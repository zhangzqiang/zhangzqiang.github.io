{"meta":{"title":"WHOOSH","subtitle":"生平有数，学识无涯","description":"张正强、技术分享","author":"Zhengqaing Zhang","url":"http://www.whoosh.site"},"pages":[{"title":"","date":"2018-02-15T07:43:55.192Z","updated":"2016-09-07T10:04:28.000Z","comments":true,"path":"baidu_verify_nvBydHIzNT.html","permalink":"http://www.whoosh.site/baidu_verify_nvBydHIzNT.html","excerpt":"","text":"nvBydHIzNT"},{"title":"","date":"2018-02-15T07:43:55.192Z","updated":"2018-02-10T18:03:24.000Z","comments":true,"path":"categories/index.html","permalink":"http://www.whoosh.site/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-02-15T07:43:55.176Z","updated":"2018-02-10T18:03:24.000Z","comments":true,"path":"about/index.html","permalink":"http://www.whoosh.site/about/index.html","excerpt":"","text":""},{"title":"","date":"2018-02-15T07:43:55.207Z","updated":"2018-02-10T18:03:24.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.whoosh.site/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"搭建前端开发环境","slug":"20180704_搭建前端开发环境","date":"2018-07-04T13:13:58.000Z","updated":"2018-07-04T13:33:06.445Z","comments":true,"path":"2018/07/04/20180704_搭建前端开发环境/","link":"","permalink":"http://www.whoosh.site/2018/07/04/20180704_搭建前端开发环境/","excerpt":"","text":"VS Code Visual Studio Code 是一个运行在桌面上，并且可用于Windows，Mac OS X和Linux平台的的轻量级且功能强大的源代码编辑器。它配备了内置的JavaScript的，TypeScript和Node.js的支持，并具有其他语言（C ++，C＃，Python和PHP）的扩展以及一个丰富的生态系统。 下载 下载相应操作系统的Visual Studio Code 安装 Mac OS X 双击下载的存档展开内容 拖动Visual Studio Code.app至Applications文件夹，在Launchpad中点击打开 右键点击Dock栏中的VS Code图标，依次选择选项、在Dock中保留。 Linux 通过任一GUI软件包管理系统安装只需双击包文件即可，或者也可以使用命令行安装: 12345678#For .debsudo dpkg -i &lt;file&gt;.deb#For .rpm (Fedora 21 and below)sudo yum install &lt;file&gt;.rpm#For .rpm (Fedora 22 and above)sudo dnf install &lt;file&gt;.rpm 现在VS Code应该可以通过launcher或在命令行中输入code运行了。 Windows 双击VSCodeSetup.exe开始安装，这将会花费几分钟 64-bit构架下，VS Code默认将会安装在C:\\Program Files (x86)\\Microsoft VS Code下，你也可以自定义安装位置。 使用 在终端中使用VS Code 安装完成之后，运行VS Code。现在，打开命令面板（按F1键）输入Shell 命令找到Shell 命令: 在PATH中安装“code”命令。命令执行完成之后，重启终端工具使新的$PATH可用。现在，您可以简单地在终端中任意文件夹下输入‘code .’来编辑该文件夹下的文件了。 附加组件 VS Code的安装包不大且只包含各种开发工作中共享的最小数量的组件，包括例如编辑器、文件管理、窗口管理和用户设置等基本功能。JavaScript/TypeScript语言服务和Node.js调试器也属于基本组件范畴。 以下是几个常用的已安装组件： git - VS Code内部支持了源代码版本控制系统git，但是需要您电脑中预先安装好了git Node.js -包含NPM，一个快速搭建运行JavaScript应用的平台和运行时 TypeScript - TypeScript编译器 Typings - 一个TypeScript类型定义管理程序，让VS Code可以为流行的JavaScript框架提供智能感知 添加扩展 VS Code扩展让第三方提供额外的支持： 语言 - C++, C#, Go, Python .etc 工具 - ESLint, JSHint , PowerShell .etc 调试器 - Chrome, PHP XDebug .etc 扩展融入了VS Code的用户界面、命令行和任务运行系统，所以您会发现通过VS Code的共享接口很容易使用不同的技术工作。点此查看VS Code扩展市场发现新东西。 附加工具 Visual Studio Code整合了现有工具链。下述工具可以提升您的开发体验。 Yeoman - 一个应用搭建工具， 想象成命令行版本的 文件 &gt; 新建工程 generator-aspnet - 一个搭建ASP.NETCore应用的Yeoman生成器 hottowel - 一个快速创建AngularJS应用的Yeoman生成器 Express - 使用 Jade 模板引擎的Node.js应用框架 gulp - 基于流的自动化构建工具，可以很容易地整合进VS Code任务 mocha - 运行于Node.js之上的JavaScript测试框架 bower - 客户端软件包管理器 Node.js Node.js® 是一个基于Chrome V8引擎的 JavaScript 运行时。 Node.js 使用高效、轻量级的事件驱动、非阻塞 I/O 模型。它的包生态系统npm，是目前世界上最大的开源库生态系统。 如果你已经安装了VS Code了，可以跳过这一步，因为VS Code已经帮你把Node安装好了，但是如果你不需要使用VS Code，而是使用其他代码编辑器，有可能需要自行安装Node。 下载 下载相应系统的Node.js，如有需要，可下载历史版本。 安装 Mac OS X 双击下载的node-v8.xx.xx.pkg安装包，并按照提示进行安装即可。该过程会自动安装包管理器npm。 Linux 将下载的node-v8.xx.xx-linux-x64.tar.xz文件，放在指定的目录下。 12345678910111213#进入文件存放路径下，解压tar xf node-v8.xx.xx-linux-x64.tar.xz#解压后进入到解压后的文件夹cd node-v8.xx.xx-linux-x64#设置node和npm为全局变量ln -s /home/chuan/chuansoft/node-v8.xx.xx-linux-x64/bin/node /usr/local/bin/nodeln -s /home/chuan/chuansoft/node-v8.xx.xx-linux-x64/bin/npm /usr/local/bin/npm#随便进入到其他文件夹测试node -vnpm -v Windows 双击node-v8.xx.xx-x64.msi开始安装，这将会花费几分钟 检测PATH环境变量是否配置了Node.js，点击开始=》运行=》输入”cmd” =&gt; 输入命令”path” 一般情况下安装程序会自动将node和npm的环境变量配置好，如果发现path中没有对应的环境变量，需要手动配置环境变量 NPM/Yarn npm 是 JavaScript 世界的包管理工具,并且是 Node.js 平台的默认包管理工具。通过 npm 可以安装、共享、分发代码,管理项目依赖关系。 yarn 是 Facebook, Google, Exponent 和 Tilde 开发的一款新的 JavaScript 包管理工具。和npm有着类似的模式，不过yarn不是分支，它解决了npm的一些缺陷，并且比npm更为高效。 常用操作 使用帮助 如果npm/yarn的命令记不清，可以通过帮助命令来查询相应命令的具体使用方式，通过对工具命令的学习将会帮组你更加有效的使用命令。 12345#npmnpm -h#yarnyarn -h 开始一个新工程 创建一个空目录package，在目录生成package.json文件 123456#npmnpm init#yarn#添加-y | --yes 参数则跳过会话，直接通过默认值生成 package.jsonyarn init -y 添加一个依赖 12345678910111213141516171819#npm#全局安装npm install &lt;packageName&gt; -g#依赖会记录在 package.json 的 dependencies 下npm install &lt;packageName&gt; -save#依赖会记录在 package.json 的 devDependencies 下npm install &lt;packageName&gt; -save-dev#yarn#全局安装yarn add &lt;packageName&gt; -g#依赖会记录在 package.json 的 dependencies 下yarn add &lt;packageName&gt;#--dev可以使用-D表示，依赖会记录在 package.json 的 devDependencies 下yarn add &lt;packageName&gt; --dev 更新一个依赖 1234567891011121314151617181920#npm#更新 package.json 所有依赖项，但不记录在 package.json 中#可以通过 ‘--save|--save-dev’ 指定升级哪类依赖npm update#升级指定包npm update &lt;packageName&gt; --save-dev# 忽略版本规则，升级到最新版本，并且更新 package.jsonnpm update --latest#yarn#更新 package.json 所有依赖项，但不记录在 package.json 中yarn upgrade# 升级指定包yarn upgrade &lt;packageName&gt;# 忽略版本规则，升级到最新版本，并且更新 package.jsonyarn upgrade --latest 移除一个依赖 123456#npm#可以指定 --save | --save-devnpm uninstall &lt;packageName&gt; --save#yarnyarn remove &lt;packageName&gt; 安装 package.json 中的所有文件 如果 node_modules 中有相应的包则不会重新下载 –force 可以强制重新下载安装 12345#npmnpm install#yarnyarn install --force 运行脚本 在package.json文件中有一段代码如下所示: 1234567&#123; \"scripts\": &#123; \"dev\": \"node app.js\", \"start\": \"node app.js\" &#125;&#125; start作为默认指令，不需要run命令，直接运行npm start或者yarn start即可，在实际开发中，在scripts下添加自定义的命令来满足业务需要。 123456789#npm# 执行 dev 对应的脚本 node app.jsnpm run devnpm start#yarn# 执行 dev 对应的脚本 node app.jsyarn run devyarn start 列出项目的所有依赖 12345678910111213141516171819#npm#列出当前项目的依赖npm list#限制依赖的深度npm list --depth=0#列出全局安装的模块sudo npm list --depth=0 -g#yarn#列出当前项目的依赖yarn list#限制依赖的深度yarn list --depth=0#列出全局安装的模块sudo yarn list -g 显示某个包信息 12345678910111213141516171819#npm#查看某个模块的最新版本信息npm info &lt;packageName&gt;#输出 json 格式npm info &lt;packageName&gt; --json#输出 README 内容npm info &lt;packageName&gt; readme#yarn#查看某个模块的最新版本信息yarn info &lt;packageName&gt;#输出 json 格式yarn info &lt;packageName&gt; --json#输出 README 内容yarn info &lt;packageName&gt; readme 缓存 1234567891011#npm#清除缓存sudo npm cache clean#yarn#列出已缓存的每个包sudo yarn cache list#返回 全局缓存位置sudo yarn cache dir#清除缓存sudo yarn cache clean 设置镜像总所周知的原因，如果你没有科学上网的途径，可能需要通过国内镜像来解决网络问题，其中最为有效和常用的就是淘宝镜像： NPM设置淘宝镜像 12345678#查询当前配置的镜像npm get registry#设置成淘宝镜像npm config set registry http://registry.npm.taobao.org/#换成原来的npm config set registry https://registry.npmjs.org/ Yarn设置淘宝镜像 12345678#查询当前配置的镜像yarn config get registry#设置成淘宝镜像yarn config set registry http://registry.npm.taobao.org/#换成原来的yarn config set registry https://registry.yarnpkg.com Git git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。起初是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。它采用了分布式版本库的方式，不必服务器端软件支持。 git 与 svn 区别点： git是分布式的分布式的版本控制系统，svn不是。 git把内容按元数据方式存储，而svn是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。 git分支和svn的分支不同：分支在svn中一点不特别，就是版本库中的另外的一个目录。 git没有一个全局的版本号，而svn有：目前为止这是跟svn相比git缺少的最大的一个特征。 git的内容完整性要优于svn：git的内容存储使用SHA-1算法确保代码内容的完整性，在遇到磁盘故障和网络问题时降低对版本库的破坏。 下载虽然VS Code内部支持了源代码版本控制系统git，但是需要您电脑中预先安装好了git才能在VS Code中使用。 下载相应操作系统的git 安装 Mac OS X 双击下载的git-xxx.dmg安装包，并按照提示进行安装即可。 Linux Debian/Ubuntu 123456$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\libz-dev libssl-dev$ apt-get install git-core$ git --version Centos/RedHat 123456$ yum install curl-devel expat-devel gettext-devel \\openssl-devel zlib-devel$ yum -y install git-core$ git --version Windows 双击git-xxx.exe开始安装，这将会花费几分钟 完成安装之后，就可以使用命令行的 git 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。 在开始菜单里找到”Git”-&gt;”Git Bash”，会弹出 Git 命令窗口，你可以在该窗口进行 Git 操作 使用首先我们必须要先理解Git这几个概念：暂存区，本地仓库，远程仓库。 暂存区：是我们每一次进行代码修改的地方，例如我们ieda的所编译的代码就是缓存区 本地仓库：是我们每一次从远程仓库pull(拉取)到地方，这个地方就是本地仓库 ，他其实就是远程仓库的一个副本 远程仓库：这个是存放到服务器上的代码，是每一个人认为自己的代码修改好了，就可以集体上传到一个地方，而你也可以从这个地方下载别人的代码，这个地方就是远程仓库。 通过下图可以对暂存区，本地仓库，远程仓库有一个整体的了解 配置git 设置全局配置 123#git config --global user.name \"your name\"git config --global user.email \"your email\" 进入你的项目目录 12345678910#首先指定到你的项目目录下cd ./demogit inittouch README.mdgit add README.mdgit commit -m \"first commit\"#指定github仓库的url，demo为仓库名称,使用时必须先创建git remote add origin https://github.com/yourname/demo.git#提交到你的仓库git push -u origin master 在VS Code中使用 打开GIT工作区，所有修改的文件详情都会显示在这里 点击+号，把所有文件提交到暂存区；同上单击左边撤销图标可以将对本文件做的修改撤销 然后打开菜单选择–提交已暂存的 然后按提示随便在消息框里输入一个消息（本次代码提交备注，以备后期查看，如添加按钮等等），再按ctrl+enter提交 拉取别人更新代码（pull）：提交新的代码之前一定要先进行该操作，保证本地仓库是从远程仓库拉下来的最新版本，否则会产生冲突 然后把所有暂存的代码push云端（友情提示：进行该操作之前必须进行上一操作：pull新代码） 在执行推送之前点击“推送到”可以核对推送的远程仓库详细信息，比如是master主分支还是dev分支 如果此时发现是master主分支可以进行分支切换：git checkout dev(切换到dev分支) 写在最后至此，我们已经完成了前端开发环境的搭建工作，为接下来愉快的编程提供了良好的开端。加油吧，少年！","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://www.whoosh.site/categories/前端技术/"}],"tags":[{"name":"React","slug":"React","permalink":"http://www.whoosh.site/tags/React/"},{"name":"Web","slug":"Web","permalink":"http://www.whoosh.site/tags/Web/"}]},{"title":"前端UI设计语言评估与分析","slug":"20180701_前端UI设计语言评估与分析","date":"2018-07-01T09:13:58.000Z","updated":"2018-07-04T13:10:36.019Z","comments":true,"path":"2018/07/01/20180701_前端UI设计语言评估与分析/","link":"","permalink":"http://www.whoosh.site/2018/07/01/20180701_前端UI设计语言评估与分析/","excerpt":"","text":"目前状况由于公司业务不断延伸，在技术选型上越来越倾向于浏览器/服务器（B/S）架构模式，但是就现有系统和正在开发的系统而言，缺乏统一的前端技术方案，具体就不列举了，只简单说下：例如Web端采用的技术有ExtJS、BootStrap、Jquery等；APP端的采用的技术有原生Android，ReactNative跨平台移动开发技术等。 由于开发资源的限制，在维护原有系统和开发新系统上面临资源难以满足业务发展需要的问题。考虑到公司平台融合战略，我们需要选择一个优秀的前端UI设计以减少开发人员在页面样式和动效上的时间投入，聚焦于功能实现的开发，提高整体的开发效率。 UI设计对比与分析目前比较流行的UI设计有Google的Material Design、蚂蚁金服的Ant Design、以及Twitter的Bootstrap。仅从设计角度来说，Material Design具有严格的设计规范，Bootstrap是纯粹的UI框架。而Ant Design，介于这两者之间。就这三种UI设计，我们做了如下对比： 对比项 Material Design Ant Design Bootstrap 维护团队 Google 蚂蚁金服 Twitter GitHub活跃度 16.2K 30.2K 126K 主要适用框架 Angular React Jquery 授权协议 MIT MIT MIT 浏览器兼容性 现代浏览器及IE9+ 现代浏览器及 IE9+ 现代浏览器及 IE8+ 优缺点分析 提供全面的设计规范文档，但缺少官方中文说明；有很多优秀的UI框架遵照Material Design规范，诸如：Material UI、MDUI等，开发难度略高 提供全面的规范说明和组件，统一中台项目的前端 UI 设计，屏蔽不必要的设计差异和实现成本，解放设计和前端的研发资源。 适用于大部分前台项目的页面开发，基于它的插件也非常多，但在引用后导致管理混乱和不便的情况也很普遍。 体验地址 https://demos.creative-tim.com/material-dashboard-react https://preview.pro.ant.design http://adminlte.la998.com 最后，考虑到文档和资源的易用性、更加现代化的React框架和UI设计的匹配性，以及国内商业环境等因素，推荐使用Ant Design作为我们首选的UI设计语言。 面临的问题虽然，Ant Design非常适合作为我们的前端UI框架，但也面临着一些问题，诸如： 需要结合React才能最大程度发挥其实用价值，但是React的学习成本和门槛又比较高，对前端开发人员的技能要求就较高。需要通过培训现有人员或引入外部人员来提高团队成员的技能。 经过验证，由于浏览器的兼容性，React+Ant这个模式无法直接运行在装置前端的浏览器中，需要通过外部电脑访问的形式提供界面浏览。 由于Ant Design提供的是定制化的组件，当业务中需要引入某些Ant Design无法提供的组件的时候，由于缺乏专业的UI的人员，很难做到和其提供的组件达到一致的样式和操作体验。建议招聘专业的UI设计人员辅助开发人员提高开发效率。","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://www.whoosh.site/categories/前端技术/"}],"tags":[{"name":"React","slug":"React","permalink":"http://www.whoosh.site/tags/React/"},{"name":"Web","slug":"Web","permalink":"http://www.whoosh.site/tags/Web/"}]},{"title":"前端框架评估与分析","slug":"20180624_前端框架评估与分析","date":"2018-06-24T12:13:58.000Z","updated":"2018-07-04T13:13:40.395Z","comments":true,"path":"2018/06/24/20180624_前端框架评估与分析/","link":"","permalink":"http://www.whoosh.site/2018/06/24/20180624_前端框架评估与分析/","excerpt":"","text":"是否需要使用框架我想答案是肯定的。我们知道前端技术规范里有海量的API，浏览器也很难做到完全的兼容，对于主张手写Javascript的人（一般都是牛的不能行的大神），确实可以做到不用框架。但是，我认为这样会导致时间的浪费，不仅是个人的时间浪费，还会拉低团队的工作效率。在大多数情况下，由于团队成员水平不一，会给产品开发和维护带来更大的成本投入，而且这种行为也不利于团队发展，极易导致技能和经验无法的得到有效延续。 很显然，一些优秀的团队或组织在不断地为前端技术框架贡献着自己的力量，能让我们站在巨人的肩膀上更加专注于自己业务的实现。接下来，我主要介绍几个目前市面上比较流行的前端框架，以供大家甄选。 Angular优势Angular的最大优势莫过于它的流行程度，可能是Goolgle的缘故吧。早在Angular 1推出之后，人们发现对于开发单页面 web 应用程序更加符合MVVM模式。通过对Angular 1进行现代化演变和重新构建框架的某些部分，以及一套用于构建用户界面的丰富组件，使得Angular 2+有了真正意义上的爆发了。 劣势单页面应用程序如果没有提前对功能进行设计，容易导致整个项目难以维护。而且在实际项目中，运行时提供不属于核心框架的技术往往让人难以理解，这也极大的降低了TypeScript对最终开发者的价值。 何时选择 可以在一个大型的框架内获取技术资源，而且框架内的技术通常很容易移植； 你的应用能够很好的转化为标准的模型-视图模式 你对 Google Material UX 设计模式满意，那么 Material Angular 是遵循该模式的一种快速、简单且可靠的方式 需要注意的是 Angular1（angular.js）与 Angular2+ 是截然不同的，其中的应用、技术和经验不能直接移植到 Angular2+ 的开发中去。有理由相信在 Google 的持续支持下，Angular 会越来越成熟。 React优势 速度快：运用了Virtual Dom技术，Reactjs只在调用setState的时候会更新dom，而且还是先更新Virtual Dom，然后和实际Dom比较，最后再更新实际Dom。 兼容性好：Virtual DOM帮助我们解决了跨浏览器问题，它为我们提供了标准化的API，甚至在IE8中都是没问题的(0.x.x版本)。 组件化：代码更加模块化，重用代码更容易，可维护性高。 单向数据流：通常结合Redux进行状态管理，而Redux是JavaScript状态容器，提供可预测化的状态管理。 同构、纯粹的javascript：因为搜索引擎的爬虫程序依赖的是服务端响应而不是JavaScript的执行，预渲染你的应用有助于搜索引擎优化。 易于打包：比如使用RequireJS来加载和打包，而Browserify和Webpack适用于构建大型应用。它们使得那些艰难的任务不再让人望而生畏。 劣势React本身并不是一个完整的框架，所以大型项目想要一套完整的框架的话，基本都需要加上ReactRouter和Redux才能写大型应用。要构建一个功能丰富的 Web 应用程序，你需要许多功能，一旦脱离 React 和 Redux 和其他一些库的核心，你将发现一个非常分散的社区，拥有无数的解决方案和模式，不容易整合在一起。 因此，虽然 React 和 Redux 都是非常专注的库，但缺乏经验的团队还是会很容易地生成不可维护的解决方案，而不是意识到他们所做的选择会导致性能不佳或错误。 即使有经验的开发人员也可能意识到，一个松散的架构或惯例可能会在未来困扰他们。 何时选择 如果你想构建一次编写，到处运行的程序，并且结合React Native实现Web和App双端展示，React是很好的选择 或者你很少需要手把手指导，并且正在寻找更好的库而不是全面的框架，那么React + Redux会给你很好的选择。 Vue优势vue.js 最大的优势是渐进式构建能力，因为是一个构建数据驱动的 web 界面的渐进式框架。其目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。核心是一个响应的数据绑定系统。 另外，它有一个强大且充满激情的社区，这也为其增加了巨大的价值，使得为一个空白项目创建一个综合的解决方案变得十分容易。 劣势vue的社区问题比较突出，核心的开发基本落在个人（尤雨溪）身上，而其他的项目基本是由一个组织提供支持。 何时选择 如果你有一个传统的 web 应用程序，并需要一个强壮稳健的应用程序层，那么 vue.js 可能是一个很好的选择，它有清晰的模式，即使没有经验的团队也能正确或者错误的使用它。 写在最后通过对Angular、React、Vue一些浅显的分析，在选择前端框架的时候更能找到适合自己或团队的方案。就我们团队而言，我们采用了React，除了上述的原因分析外，还有一个主要原因就是我们希望统一Web端和App端开发技术，这样能最大程度的提高团队开发效率。","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://www.whoosh.site/categories/前端技术/"}],"tags":[{"name":"React","slug":"React","permalink":"http://www.whoosh.site/tags/React/"},{"name":"Web","slug":"Web","permalink":"http://www.whoosh.site/tags/Web/"}]},{"title":"项目相关方管理","slug":"20180616_项目相关方管理","date":"2018-06-16T15:13:58.000Z","updated":"2018-06-20T22:39:28.929Z","comments":true,"path":"2018/06/16/20180616_项目相关方管理/","link":"","permalink":"http://www.whoosh.site/2018/06/16/20180616_项目相关方管理/","excerpt":"","text":"相关方管理 识别能够影响项目或受项目影响的人员、团体或组织，分析相关方对项目的期望和影响，制定合适的管理策略来有效调动相关方参与项目决策和执行。 在项目章程被批准、项目经理被委任，以及团队开始组建之后，尽早开始识别相关方应引导相关方参与 应用共创的概念，咨询最受项目工作或成果影响的相关方 相关方满意度应作为项目目标加以识别和管理识别相关方 定义 定期识别项目相关方，分析和记录他们的利益、参与度、相互依赖性、影响力和对项目成功的潜在影响的过程 作用 使项目团队能够建立对每个相关方或相关方群体的适度关注 时间点 整个项目期间定期开展ITTO 输入（I） 项目章程 通常在编制和批准项目章程之前或同时展开首次识别相关方 商业文件 商业论证，效益管理计划 项目管理计划 首次识别相关方时，项目管理计划并不存在 沟通管理计划 相关方参与计划 项目文件 并非任何项目文件都将成为首次识别相关方的输入 变更日志，问题日志，需求文件 协议 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 数据收集 问卷调查 头脑风暴 头脑写作 书面形式的头脑风暴 数据分析 相关方分析 产生相关方和关于相关方的各种信息，如兴趣、权利、所有权、知识、贡献等 文件分析 评估项目文件、以往项目的经验教训等 数据表现 相关方映射分析/表现 权力利益方格 权力高，利益低，令其满意 权力高，利益高，重点关注 权力低，利益低，一般监督 权力低，利益高，随时告知 凸显模型 通过评估相关方权力、紧迫性和合法性，对相关方进行分类 适用于复杂的相关方网络 影响方向 向上，向下，向外，横向 优先级排序：大量相关方或成员频繁变化 会议 输出（O） 相关方登记册 包括身份信息、评估信息、相关方分类等 变更请求 项目管理计划更新 需求管理计划、沟通管理计划、风险管理计划、相关方参与计划 项目文件更新 假设日志、问题日志、风险登记册规划相关方参与 定义 根据相关方的需求、期望、利益和对项目的潜在影响，制定相关方参与项目的方法的过程 作用 提供与相关方进行有效互动的可行计划 时间点 整个项目期间定期开展ITTO 输入（I） 项目章程 项目管理计划 资源管理计划，沟通管理计划，风险管理计划 项目文件 假设日志，变更日志，问题日志，项目进度计划，风险登记册，相关方登记册 协议 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 数据收集 标杆对照 数据分析 假设条件和制约因素分析 根本原因分析 决策 优先级排序或分级 数据表现 思维导图 相关方参与度评估矩阵 不了解型：不知道项目及其潜在影响 抵制型：知道项目及其潜在影响，但抵制项目工作或成果可能引发的任何变更 中立型：了解项目，但既不支持，也不反对 支持型：了解项目及其潜在影响，并且会支持项目工作及成果 领导型：了解项目及其潜在影响，而且积极参与以确保项目取得成功 会议 输出（O） 相关方参与计划 随之相关方社区的变化，定期审查和更新该计划 确定用于促进相关方有效参与决策和执行的策略和行动管理相关方参与 定义 与相关方进行沟通和协作以满足其需求与期望、处理问题、并促进相关方合理参与的过程 作用 让项目经理能够提高相关方的支持，并尽可能降低相关方的抵制 时间点 整个项目期间开展ITTO 输入（I） 项目管理计划 沟通管理计划，风险管理计划，相关方参与计划，变更管理计划 项目文件 变更日志，问题日志，经验教训登记册，相关方登记册 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 沟通技能 反馈 人际关系与团队技能 冲突管理，文化意识，谈判，观察/交谈 政治意识 基本规则 明确项目团队成员和其他相关方采取什么行为去引导相关方参与 会议 输出（O） 变更请求 项目管理计划更新 沟通管理计划，相关方参与计划 项目文件更新 变更日志，问题日志，经验教训登记册，相关方登记册监督相关方参与 定义 监督项目相关方关系，并通过修订参与策略和计划来引导相关方合理参与项目的过程 作用 随着项目进展和环境变化，维持或提升相关方参与活动的效率和效果 时间点 整个项目期间开展ITTO 输入（I） 项目管理计划 资源管理计划，沟通管理计划，相关方参与计划 项目文件 问题日志，经验教训登记册，项目沟通记录，风险登记册，相关方登记册 工作绩效数据 事业环境因素和组织过程资产 工具与技术（TT） 数据分析 备选方案分析 根本原因分析 相关方分析 决策 多标准决策分析 投票：应对相关方参与水平偏差的最佳方案 数据表现 相关方参与度矩阵：跟踪每个相关方参与水平的变化，对相关方参与加以监督 沟通技能 反馈：确保发送给相关方的信息被接受和理解 演示：为相关方提供清晰的信息 人际关系与团队技能 积极倾听：减少理解错误和沟通错误 文化意识：文化差异和文化需求 领导力：传递愿景并激励相关方 人际交往：了解相关方参与水平 政治意识：有助于理解组织战略 会议 输出（O） 工作绩效信息 变更请求 项目管理计划更新 资源管理计划，沟通管理计划，相关方参与计划 项目文件更新 问题日志，经验教训登记册，风险登记册，相关方登记册","categories":[{"name":"项目管理","slug":"项目管理","permalink":"http://www.whoosh.site/categories/项目管理/"}],"tags":[{"name":"PMP","slug":"PMP","permalink":"http://www.whoosh.site/tags/PMP/"},{"name":"PMBOK","slug":"PMBOK","permalink":"http://www.whoosh.site/tags/PMBOK/"}]},{"title":"项目采购管理","slug":"20180609_项目采购管理","date":"2018-06-09T13:13:58.000Z","updated":"2018-06-20T23:45:26.079Z","comments":true,"path":"2018/06/09/20180609_项目采购管理/","link":"","permalink":"http://www.whoosh.site/2018/06/09/20180609_项目采购管理/","excerpt":"","text":"采购管理 项目经理无权签署对组织有约束力的法律协议规划采购管理 定义 记录项目采购决策、明确采购方法及识别潜在卖方的过程 作用 确定是否从项目外部获取货物和服务，如果是，则还要确定将在什么时间，以什么方式获取什么货物或服务 时间点 仅开在一次或仅在项目预定义的节点开展ITTO 输入（I） 项目章程 商业文件 商业论证， 收益管理计划 项目管理计划 范围管理计划 如何在项目的实施阶段管理承包商的工作范围 质量管理计划 可用于供应商资格预审或甄选 资源管理计划 包括哪些资源需要采购或租赁的信息，以及影响采购的假设条件或制约因素 范围基准 范围基准。包括范围说明书、WBS、WBS词典 项目文件 里程碑清单，项目团队派工单，需求文件，需求跟踪矩阵，资源需求，风险登记册，相关方登记册 事业环境因素 组织过程资产 预先批准的卖方清单 正式的采购政策、程序和指南 合同类型 总价合同 已明确定义需求，且不会出现重大范围变更的情况下使用 固定总价合同（FFP） 大多数采用，货物采购的价格一开始确定，且不允许改变（除非范围变更） 总价+激励费用（FPIF） 允许一定的绩效偏离，会设置价格上限，高于此价格上限的全部成本由卖方承担 总价+经济价格调整（FPEPA） 卖方履约期长（跨越几年时间），或将以不同货币支付价款 成本补偿合同 向卖方支付为完成工作发生的全部合法实际成本，外加一笔费用作为卖方的利润，适用于范围可能发生重大变更情况 成本+固定费用（CPFF） 为卖方报销履行合同工作所发生的一切可列成本，并向卖方支付一笔固定费用 成本＋激励费用（CPIF） 为卖方报销履行合同工作所发生的一切可列成本，并在卖方达到合同规定的绩效目标时，向卖方支付预先确定的激励费用 成本＋奖励费用（CPAF） 为卖方报销履行合同工作所发生的一切可列成本，但只有在卖方满足合同规定的、某些笼统主观绩效标准的情况下，才向卖方支付大部分费用，奖励费用完全由买方主观决定是否给予，且不允许申述 工料合同（T&amp;M） 适用于在无法快速编制出准确的工作说明书的情况下扩充人员、聘用专家或寻求外部支持，即时间紧任务重，不适用长期合同 工具与技术（TT） 专家判断 数据收集 市场调研 数据分析 自制或外购分析 可以使用回收期（PBP）、投资回报率（ROI）、内部报酬率（IRR）、现金流贴现、净现值（NPV）、收益成本（BAC）、或其他分析技术 供方选择分析 最低成本 适用于标准化或常规化采购 仅凭资质 适用于采购价值相对较小，不值得花费时间和成本开展完整选择过程 基于质量或技术方案得分 先对技术建议书进行评估，考察技术方案的质量 基于质量和成本 独有来源 特定卖方 固定预算 在预算内选择技术建议书得分最高的卖方 会议 输出（O） 采购管理计划 包含必要在采购过程中开展的各种活动，记录是否要开展国际竞争性招标、国内竞争性招标、当地招标 如何协调采购与项目的其他工作 开展重要采购活动的时间表 管理合同的采购测量指标 采购有关的相关方角色和职责 影响采购工作的制约因素和假设条件 司法管辖权和付款货币 风险管理事项 拟使用的预审合格的卖方 采购策略 交付方法 合同支付类型 采购阶段 招标文件 用于向潜在卖方征求建议书 信息邀请书（RFI） 需要卖方提供拟采购货物和服务更多信息 报价邀请书（RFQ） 需要卖方提供关于满足需求对应的成本信息 建议邀请书（RFP） 项目中出现问题且解决办法难以确定，这是最正式的邀请书文件 采购工作说明书（SOW） 包括规格、所需数量、质量水平、绩效数据、履约期间、工作地点和其他要求 在采购过程中，根据需要对工作说明书进行修订，直到成为所签协议的一部分 对于服务采购，可能用的是工作大纲（TOR） 供方选择标准 能力和潜能 产品成本和生命周期成本 具体的相关经验 公司的财务稳定 自制或外购决策 独立成本估算 针对大型采购，采购组织可以自行准备独立估算，或聘请外部专业估算师，并将其作为评价卖方报价的对照基准 变更请求 项目文件更新 经验教训登记册，里程碑清单，需求文件，需求跟踪矩阵，风险登记册，相关方登记册 组织过程资产更新 采购文件：采购管理计划、采购策略、工作说明书、招标文件实施采购 定义 获取卖方应答、选择卖方并授予合同的过程 作用 选定合格卖方并签署关于货物或服务交付的法律协议，包括正式合同 时间点 整个项目期间开展 备注 招标流程：招标、投标、评标、授标ITTO 输入（I） 项目管理计划 采购管理计划，范围管理计划，需求管理计划，沟通管理计划，风险管理计划，配置管理计划，成本基准 项目文件 经验教训登记册，项目进度计划，需求文件，风险登记册，相关方登记册 采购文档 招标文件，采购工作说明书，独立成本估算，供方选择标准 卖方建议书 卖方为响应采购文件包而编制的建议书，其中包含的基本信息将被评估团队用于选定一个或多个投标人 事业环境因素 组织过程资产 工具与技术（TT） 专家判断 广告-招标 产品、服务或成果与用户或潜在用户进行的沟通 投标人会议-投标 在卖方提交建议书之前，在买方与潜在卖方之间召开的会议 目的是去报所有潜在投标人对采购要求都有清楚且一致的理解 数据分析-评标 建议书评价 人际关系与团队技能-授标 谈判 输出（O） 选定的卖方 在建议书评估或投标评估中被判断为最有竞争力的投标人 协议 合同对买卖双方都有约束力，强制卖方提供规定的产品、服务或成果，强制买方向卖方支付相应的报酬 变更请求 项目管理计划更新 需求管理计划，质量管理计划，沟通管理计划，风险管理计划，采购管理计划，范围基准、成本基准、进度基准 项目文件更新 经验教训登记册，需求文件，需求跟踪矩阵、资源日历、风险登记册，相关方登记册 组织过程资产更新控制采购 定义 管理采购关系，监督合同绩效，实施必要的变更和纠偏，以及关闭合同的过程 作用 确保买卖双方履行法律协议，满足项目需求 时间点 整个项目期间开展 备注 买卖双方都出于相似的目的来管理采购合同，都必须确保双方履行合同义务，确保各自的合法权利得到保护 绩效审查：买方对卖方的过程审查 检查：买方对卖方可交付成果的检查 审计：买方对自己采购过程的审计 合同提前终止条件：双方协商一致、一方违约、买方便利 合同提前终止应对措施：卖方应该就卖方为该合同或部分所作的准备工作给予补偿，就合同中已经完成或验收的工作支付报酬ITTO 输入（I） 项目管理计划 需求管理计划，风险管理计划，采购管理计划，变更管理计划，进度基准 项目文件 假设日志，经验教训登记册，里程碑清单，质量报告，需求文件，需求跟踪矩阵，风险登记册，相关方登记册 协议 采购文档 批准的变更请求 工作绩效数据 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 索赔管理 1.谈判；2.替代争议解决方法（ADR）；3.起诉 谈判是解决所有索赔和争议的首选方法 数据分析 绩效审查 挣值分析 趋势分析 检查 对卖方正在执行的工作进行结构化审查，可能涉及对可交付成果的简单审查，或对工作本身的实地审查。确认范围过程针对的是对核实的可交付成果 审计 对采购过程的结构化审查，在采购合同中明确审计的权力和义务 输出（O） 采购关闭 买方通常通过其授权的采购管理员，向卖方发出合同已经完成的正式书面通知 工作绩效信息 变更请求 采购文档更新 采购管理计划、采购策略、工作说明书、招标文件 项目管理计划更新 风险管理计划，采购管理计划，进度基准，成本基准 项目文件更新 经验教训登记册，资源需求，需求跟踪矩阵，风险登记册，相关方登记册 组织过程资产更新 支付计划和请求，卖方绩效评估文件，预审合格卖方清单更新，经验教训知识库，采购档案","categories":[{"name":"项目管理","slug":"项目管理","permalink":"http://www.whoosh.site/categories/项目管理/"}],"tags":[{"name":"PMP","slug":"PMP","permalink":"http://www.whoosh.site/tags/PMP/"},{"name":"PMBOK","slug":"PMBOK","permalink":"http://www.whoosh.site/tags/PMBOK/"}]},{"title":"项目风险管理","slug":"20180602_项目风险管理","date":"2018-06-02T03:53:18.000Z","updated":"2018-06-22T07:48:26.440Z","comments":true,"path":"2018/06/02/20180602_项目风险管理/","link":"","permalink":"http://www.whoosh.site/2018/06/02/20180602_项目风险管理/","excerpt":"","text":"风险管理 规划风险管理旨在利用或强化正面风险（机会），规避或减轻负面风险（威胁） 风险三要素：风险事件、概率、影响 整体项目风险大于单个项目风险之和 风险临界值反映了组织与项目相关方的风险偏好程度，是项目目标的可接受的变异程度 项目风险管理的发展趋势和新兴实践： 非事件类风险：变异性风险（蒙特卡洛模拟）、模糊性风险 项目韧性 整合式风险管理规划风险管理 定义 定义如何实施项目风险管理活动的过程 作用 确保风险管理的水平、方法和可见度与项目风险程度，以及项目对组织和其他相关方的重要程度相匹配 时间点 仅开展一次或在预定义点开展 备注 已知-已知风险：已识别且有应对计划，计入项目预算（时间/成本） 已知-未知风险：已识别但无法主动管理，计入应急储备 未知-未知风险：未识别且无法主动管理，计入管理储备 ITTO 输入（I） 项目章程 项目管理计划 所有已批准的子管理计划，使风险管理计划与之相协调 项目文件 相关方登记册 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 数据分析 相关方分析：确定相关方的风险偏好 会议 输出（O） 风险管理计划 风险管理战略：描述管理项目风险的一般方法 方法论：风险管理的具体方法、工具及数据来源 角色与职责：确定相关方的角色和职责 资金：确定风险管理活动所需的资金，并制定应急储备和管理储备的使用方案 时间安排：确定在项目生命周期中实施风险管理过程的时间和频率 风险类别 借助风险分解结构（RBS）来构建风险类别，有助于识别风险和归类 相关方风险偏好 针对每个项目目标，把相关方的风险偏好表述成可测量的风险临界值 风险承受力&gt;风险偏好&gt;风险临界值 风险概率和影响定义 根据具体的项目环境、组织和关键相关方的风险偏好和临界值，来制定风险概率和影响定义 概率和影响矩阵 正面影响定义为机会、负面影响定义为威胁 用描述性术语（很高、高、中、低和很低）或数值来表达，如果使数值，就可以把两个数值相乘，得出每个风险的概率-影响分值，用于排列风险优先级 报告格式 描述风险登记册、风险报告以及项目风险管理过程的内容和格式 跟踪 确定将如何记录风险活动，以及将如何审计风险的管理过程识别风险 定义 识别单个项目风险以及整体项目风险的来源，并记录风险特征的过程 作用 记录现有单个项目风险、以及整体项目风险的来源，同时，汇集相关信息，以便团队能恰当应对已识别的风险 时间点 整个项目期间开展 备注 识别风险时，要同时考虑单个项目风险，以及整体项目风险的来源 鼓励所有相关方参与单个项目风险的识别工作 识别风险是一个迭代过程，迭代的频率和每次迭代所需的参与程度应记录在风险管理计划中ITTO 输入（I） 项目管理计划 需求管理计划，进度管理计划，成本管理计划，质量管理计划，资源管理计划，风险管理计划，范围基准，进度基准，成本基准 项目文件 假设日志，成本估算，持续时间估算，问题日志，经验教训登记册，需求文件，资源需求，相关方登记册 协议 采购文档：从外部采购项目资源，应该审查初始采购文档 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 数据收集 头脑风暴 核对单 需要考虑的项目、行动或要点的清单，常用作提醒 从类似项目和其他信息来源积累的历史信息和知识来编制 不能用核对单来取代所需的风险识别工作 经常审查核对单，增加新信息，删除或存档过时信息 访谈 数据分析 根本原因分析：石川图 假设条件和制约因素分析 从假设条件的不准确、不稳定、不一致或不完整，可以识别出威胁，通过清除或放松会影响项目或过程执行的制约因素，可以创造出机会 SWOT分析： 对项目的优势、劣势、机会和威胁进行逐个检查 文件分析 对项目文件的结构化审查，识别出一些风险 人际关系与团队技能 引导 提示清单 关于可能引发单个项目风险以及整体项目风险来源的风险类别的预设清单 作为框架用于协助项目团队形成想法 可以用风险分解结构底层的风险类别作为提示清单 会议 风险研讨会 输出（O） 风险登记册 记录已识别单个项目风险的详细信息 随着实施定性风险分析、规划风险应对、实施风险应对和监督风险等过程的开展，这些过程的结果也要记录在风险登记册 包括：已识别风险的清单、潜在风险责任人、潜在风险应对措施清单 风险报告 提供整体项目风险的信息，以及关于已识别的单个风险的概述信息 项目文件更新 假设日志，问题日志，经验教训登记册实施定性风险分析 定义 通过评估单个项目风险发生的概率和影响以及其他特征，对风险进行优先级排序，从而为后续分析或行动提供基础的过程 作用 重点关注高优先级的风险 时间点 整个项目期间开展 备注 实施定性风险分析能为规划风险应对过程确定单个项目风险的相对优先级 会为每个风险识别出责任人，以便由他们负责规划风险应对措施，并确保应对措施的实施ITTO 输入（I） 项目管理计划 风险管理计划 项目文件 假设日志，风险登记册，相关方登记册 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 数据收集：访谈 数据分析 风险数据质量评估 开展定性风险分析的基础 旨在评价关于单个项目风险的数据的准确性和可靠性 风险概率和影响评估 概率评估考虑特定风险发生的可能性，影响评估考虑的时风险对一项或多项项目目标潜在的影响 低概率和影响的风险被列入风险登记册中的观察清单，以供监控 其他风险参数评估 紧迫性，邻近性、潜伏性、可管理性、可控性、可监测性、连通性、密切度等，有助于进行更加稳健的风险优先级排序。 人际关系与团队技能：引导 风险分类 依据风险来源、受影响的项目或领域，以及其他实用类别进行分类 数据表现 概率与影响矩阵 逐一对单个项目风的发生概率及其一项或多项项目目标的影响进行评估，然后，基于所得到的概率和影响组合，使用概率和影响矩阵，来为单个项目风险分配优先级别 层级图 使用两个以上的参数对风险进行分类，例如气泡图，X轴表示可监测性，Y轴表示邻近性，气泡大小表示影响值 会议：风险研讨会 会议的目标包括审查已识别的风险、评估概率和影响，对风险进行分类和优先级排序 输出（O） 项目文件更新 假设日志、问题日志、风险登记册、风险报告实施定量风险分析 定义 就已识别的单个项目和不确定性的其他来源对整体项目目标的影响进行定量分析的过程 作用 量化整体项目风险敞口，并提供额外的定量风险信息，已支持风险应对规划 时间点 并非每个项目必须，如果采用，则在整个项目期间持续开展 备注 定量分析适用于大型或复杂的项目、具有战略重要性的项目、合同要求进行定量分析的项目、或主要相关方要求进行定量分析的项目ITTO 输入（I） 项目管理计划 风险管理计划，范围基准，进度基准，成本基准 项目文件 假设日志、估算依据、成本估算、成本预测、持续时间估算、里程碑清单、资源需求、风险登记册、风险报告、进度预测 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 数据收集：访谈 人际关系与团队技能：引导 不确定性表现方式 三角分布、正态分布、对数正态分布、贝塔分布、均匀分布和离散分布 数据分析 模拟：蒙特卡洛分析 敏感性分析：龙卷风图 有助于确定哪些单个项目风险或其他不确定性来源对项目结果具有最大的潜在影响 决策树分析 在若干个备选行动方案中选择一个最佳方案 收益取最大值、成本取最小值 影响图 不确定条件下决策制定的图形辅助工具 输出（O） 项目文件更新 风险报告 对整体项目风险敞口的评估结果 项目详细概率分析结果 单个项目风险优先级清单 定量风险分析结果的趋势 风险应对建议规划风险应对 定义 为处理整体项目风险敞口，以及应对单个项目风险，而制定可选方案、选择应对策略并商定应对行动的过程 作用 制定应对整体项目风险和单个项目风险的适当方法，还将分配资源，并根据需要将相关活动添加进项目文件和项目管理计划 时间点 整个项目期间开展ITTO 输入（I） 项目管理计划 资源管理计划、风险管理计划、成本基准 项目文件 经验教训登记册、项目进度计划、项目团队派工单、资源日历、风险登记册、风险报告、相关方登记册 事业环境因素 组织过程资产 工具与技术（TT） 专家判断 数据收集：访谈 人际关系与团队技能：引导 威胁应对策略 上报 如果项目团队或项目发起人认为某些威胁不在项目范围内，或提议的应对措施超出了项目经理的权限，就应该采用上报策略 威胁通常要上报给其目标会受该威胁影响的那个层级，一旦上报，就不再由项目团队进一步监督 规避 项目团队采取行动来消除威胁，或保护项目免受威胁的影响 包括消除威胁的原因、延长进度计划、改变项目策略、或缩小范围 转移 将应对威胁的责任转移给第三方，通常向承担威胁的一方支付风险转移费用 包括购买保险、使用履约保函、使用担保书、使用保证书，外包等 减轻 采取措施来降低威胁发生的概率和影响 包括采用简单的流程，进行多次测试，或者选用更可靠的卖方，原型开发等 接受 主动接受策略是建立应急储备、包括预留时间、资金或资源以应对出现的威胁 被动接受策略是不会主动采取行动，只是定期对威胁进行审查，确保其未发生重大改变 机会应对策略 上报 开拓 组织想确保把握住高优先级的机会，把组织中最有能力的资源分配给项目来缩短完工时间，或采用全新技术或技术升级来节约项目成本并缩短项目持续时间 分享 将应对机会的责任转移给第三方，使其享有机会所带来的部分收益 包括建立合作伙伴关系、合作团队、特殊公司或合资企业等 提高 提高机会出现的概率和影响 接受 承认机会的存在，但不主动采取措施 主动接受策略是建立应急储备；被动接受则不会主动采取行动 应急应对策略 仅在某些预定条件下才执行的应对计划，通常成为应急计划或弹回计划 弹回计划，风险发生且主要应对措施不足以应对时使用 权变措施：针对未知-未知风险，一定是威胁，动用管理储备，走变更流程 整体项目风险应对策略 规避 开拓 转移或分享 减轻或提高 接受 数据分析 备选方案分析 成本效益分析 决策 输出（O） 变更请求 项目管理计划更新 进度管理计划、成本管理计划、质量管理计划、资源管理计划、采购管理计划、范围基准、进度基准、成本基准 项目文件更新 假设日志、成本预测、经验教训登记册、项目进度计划、项目团队派工单、风险登记册、实施风险应对 定义 执行商定的风险应对计划的过程 作用 确保按计划执行商定的风险应对措施，来管理整体项目风险敞口，最小化单个项目威胁，以及最大化单个项目机会 时间点 整个项目期间开展 备注 只有风险责任人以必要的努力取实施商定的应对措施，项目的整体风险敞口和单个威胁及机会才能等到主动管理ITTO 输入（I） 项目管理计划 风险管理计划 项目文件 经验教训登记册，风险登记册，风险报告 组织过程资产 工具与技术（TT） 专家判断 人际关系与团队技能：影响力 项目管理信息系统 输出（O） 变更请求 项目文件更新 问题日志，经验教训登记册，项目团队派工单，风险登记册，风险报告监督风险 定义 监督商定的风险应对计划的实施、跟踪已识别风险、识别和分析新风险，以及评估风险管理有效性的过程 作用 使项目决策都基于关于整体项目风险敞口和单个项目风险的当前信息 时间点 整个项目期间开展ITTO 输入（I） 项目管理计划 风险管理计划 项目文件 问题日志，经验教训登记册，风险登记册，风险报告 事业环境因素和组织过程资产 工具与技术（TT） 数据分析 技术绩效分析 把项目执行期间所取得的技术成果与取得相关技术成果的计划进行比较 储备分析 在项目的任一时点比较剩余应急储备与剩余风险量，从而确定剩余储备是否仍然合理 审计 风险审计：用于评估风险管理过程的有效性 会议 风险审查会：定期安排，识别新的单个项目风险，重新评估当前风险，关闭已过时的风险 输出（O） 工作绩效信息 变更请求 项目管理计划更新 任何组件 项目文件更新 假设日志、问题日志、经验教训登记册、风险登记册、风险报告 组织过程资产更新","categories":[{"name":"项目管理","slug":"项目管理","permalink":"http://www.whoosh.site/categories/项目管理/"}],"tags":[{"name":"PMP","slug":"PMP","permalink":"http://www.whoosh.site/tags/PMP/"},{"name":"PMBOK","slug":"PMBOK","permalink":"http://www.whoosh.site/tags/PMBOK/"}]},{"title":"项目沟通管理","slug":"20180526_项目沟通管理","date":"2018-05-26T13:13:58.000Z","updated":"2018-06-22T11:04:56.818Z","comments":true,"path":"2018/05/26/20180526_项目沟通管理/","link":"","permalink":"http://www.whoosh.site/2018/05/26/20180526_项目沟通管理/","excerpt":"","text":"沟通管理 通过开发工作，以及执行有用于有效交换信息的各种活动，来确保项目及其相关方信息的需求得以满足的各个过程 美拉柄法则：词语7%，语气语调38%，肢体语言55%。 项目经理90%以上的时间用于沟通 书面沟通有利于解决复杂问题，书面沟通的5C原则：正确的语法和拼写、简洁的表述和无多余文字、清晰的目的和表述、连贯的思维逻辑、受控的语句和想法承接规划沟通管理 定义 基于每个相关方或相关方群体的信息需求、可用的组织资产，以及具体项目的需求，为项目沟通活动制定恰当的方法和计划的过程。规划沟通管理里有具体的沟通管理内容 作用 及时向相关方提供提供相关信息，引导相关方有效参与项目，而编制书面沟通计划 时间点 整个项目期间定期开展ITTO 输入（I） 项目章程 主要相关方清单，可能包含相关方角色和职责有关的信息 项目管理计划 资源管理计划，相关方参与计划 项目文件 需求文件，相关方登记册 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 沟通需求分析 确定项目相关方信息需求，包括所需信息的类型和形式，以及信息对相关方的价值。 潜在沟通沟通渠道或途径数量 N*(N-1)/2，注意是否包含项目经理、是增加到还是增加了 沟通技术 信息需求的紧迫性 技术的可用性与可靠性 技术的易用性 项目环境 信息的敏感性和保密性，只传递对项目有利的信息 沟通模型 基本的发送方和接收方沟通模型：确保信息送达，不关注是否理解 编码 传递信息 解码 互动沟通模型：确保信息送达且被正确理解 确认已收到 反馈/响应 沟通方法 互动沟通：在两方或多方之间进行的实时多向信息交换，如即时通信 推式沟通：向需要接收信息的特定接收方发送或发布信息，不能确保信息被收到。如邮件 拉式沟通：适用于大量复杂信息或大量信息受众的情况，如网站 人际关系与团队技能 沟通风格评估 用于评估沟通风格并识别偏好的沟通方法、形式和内容的一种技术，常用于不支持项目的相关方 政治意识 对正式和非正式权力关系的认知，以及在这些关系中工作的意愿，有助于项目经理根据项目环境和组织的政治环境来规划沟通 文化意识 理解个人、群体和组织之间的差异，并据此调整项目的沟通策略 数据表现 相关方参与度评估矩阵 显示了相关方当前和期望参与度之间的差距，通过分析，填补参与度差距且识别额外的沟通需求 会议 输出（O） 沟通管理计划 将如何规划、结构化、执行与监督项目沟通，以提高沟通的有效性 包括以下内容：相关方的沟通需求；需沟通的信息（语言、形式、内容和详细程度）；上报步骤(问题升级)；发布信息的原因；发布所需信息、确认已收到，或作出回应的时限和频率；负责沟通的相关信息的人员；负责授权保密信息发布的人员；接收信息的人员或群体；用于传递信息的方法或技术；为沟通活动分配；通用术语表的资源等 信息流有问题找沟通管理计划 项目管理计划更新 相关方参与计划 影响相关方参与项目决策和执行的任何过程、程序、工具或技术 项目文件更新 项目进度计划，相关方登记册管理沟通 定义 确保项目信息及时且恰当地收集、生成、发布、存储、检索、管理、监督和最终处置的过程 作用 促成项目团队与相关方之间的有效信息流动 时间点 整个项目期间开展ITTO 输入（I） 项目管理计划 资源管理计划， 沟通管理计划， 相关方管理计划 项目文件 变更日志 向受影响的相关方传达变更，以及变更请求的批准、推迟和否决情况 问题日志 将与问题相关的信息传达给受影响的相关方 经验教训登记册，质量报告，风险报告，相关方登记册 工作绩效报告 工作绩效报告通过管理沟通过程传递给项目相关方，包括状态报告和进展报告 事业环境因素和组织过程资产 工具与技术（TT） 沟通技术 影响技术选用的因素包括团队是否集中办公、需要分享的信息是否需要保密、团队成员的可用资源，以及组织文化如何影响会议和讨论的正常开展 沟通方法 沟通技能 沟通胜任力 有助于明确关键信息的目的、建立有效关系 反馈 关于沟通、可交付成果或情况的反应信息 非口头技能 通过示意、语调和面部表情等适当的肢体语言来表达意思 演示 信息和文档的正式交付 项目管理信息系统 电子项目管理工具,电子沟通管理,社交媒体管理 项目报告发布 收集和发布项目信息的行为 人际关系与团队技能 积极倾听 告知已收到、澄清与确认信息、理解，以及消除妨碍理解的障碍 冲突管理，文化意识，会议管理，人际交往，政治意识 会议 输出（O） 项目沟通记录 绩效报告、可交付成果的状态、进度进展、产生的成本、演示，以及相关方需要的其他信息 项目管理计划更新 沟通管理计划，相关方管理计划 项目文件更新 问题日志，经验教训登记册，项目进度计划，风险登记册，相关方登记册 组织过程资产更新 项目记录，计划内的和临时的项目报告和演示监督沟通 定义 确保满足项目及其相关方的信息需求的过程 作用 按沟通管理计划和相关方参与计划的要求优化信息传递流程 时间点 整个项目期间开展 在正确的时间，通过正确的渠道，将正确的内容传递给正确的受众，产生正确的影响ITTO 输入（I） 项目管理计划 资源管理计划，沟通管理计划，相关方参与计划 项目文件 问题日志，经验教训登记册，项目沟通记录 工作绩效报告 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 项目管理信息系统：信息监控 数据分析 相关方参与度评估矩阵 人际关系与团队技能 观察/交谈 会议 输出（O） 工作绩效信息 包括与计划相比较的沟通的实际开展情况和对沟通的反馈 变更请求 项目管理计划更新 沟通管理计划，相关方参与计划 项目文件更新 问题日志，经验教训登记册，相关方登记册","categories":[{"name":"项目管理","slug":"项目管理","permalink":"http://www.whoosh.site/categories/项目管理/"}],"tags":[{"name":"PMP","slug":"PMP","permalink":"http://www.whoosh.site/tags/PMP/"},{"name":"PMBOK","slug":"PMBOK","permalink":"http://www.whoosh.site/tags/PMBOK/"}]},{"title":"项目资源管理","slug":"20180519_项目资源管理","date":"2018-05-19T05:21:58.000Z","updated":"2018-06-22T07:03:35.802Z","comments":true,"path":"2018/05/19/20180519_项目资源管理/","link":"","permalink":"http://www.whoosh.site/2018/05/19/20180519_项目资源管理/","excerpt":"","text":"资源管理 团队成员参与规划阶段，即可使他们对项目规划工作贡献专业技能、有可以增强他们对项目的责任感 马斯洛需求层次理论（生理需求、安全需求、社会需求、尊重需求、自我实现需求） 赫兹伯格双因素理论（保健因素、激励因素） 麦格雷戈X、Y理论（X理论：消极，人性本惰；Y理论：积极，人性本善） 大内Z理论（终身雇佣制、缓慢的评价和晋升） 麦克利兰成就动机理论（成就、权力、亲和、需要）规划资源管理 定义 定义如何估算、获取、管理和利用团队以及实物资源的过程 作用 根据项目类型和复杂程度确定适用于项目资源的管理方法和管理程度 时间点 仅开展一次或仅在预定义点开展ITTO 输入（I） 项目章程 项目管理计划 质量管理计划，范围基准 项目文件 项目进度计划，需求文件，风险登记册，相关方登记册 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 数据表现 层级型 工作分解结构（WBS） 用来显示如何把项目可交付成果分解为工作包，有助于明确高层级的职责 组织分解结构（OBS） 按照组织现有的部门、单元或团队排列，并在每个部门下列出项目活动或工作包 资源分解结构（RBS） 按资源类别和类型，对团队和实物资源进行层级列表排列，用于规划、管理和控制项目工作 责任分配矩阵（RAM） 显示了分配给每个工作包的项目资源，用于说明工作包或活动与项目团队成员之间的关系 RACI矩阵（执行、负责、咨询和知情）是RAM的一个列子，用于明确划分资源的角色和职责，其中A只能有一个，高层级明确到部门、低层级明确到个人 职权不清找责任分配矩阵或RACI 文本型 详细描述团队成员的职责，通常以概述的形式，提供诸如职责、职权、能力和资格等方面的信息 组织理论 会议 输出（O） 资源管理计划 提供了关于如何分类、分配、管理和释放项目资源的指南 包括：识别资源、获取资源、角色和职责（角色、职权、职责、能力）、项目组织图、项目团队资源管理、培训、团队建设、资源控制、认可计划 团队章程 为团队创建团队价值观、共识和工作指南的文件，需求定期审查和更新 对项目团队成员的可接受行为确定了明确的期望 有助于减少误解、提高生产力，是团队的基本规则，指导新成员融入团队 项目文件更新 假设日志, 风险登记册估算活动资源 定义 估算执行项目所需的团队资源、以及材料、设备和用品的类型和数量的过程 作用 明确完成项目所需的资源种类、数量和特性 时间点 整个项目期间定期开展ITTO 输入（I） 项目管理计划 资源管理计划，范围基准 项目文件 活动属性 估算活动清单中每项活动所需的团队和实物资源提供了主要数据来源 活动清单 识别了需要资源的活动 资源日历 识别了每种具体资源可用的工作日、班次、正常上下班时间、周末和公共假期 规定了在项目期间确定的团队和实物资源何时可用、可用多久 假设日志 成本估算 风险登记册 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 自下而上估算 类比估算 参数估算 数据分析：备选方案分析 项目管理信息系统 会议 输出（O） 资源需求 识别了各个工作包或工作包中每个活动所需的资源类型和数量 估算依据 估算方法、假设条件、制约因素、估算范围、置信水平、其他文件 资源分解结构（RBS） 资源依类别和类型的层级展现，用于指导项目的分类活动 是一种用于获取和监督资源的完整的文件 实物资源统一采购 项目文件更新 活动属性、假设日志、经验教训登记册获取资源 定义 获取项目所需的团队成员、设施、设备、材料、用品和其他资源的过程 作用 概述和指导资源的选择、并将其分配给相应的活动 时间点 整个项目期间定期开展 备注 内部资源由职能经理或资源经理负责获取（分配），外部资源则是通过采购过程获得 在获取资源过程中项目经理或项目团队应进行有效谈判 在不违反法律、规章、强制性规定或其他具体标准前提下可以使用替代资源ITTO 输入（I） 项目管理计划 资源管理计划，采购管理计划，成本基准 项目文件 项目进度计划 有助于确定需要提供和获取资源的时间 资源日历 用于编制可靠的进度计划，在整个项目过程中渐进明细和更新 资源需求 识别了需要获取的资源 相关方登记册 事业环境因素和组织过程资产 工具与技术（TT） 决策 多标准决策分析 对潜在资源进行评级和打分，然后对标准进行加权，最终确定资源的优先级 可用标准：可用性、成本、能力、经验、知识、技能、态度、国际因素 人际关系与团队技能 谈判 职能经理确保项目在要求的时限内获得最佳资源，直到完成职责 执行组织中的其他项目管理团队，确保分配稀缺或特殊资源 外部组织和供应商，提供合适的、稀缺的、特殊的、合格的、经认证的的团队或实物资源 优秀资源从其他团队或外部组织获取，一般资源从职能经理获取 预分派 在竞标过程中承诺分派特定人员进行项目工作 项目取决于特定人员的技能 制定项目章程过程或其他过程已经制定了某些团队成员的工作分派 虚拟团队 不同地理位置的、在家办公的、工作班次，工作小时不同的、行动不便的、差旅费过高的、节省开支的 沟通很重要 输出（O） 物质资源分配单 记录了项目将使用的材料、设备、用品、地点和其他实物资源 项目团队派工单 记录了团队成员及其在项目中的角色和职责 资源日历 识别了每种具体资源可用的工作日、班次、正常上下班时间、周末和公共假期 规定了在项目期间确定的团队和实物资源何时可用、可用多久 变更请求 项目管理计划更新 资源管理计划，成本基准 项目文件更新 经验教训登记册，项目进度计划，资源分解结构，资源需求，风险登记册，相关方登记册 事业环境因素更新 组织过程资产更新建设团队 定义 提高工作能力，促进团队成员互动，改善团队整体氛围，以提高项目绩效的过程 作用 改进团队协作、增强人际关系技能和胜任力、激励员工、减少摩擦以及提升整体项目绩效 时间点 整个项目期间开展 备注 塔克曼阶梯理论 形成阶段 团队成员相互认识，了解项目情况、角色和职责，但倾向于相互独立，不会开诚布公 震荡阶段 开始从事项目工作、不同的意见和观点，冲突和矛盾，制定技术决策和讨论项目管理方法 规范阶段 团队成员开始协同工作、并调整各自的工作习惯和行为来支持团队，并且学习相互信任 成熟阶段 团队成员之间相互依靠、平稳高效的解决问题 解散阶段 在结束项目或阶段过程中，释放人员，解散团队ITTO 输入（I） 项目管理计划 资源管理计划 为如何通过团队绩效评价和其他形式的团队管理活动，为项目团队成员提供奖励、提出反馈、增加培训或采取惩罚措施提供了指南 项目文件 经验教训登记册，项目进度计划， 项目团队派工单，资源日历，团队章程 事业环境因素和组织过程资产 工具与技术（TT） 集中办公 在同一物理地点工作，增强团队工作能力，增进沟通和集体感 虚拟团队 沟通很重要 沟通技术 共享门户 音/视频会议 电子邮件/聊天软件 人际关系与团队技能 冲突管理 项目经理及时的以建设性方式解决冲突，从而创建高绩效团队 影响力 在维护相互信任的同时，解决重要问题并达成一致意见 激励 激励为某人采取行动提供了理由，提高团队参与决策的能力并鼓励他们独立工作 谈判 有助于在团队成员之间建立融洽的相互信任关系 团队建设 旨在帮助各团队成员更加有效地协同工作 认可和奖励 只有能满足被奖励者的某个重要需求的奖励，才是有效的奖励 可以是正式或非正式的方式做出奖励决定，而且要考虑文化差异 在整个项目生命周期中尽可能地给予表彰，而不是等到项目完成时 金钱是奖励制度中的有形奖励，无形奖励更加有效 如果员工感受不到自己的价值和工作意义，通过认可和奖励来收到激励 培训 目的时减少差异，培训成本通常应该包括在项目预算中 如果是项目本身需要的是直接成本，如果是未来项目需要的是间接成本 个人和团队评估 洞察成员的优势和劣势，360°考核 有利于增进团队成员间的理解、信任、承诺和沟通，在整个项目期间不断提高团队成效。 会议 输出（O） 团队绩效评价 随着项目团队建设工作的开展，对项目团队的有效性进行正式或非正式的评价 指标包括：技能的改进、胜任力改进、离职率的降低、凝聚力的提升等 变更请求 项目管理计划更新 项目文件更新 经验教训登记册，项目进度计划， 项目团队派工单，资源日历，团队章程 事业环境因素更新 组织过程资产更新管理团队 定义 跟踪团队成员工作表现、提供反馈、解决问题并管理团队变更、以优化项目绩效 作用 影响团队行为、管理冲突、以及解决问题 时间点 整个项目期间开展ITTO 输入（I） 项目管理计划 资源管理计划 项目文件 问题日志，经验教训登记册，项目团队派工单，团队章程 工作绩效报告 为制定决策、采取行动或引起关注所形成的实物或电子工作绩效信息 包括从进度控制、成本控制、质量控制、资源控制和范围确认中得到的工作绩效信息 团队绩效评价 事业环境因素和组织过程资产 工具与技术（TT） 人际关系与团队技能 冲突管理 冲突的来源包括资源稀缺、进度优先级排序和个人工作风格差异等 冲突管理的流程： 团队成员私下自行解决 项目经理参与提供协助 采用正式途径处理 冲突解决方法 撤退/回避：将问题推迟到准备充分的时候，或将问题推给他人解决 缓和/包容：强调一致而非差异，为维持和谐与关系而退让一步，注重求同存异，问题根本没有解决 妥协/调解：为了暂时或部分解决冲突，寻找能让各方都在一定程度上满意的方案，问题得到一定程度解决。有时会导致双输局面 强迫/命令： 以牺牲其他方为代价，推行某一方的观点，通常利用权力来强行解决紧急问题 合作/解决问题：综合考虑不同的观点和意见，采用合作的态度和开放式对话引导各方达成共识和承诺，可以带来双赢局面 制定决策 情商 影响力 领导力 项目管理信息系统 输出（O） 变更请求 项目管理计划更新 资源管理计划，进度基准，成本基准 项目文件更新 问题日志，经验教训登记册，项目团队派工单 事业环境因素更新控制资源 定义 确保按计划为项目分配实物资源、以及根据资源使用计划监督资源实际使用情况，并采取纠正措施的过程 作用 确保所分配的资源适时地可用于项目，且在不再需要时被释放 时间点 整个项目期间开展ITTO 输入（I） 项目管理计划 资源管理计划 项目文件 问题日志，经验教训登记册，实物资源分配单，项目进度计划，资源分解结构，资源需求，风险登记册 工作绩效数据 组织过程资产 工具与技术（TT） 数据分析 备选方案分析 成本效益分析 绩效审查 测量、比较和分析计划的资源使用和实际资源使用的不同 趋势分析 解决问题的步骤：1. 定义问题 2. 识别根本原因 3. 生成可能的解决方案 4. 选择最佳解决方案 5. 执行解决方案 6. 验证解决方案的有效性 人际关系与团队技能 谈判：项目经理可能需要就增加实物资源、变更实物资源或资源相关成本进行谈判 影响力 项目管理信息系统 输出（O） 工作绩效信息 变更请求 项目管理计划更新 资源管理计划，进度基准， 成本基准 项目文件更新 问题日志，经验教训登记册，实物资源分配单，项目进度计划，资源分解结构，资源需求，风险登记册","categories":[{"name":"项目管理","slug":"项目管理","permalink":"http://www.whoosh.site/categories/项目管理/"}],"tags":[{"name":"PMP","slug":"PMP","permalink":"http://www.whoosh.site/tags/PMP/"},{"name":"PMBOK","slug":"PMBOK","permalink":"http://www.whoosh.site/tags/PMBOK/"}]},{"title":"项目质量管理","slug":"20180513_项目质量管理","date":"2018-05-13T15:03:58.000Z","updated":"2018-06-22T11:04:56.819Z","comments":true,"path":"2018/05/13/20180513_项目质量管理/","link":"","permalink":"http://www.whoosh.site/2018/05/13/20180513_项目质量管理/","excerpt":"","text":"质量管理 项目质量管理需要兼顾项目管理（过程）和项目可交付成果（结果）两个方面。 质量（缺陷程度）与等级（功能数量、设计意图）不是相同概念，低质量肯定是个问题，而低等级产品不一定是个问题。 属性抽样：结果是合格/不合格；变量抽样：表明合格的程度 公差：结果的可接受程度；控制界线：过程绩效的普通偏差的边界 质量管理水平的有效性： 让客户发现缺陷 通过控制质量过程检测和纠正缺陷 通过质量保证检查并纠正过程 将质量融入项目和产品的规范和设计中 在整个组织内创建产品质量文化 预防胜于检查。预防：保证过程中不出现错误；检查：保证错误不落在客户手中 客户满意：把符合要求（确保项目产出预定的成果）和适合使用（产品或服务必须满足实际需求）结合起来 持续改进：休哈特提出，戴明改善的PDCA（计划-实施-检查-行动）循环是质量改进的基础。朱兰-质量螺旋；克鲁斯比-零缺陷/质量免费；石川-因果图；田口玄一-实验设计方法。 管理层责任：责任比例85%（管理层）和15%（员工）规划质量管理 定义 识别项目及其可交付成果的质量要求和标准，并书面描述项目将如何证明质量要求和标准的过程 作用 为整个项目期间如何管理和核实质量提供指南和方向 时间点 仅开展一次或在预定义节点开展ITTO 输入（I） 项目章程 项目管理计划 需求管理计划，风险管理计划，相关方参与计划，范围基准 项目文件 假设日志，需求文件，需求跟踪矩阵，风险登记册，相关方登记册 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 数据收集 标杆对照 将实际或计划的项目实践或项目的质量标准与可比项目的实践或标准进行比较，以便识别最佳实践，形成改进意见，并为绩效考核提供依据 头脑风暴 访谈 数据分析 成本效益分析 用来估算备选方案优势和劣势的财务分析工具，以确定可以创造最佳效益的备选方案 质量成本（COQ） 一致性成本 预防成本：打造某种高质量产品 培训、文件过程、设备、完成时间 评估成本：评估质量 测试、破坏性试验损失、检查 预防胜于检查 非一致成本 内部失败成本：项目中发现的失败 返工、报废 外部失败成本：客户发现的失败 债务、保修工作、召回、失去业务 决策 多标准决策分析 识别关键事项和合适的备选方案，并对备选方案排出优先顺序，作为执行的决策 数据表现 流程图 有助于了解和估算一个过程的质量成本 帮助改进过程并识别可能出现质量缺陷或可以纳入质量检查的地方 逻辑数据模型 把组织数据可视化，以商业语言加以描述 可用于识别会出现数据完整性或其他质量问题的地方 矩阵图 在行列交叉的位置展示因素、原因和目标之间的关系强弱 有助于识别对项目成功至关重要的质量测量指标 思维导图 可视化组织信息的绘图法 有助于快速收集项目质量要求，制约因素、依赖关系和联系 测试与检查规划 决定如何测试或检查产品、可交付成果或服务，以满足相关方的需求和期望，以及如何满足产品的绩效和可靠性目标 会议 输出（O） 质量管理计划：如何做 描述如何实施适用的政策、程序和指南以实现质量目标 在项目早期就对质量管理计划进行评审，以确保决策时基于准确信息的，这样就可以更加关注项目的价值定位，降低返工造成的成本超支和进度延误 质量测量指标：定标准 描述项目或产品属性，以及控制质量过程将如何验证质量符合测量指标程度 项目管理计划更新 风险管理计划，范围基准 项目文件更新 经验教训登记册、需求跟踪矩阵、风险登记册、相关方登记册管理质量 定义 把组织的质量政策用于项目，并将质量管理计划转化为可执行的质量活动的过程 作用 提高实现质量目标的可能性，以及识别无效过程和导致质量低劣的原因 时间点 整个项目期间开展 备注 管理质量又称质量保证（QA），管理质量包括所有的质量保证活动，还与产品设计和过程改进有关，质量管理工作属于质量成本框架中的一致性工作。 质量管理适用控制质量过程的数据和结果向相关方展示项目的总体质量状态 在敏捷项目中，整个项目期间的质量管理由所有团队成员执行，在传统项目中，质量管理通常是特定团队成员的职责。ITTO 输入（I） 项目管理计划 质量管理计划 项目文件 经验教训登记册、风险报告 质量控制测量结果：来自于控制质量输出，用于分析和评估项目过程和可交付成果的质量是否符合执行组织的标准或特定要求 质量测量指标：通样也是控制质量的输入，设定对项目及其可交付成果的测试场景。 组织过程资产 工具与技术（TT） 数据收集 核对单 一种结构化工具，通常列出特定组成部分，用来核实所要求的一系列步骤是否已得到执行或检查需求列表是否得到满足 数据分析 备选方案分析 文件分析 可以重点指出可能超出控制范围之外并阻碍项目团队满足特定要求或相关方期望的过程 过程分析 可以识别过程改进机会，同时检查在过程期间遇到的问题、制约因素，以及非增值活动 根本原因分析（RCA） 确定引起偏差，缺陷或风险的根本原因的一种分析技术 用于识别问题的根本原因并解决问题，消除所有根本原因可以杜绝问题再次发生 决策 多标准决策 项目决策可以包括在不同执行情景或供应商中加以选择 产品决策可以包括评估生命周期成本、进度、相关方的满意度 数据表现 亲和图 对潜在缺陷进行分类，展示最应关注的领域 因果图 又称鱼骨图/石川图，有助于识别问题的主要原因和根本原因 流程图 展示引发缺陷的一系列步骤 直方图 以数字数据的图形方式展示每个可交付成果的缺陷数量、缺陷成因的排列、各个过程的不合规次数，或项目/产品缺陷的其他表现形式 矩阵图 行列交叉的位置展示因素、原因和目标之间的关系强弱 散点图 展示两个变量之间的关系的图形 审计 用于确定项目是否遵循了组织和项目的政策，过程与程序的一种结构化且独立的过程 质量审计步骤：1.识别；2.分享；3.协助；4.积累；5.确认 面向X的设计（DfX） 旨在优化设计的特定方面，可以控制或提高产品的最终特性 问题解决 找到解决问题或应对挑战的解决方案，有效或系统化地解决问题时质量保证和质量改进的基本要素 解决问题的步骤： 定义问题 识别根本原因 生成可能的解决方案 选择最佳解决方案 执行解决方案 验证解决方案的有效性 质量改进方法 基于质量控制过程的发现和建议、质量审计的发现，或管理质量过程的问题解决 PDCA（计划-实施-检查-行动）和六西格玛（百万分之三点四）是最常用工具 输出（O） 质量报告 可能是图形、数据或定性文件，其中包含的信息可帮助其他过程或部门采取纠正措施，以实现项目质量期望 测试与评估文件 控制质量过程的输入，用于评估质量目标的实现情况 变更请求 项目管理计划更新 质量管理计划,范围基准,进度基准, 成本基准 项目文件更新 问题日志、经验教训登记册、风险登记册控制质量 定义 为了评估绩效，确保项目输出完整、正确且满足客户期望，而监督和记录质量管理活动执行结果的过程 作用 核实项目可交付成果和工作已经达到主要相关方的质量要求，可供最终验收 时间点 整个项目期间开展 备注 控制质量过程确定项目输出是否达到预期目的，这些输出满足所有适用标准、要求、法规和规范 目的是在用户验收和最终可交付之前测量产品或服务的完整性、合规性和实用性 管理质量针对过程，控制质量针对可交付成果ITTO 输入（I） 项目管理计划 质量管理计划 项目文件 经验教训登记册，质量测量指标，测试与评估文件 批准的变更请求 可交付成果 在某一过程、阶段或项目完成时，必须产出的任何独特并可核实的产品、成果或服务能力 工作绩效数据 事业环境因素和组织过程资产 工具与技术（TT） 核对单 checklist，有助于以结构化方式管理控制质量活动 核查表 checktable，有效地收集关于潜在质量问题的有用数据（例如属性数据）,通常用帕累托图进行展示 统计抽样 从目标总体中选取部分样本用于检查，抽样的频率和规模应在规划质量管理过程中确定 问卷调查 在部署产品或服务之后收集客户满意度的数据 数据分析 绩效审查：针对实际结果 根本原因分析：用于识别缺陷成因 检查 检验工作产品，以确定是否符合书面标准。检查的结果通常包括测量数据 测试/产品评估 测试时有组织的、机构话的调查 目的时找出产品或服务中存在的错误、缺陷、漏洞或其他不合规问题，帮助减少修补不合规组件的成本 数据表现 因果图 用于识别质量缺陷和错误可能造成的结果 控制图 用于确定一个过程是否稳定，或者是否具有可预测的绩效 失控状态：1、超出控制上下限；2、连续7个点在同一侧 超出规格上下限(正负3个西格玛-99.7%)表明缺陷已经发生 直方图 散点图 会议 输出（O） 质量控制测量结果 对质量控制活动的结果的书面记录，应以质量管理计划所确定的格式加以记录 核实的可交付成果 指导与管理项目工作输出可交付成果 然后经控制质量后，变成核实的可交付成果 然后经确认范围后，变成验收的可交付成果 最后到达结束项目或阶段变成最终的产品、服务或成果 工作绩效信息 变更请求 项目管理计划更新 项目文件更新 问题日志、经验教训登记册、风险登记册、测试与评估文件","categories":[{"name":"项目管理","slug":"项目管理","permalink":"http://www.whoosh.site/categories/项目管理/"}],"tags":[{"name":"PMP","slug":"PMP","permalink":"http://www.whoosh.site/tags/PMP/"},{"name":"PMBOK","slug":"PMBOK","permalink":"http://www.whoosh.site/tags/PMBOK/"}]},{"title":"项目成本管理","slug":"20180506_项目成本管理","date":"2018-05-06T14:53:58.000Z","updated":"2018-06-22T09:13:33.711Z","comments":true,"path":"2018/05/06/20180506_项目成本管理/","link":"","permalink":"http://www.whoosh.site/2018/05/06/20180506_项目成本管理/","excerpt":"","text":"成本管理 关注完成项目活动所需资源的成本，但同时也应考虑项目决策对项目产品、服务或成果的使用成本、维护成本和支持成本的影响。 采用轻量级估算方法快速生成对项目人力成本的高层级预测，详细的估算适用于采用准时制的短期规划规划成本管理 定义 确定如何估算、预算、管理、监督和控制项目成本的过程 作用 在整个项目期间为如何管理项目成本提供指南和方向 时间点 仅开展一次或在预定义节点开展 备注 在项目规划阶段早期对成本管理进行规划ITTO 输入（I） 项目章程 预先批准的财务资源以及规定的项目审批要求 项目管理计划 进度管理计划,风险管理计划 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 数据分析：备选方案分析 会议 输出（O） 成本管理计划，和进度管理计划内容类似 计量单位 精确度、准确度 组织程序链接 工作分解结构（WBS）为成本管理计划提供了框架，以便据此规范地开展成本估算、预算和控制 控制临界值 偏差临界值，用于监督成本绩效 绩效测量规则 报告格式 其他细节估算成本 定义 对完成项目工作所需资源成本进行近似估算的过程 作用 确定项目所需资金 时间点 整个项目期间开展 备注 成本估算是对完成活动所需资源的可能成本的量化评估 通常以某种货币单位进行成本估算，也可以使用人天数，来消除通货膨胀的影响 粗略量级估算（ROM）区间-25%至75%，确定性估算区间-5%至10%ITTO 输入（I） 项目管理计划 成本管理计划，质量管理计划，范围基准 项目文件 经验教训登记册，项目进度计划，资源需求，风险登记册 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 类比估算 使用以往项目的参数值或属性进行估算 参数估算 利用历史数据之间的统计关系和其他变量进行估算 自下而上估算 对单个工作包或活动的成本进行最具体、细致的估算，然后向上逐层汇总，用于后续报告和跟踪 三点估算 考虑估算中的不确定性和风险，使用最可能成本（Cm）、最乐观成本（Co）、最悲观成本（Cp）来界定活动成本的近似区间 三角分布：Ce=（Cm+Co+Cp）/3 贝塔分布：Ce=（Cm+Co*4+Cp）/6 正负1个西格玛68.5%；正负2个西格玛95.4%；正负3个西格玛99.7% 数据分析 备选方案分析 储备分析–应急储备 用来应对会影响项目的已知-未知风险的部分,随着项目信息越来越明确，可以动用、减少或取消应急储备 小至单个活动，大至整个项目，任何层级都可有其应急储备 质量成本 包括一致性成本和非一致性成本 项目管理信息系统 决策 投票：可以调动团队成员的参与，提高估算的准确性，并提高对估算的责任感 输出（O） 成本估算 可以是汇总的或详细分列的，应覆盖项目所使用的全部资源 如果间接成本也包含在项目估算中，则可在活动层次或更高层次上计列间接成本 估算依据 成本估算所需的支持信息的数量和种类 项目文件更新 假设日志、经验教训登记册、风险登记册制定预算 定义 汇总所有单个活动或工作包的估算成本，建立一个经批准的成本基准的过程 作用 确定可据以监督和控制项目绩效的成本基准 时间点 仅开展一次或在预定义节点开展ITTO 输入（I） 项目管理计划 成本管理计划,资源管理计划,范围基准 项目文件 估算依据,成本估算, 项目进度计划,风险登记册 商业文件 商业文件,效益管理计划 协议：采购协议 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 成本汇总 把成本估算汇总到WBS中的工作包，再由工作包汇总至WBS的更高层次（如控制账户），最终得出整个项目的总成本 数据分析 储备分析–管理储备 针对项目范围中不可预见的工作，用来应对会影响项目的未知-未知风险的部分 管理储备不包括在成本基准中，但属于项目总预算和资金需求的一部分 动用管理储备时，就要把动用的部分增加到成本基准中，从而导致成本基准的变更，走变更控制流程 历史信息审核 有助于参数估算或类比估算 资金限制平衡 如果发现资金限制于计划支出之间的差异，则可能需要调整进度计划，以平衡资金支出水平 融资 输出（O） 成本基准 经过批准的，按时间段分配的项目预算，不包括任何管理储备，只有通过正式的变更控制程序才可变更，用作与实际结果进行比较的依据 项目预算 管理储备 成本基准 控制账户 工作包应急储备 工作包成本估算 活动应急储备 活动成本估算 项目资金需求 包括预计支出和预计债务 项目文件更新 成本估算、项目进度计划、风险登记册控制成本 定义 监督项目状态，以更新项目成本和管理成本基准变更的过程 作用 在整个项目期间保持对成本基准的维护 时间点 整个项目期间开展 备注 重点分析项目资金支出与相应完成工作之间的关系 有效成本控制的关键在于管理经批准的成本基准ITTO 输入（I） 项目管理计划 成本管理计划, 成本基准,绩效测量基准 项目文件 经验教训登记册 项目资金需求 工作绩效数据 组织过程资产 工具与技术（TT） 专家判断 数据分析 挣值分析（EVA） 将实际进度和成本绩效与绩效测量基准进行比较 计划价值（PV） 为计划工作分配的经批准的预算，不包括管理储备 某时间点计划完成（或应该已经完成）的工作的价值 完工预算(BAC)=项目的总计划价值（成本基准） 挣值（EV） 对已完成工作的测量，用该工作的批准预算来表示 某时间点所有已完成工作的计划价值，与实际成本无关 常用于计算项目完成的百分比，监测EV增量用于判断当前进度状态，也要关注EV的累计值用于判断长期的绩效趋势 EV=已完成工作的计划价值之和 实际成本（AC） 在给定时间段内，因执行项目活动而实际发生的成本 某时间点所有已完成工作的实际成本 偏差分析 成本偏差（CV） 在某个给定时间点，预算亏空或盈余量，表示为挣值与实际成本之差，即CV=EV-AC 大于0：低于计划成本；等于0：按计划成本；小于0：成本超支 成本绩效指数（CPI） 测量预算资源的成本效率的一种指标，表示为挣值与实际成本之比，即CPI=EV/AC 大于1：低于计划成本；等于1：按计划成本；小于1：成本超支 进度偏差（SV） 在某个给定时间点，与计划交付日期相比的亏空或盈余量，表示为挣值于计划价值之差，即SV=EV-PV 大于0：比进度计划提前；等于0：按进度计划进行；小于0：进度滞后 进度绩效指数（SPI） 测量进度效率的一种指标，表示为挣值与计划价值之比。即SPI=EV/PV 大于1：比进度计划提前；等于1：按进度计划进行；小于1：进度滞后 完工偏差（VAC） 对预算亏空量或盈余量的一种预测，是完工预算和完工估算之差，即VAC=BAC-EAC 大于0：低于计划成本；等于0：按计划成本；小于0：成本超支 趋势分析 图表 预测 完工估算（EAC） 完成所有工作所需的预期总成本，等于截至目前的实际成本加上完工尚需估算（ETC） 典型：预期项目剩余部分的CPI不变，则EAC=BAC/CPI 非典型：未来工作将按计划速度（进度/成本）完成，即SPI和CPI都等于1，则EAC=AC+（BAC-EV） 如果进度成本同时作用，则EAC＝AC＋[（BAC-EV）/（CPI*SPI）] 如果最初计划不在有效，则EAC=AC+至下而上的ETC 完工预算（BAC） 为将要执行的工作所建立的全部预算的总和 总计划工作的价值，项目成本的基准 完工尚需估算（ETC） 完成所有剩余项目工作的预计成本 典型：预期项目剩余部分的CPI不变，则ETC=(BAC-EV)/CPI 非典型：未来工作将按计划速度完成，则ETC=BAC-EV 如果最初计划不在有效，则ETC=至下而上的重新估算 储备分析 应急储备 如果已识别的风险没有发生，就可能要从项目预算中扣除未使用的应急储备，为其他项目或运营腾出资源 管理储备 动用管理储备时，就要把动用的部分增加到成本基准中，从而导致成本基准的变更，走变更控制流程 完工尚需绩效指标（TCPI） 为实现特定的管理目标，剩余资源的使用必须达到成本绩效指标，是剩余工作和剩余资金之比 为完成计划必须保持的效率，即TCPI=（BAC-EV）/（BAC-AC） 为完成当前完工估算必须保持的效率，即TCPI=（BAC-EV）/（EAC-AC） 大于1：难以完成；等于1：正好完成；小于1：轻易完成 项目管理信息系统 输出（O） 工作绩效信息 成本预测 变更请求 项目管理计划更新 成本管理计划、成本基准、绩效测量基准 项目文件更新 假设日志、估算依据、成本估算、经验教训登记册、风险登记册","categories":[{"name":"项目管理","slug":"项目管理","permalink":"http://www.whoosh.site/categories/项目管理/"}],"tags":[{"name":"PMP","slug":"PMP","permalink":"http://www.whoosh.site/tags/PMP/"},{"name":"PMBOK","slug":"PMBOK","permalink":"http://www.whoosh.site/tags/PMBOK/"}]},{"title":"项目进度管理","slug":"20180428_项目进度管理","date":"2018-04-28T15:06:28.000Z","updated":"2018-06-22T03:53:55.860Z","comments":true,"path":"2018/04/28/20180428_项目进度管理/","link":"","permalink":"http://www.whoosh.site/2018/04/28/20180428_项目进度管理/","excerpt":"","text":"进度管理 项目进度计划流程： 项目管理团队选择进度计划方法（关键路径法/敏捷法）； 将项目特定数据输入进度编制工具； 创建项目进度模型 具有未完项的迭代型进度计划：基于适应型生命周期的滚动式规划，通常用于向客户交付增量价值，或多个团队并行开发大量内部关联较小的功能 按需进度计划：不依赖于以前为产品或产品增量制定的进度计划，在资源可用时，立即从未完项和工作序列中提取出来，通常用于在运营持续环境中以增量方式研发产品，且任务的规模或范围相对类似规划进度管理 定义 为规划、编制、管理、执行和控制项目进度而制定政策、程序和文档的过程 作用 为如何在整个项目期间管理项目进度提供指南和方向 时间点 仅开展一次或仅在项目的预定义点开展ITTO 输入（I） 项目章程 项目管理计划 范围管理计划 开发方法 有助于定义进度计划方法、估算技术、进度计划编排工具以及用来控制进度的技术 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 数据分析 备选方案分析 会议 输出（O） 进度管理计划 项目进度模型制定 进度计划的发布和迭代长度：指定固定时间的发布时段、阶段和迭代 准确度、计量单位 组织程序链接 WBS为进度管理计划提供了框架 控制临界值 用于监督进度绩效，通常用偏离基准计划中的参数的某个百分数表示 绩效测量规则 确定完成百分比规则 0/100，20/80，50/50等 挣值管理（EVM）技术 基准法、固定公式法、完成百分比法等 进度绩效测量标准 进度偏差（SV）和进度绩效指数（SPI） EVM把范围基准、成本基准和进度基准整合起来，形成绩效测量基准 报告格式定义活动 定义 识别和记录为完成项目可交付成果而须采取的具体行动的过程 作用 将工作包分解为进度活动，作为对项目工作进行进度估算、规划、执行、监督和控制的基础 时间点 整个项目期间开展ITTO 输入（I） 项目管理计划 进度管理计划，范围基准 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 分解 把项目范围和项目可交付成果逐步划分为更小、更便于管理的组成部分 定义活动过程的最终输出是活动而不是可交付成果，可交付成果是指导于管理项目工作过程的输出，范围基准是创建WBS过程的输出。 让团队成员参与分解过程，有助于得到更好、更准确的结果。 滚动式规划 迭代式的规划技术，是一种渐进明细的规划方式 适用于工作包、规划包以及采用敏捷或瀑布式方法的发布规则 详细规划近期要完成的工作、在较高层级粗略规划远期工作 会议 输出（O） 活动清单 项目所需的进度活动，包括每个活动的标识和工作范围详述，对于滚动式或敏捷项目，活动清单要定期更新 活动属性 每项活动所具有的多重属性，用来扩充对活动的描述 里程碑清单 项目中的重要时点或事件，指明每个里程碑是强制性(活动要求)的还是选择性（根据历史信息确定）的 里程碑的持续时间是零，它不是活动 变更请求 项目管理计划更新 进度基准，成本基准排列活动顺序 定义 识别和记录项目活动之间的关系的过程 作用 定义工作之间的逻辑顺序，以便在既定的所有项目制约因素下获得最高的效率 时间点 整个项目期间开展ITTO 输入（I） 项目管理计划 进度管理计划，范围基准 项目文件 活动属性，活动清单，假设日志，里程碑清单 事业环境因素和组织过程资产 工具与技术（TT） 紧前关系绘图法（PDM）：节点法/前导图法/单代号法/AON 用节点表示活动、用一种或多种逻辑关系连接活动，以显示活动的实施顺序 完成到开始（FS）：只有紧前活动完成，紧后活动才能开始 完成到完成（FF）：只有紧前活动完成，紧后活动才能完成 开始到开始（SS）：只有紧前活动开始，紧后活动才能开始 开始到完成（SF）：只有紧前活动开始，紧后活动才能完成，如换班 只有紧前活动怎样，紧后活动才能怎样 不建议相同的活动之间存在多种关系，也不建议采用闭环的逻辑关系 确定和整合依赖关系 强制性依赖关系 法律或合同要求的或工作的内在性质决定的依赖关系 往往与客观限制有关 选择性依赖关系 又称首选逻辑关系、优先逻辑关系或软逻辑关系 如果打算快速跟进，则应当审查相应的选择性依赖关系，并考虑是否需要调整或去除 外部依赖关系 项目活动与非项目活动之间的依赖关系，往往不在项目团队的控制范围内 内部依赖关系 项目活动之间的紧前关系，通常在项目团队的控制之中 提前量和滞后量 提前量：相对于紧前活动，紧后活动可以提前的时间量 滞后量：相对于紧前活动，紧后活动必须推迟的时间量 提前量和滞后量的使用不能替代进度逻辑关系，而且持续时间估算中不包括任何提前量或滞后量 项目信息管理系统 输出（O） 项目进度网络图 表示项目活动之间的逻辑关系（依赖关系）的图形 在路径汇聚（多个紧前活动）和路径分支（多个紧后活动）的地方，存在更大的风险 项目文件更新 活动属性，活动清单，假设日志，里程碑清单估算活动时间 定义 根据资源估算的结果，估算完成单项活动所需工作时段数的过程 作用 确定完成每个活动所需花费的时间量 时间点 整个项目期间开展 备注 应该有项目中最熟悉具体活动的个人或小组提供持续时间估算所需的各种输入 对持续时间的估算应该渐进明细，取决于输入数据的数量和质量 收益递减规律（临界点）、资源数量、技术进步、员工激励（学生综合征和帕金森定律）ITTO 输入（I） 项目管理计划 进度管理计划，范围基准 项目文件 活动属性，活动清单，假设日志，经验教训登记册，里程碑清单，项目团队派工单，资源分解结构，资源日历，资源需求，风险登记册 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 类比估算 一种使用相似活动或项目的历史数据，来估算当前活动或项目的持续时间或成本的技术，成本较低、耗时较少，但准确性也较低，是至上而下整体的专家判断 参数估算 一种基于历史数据和项目参数之间的统计关系和其他变量，使用某种算法来计算成本或持续时间的估算技术。准确性取决于参数模型的成熟度和基础数据的可靠性 三点估算 考虑估算中的不确定性和风险，利用最可能时间（Tm），最乐观时间(To)，最悲观时间(Tp)界定活动持续时间的近似区间。 三角分布：t=(Tm+To+Tp)/3 贝塔分布：t=(Tm+To*4+tP)/6 正负1个西格玛68.5%；正负2个西格玛95.4%；正负3个西格玛99.7% 自下而上估算 一种估算项目持续时间或成本的方法，通过自下而上的逐层汇总WBS组成部分的估算而得到项目估算 数据分析 备选方案分析 储备分析 用于确定项目所需的应急储备量和管理储备 应急储备与已知-未知风险相关，用来应对已经主动接受的已识别的风险。随着项目信息越来越明确，可以动用、减少或取消应急储备。 管理储备与未知-未知风险相关，用来应对项目范围中不可预见的工作。使用管理储备可能需要变更进度基准 决策：投票 会议 输出（O） 持续时间估算 对完成某项活动、阶段或项目所需的工作时段数的定量评估，其中不包括任何滞后量，但可指出一定的变动区间 估算依据 持续时间估算所需的支持信息的数量和种类 项目文件更新制定进度计划 定义 分析活动顺序、持续时间、资源需求和进度制约因素，创建进度模型，从而落实项目执行和监控的过程 作用 为完成项目而制定具有计划日期的进度模型 时间点 整个项目期间开展ITTO 输入（I） 项目管理计划 进度管理计划，范围基准 项目文件 活动属性，活动清单，假设日志，估算依据，持续时间估算，经验教训登记册，里程碑清单，项目进度网络图，项目团队派工单，资源日历，资源需求，风险登记册 协议 供应商为项目进度提供在制定如何执行项目工作以履行合同承诺的详细信息 事业环境因素和组织过程资产 工具与技术（TT） 进度网络分析 包含以下技术：关键路径法、资源优化技术、建模技术。 当多个路径在同一时间点汇聚或分叉时，评估汇总进度储备的必要性，以减少出现进度延误的可能性 是一个反复进行的过程，一直持续到创建出可行的进度模型 关键路径法 是项目中时间最长的活动顺序，决定着可能的项目最短工期。最长路径的总浮动时间最少，通常为零 总浮动时间是进度活动可以从最早开始日期推迟或拖延的时间，而不至于延误项目完成日期或违反进度制约因素。 总浮动时间可能是正值、负值或零。出现负值说明违反了对最晚日期的制约因素，需要调整活动持续时间（增加资源或缩减范围）、逻辑关系、提前量和滞后量或其他进度制约因素 自由浮动时间是不延误任何紧后活动最早开始日期或不违反进度制约因素的前提下，某进度活动可以推迟的时间量 关键路径法不考虑资源限制，总浮动时间体现进度的灵活性 资源优化 资源平衡 为了在资源需求与资源供给之间取得平衡，根据资源制约因素对开始时间和完成时间进行调整的技术 往往导致初始关键路径改变，用浮动时间平衡资源，避免资源波动范围大的情况 资源平滑 对进度模型中的活动进行调整，从而使项目资源需求不超过预定的资源限制的技术 不会改变项目关键路径，完工日期也不会延迟。活动只在其自由和总浮动时间内延迟，但无法实现所有资源的优化 数据分析 假设情景分析 对各种情景进行评估，预测他们对项目目标的影响 根据分析结果，评估项目进度计划在不同条件下的可行性，以及为应对意外情况的影响而编制进度储备和应对计划 模拟（蒙特卡罗） 把单个项目风险和不确定性的其他来源模型化，以评估他们对项目目标的潜在影响 提前量和滞后量 提前量用于在条件许可的情况下提早开始紧后活动 滞后量是在某些限制条件下，在紧前和紧后活动之间增加一段不需工作或资源的自然时间 进度压缩 在不缩减项目范围前提下，缩短或加快进度工期，以满足进度制约因素、强制日期或其他进度目标 赶工：增加成本，通过增加资源、以最小的成本代价来压缩进度工期的技术 快速跟进： 增加风险，将正常情况下按顺序进行的活动或阶段改为至少部分并行开展 项目管理信息系统 敏捷发布规划 基于项目路线图和产品发展愿景，提供了高度概括的发布进度时间轴，还确定了发布的迭代或冲刺次数 输出（O） 进度基准 经过批准的进度模型，只有通过正式的变更控制程序才能进行变更，用作与实际结果进行对比的依据 项目进度计划 横道图（甘特图） 面向管理层，纵向列表示活动，横向列表示时间，用横条表示活动自开始日期至完成日期的持续时间 里程碑图 面向客户，标出主要可交付成果或关键外部接口的计划开始或完成日期 项目进度网络图 通常用活动节点绘制，没有时间刻度，存粹显示活动及其相互关系，也称纯逻辑图 进度数据 用于描述和控制进度计划的信息集合，至少包括进度里程碑、进度活动、活动属性、以及已知的全部假设条件与制约因素 项目日历 规定可以开展进度活动的可用工作日和工作班次 项目日历是什么时候工作，资源日历是什么时候可用，可用多久 变更请求 修改项目范围或项目进度，可能对范围基准、项目管理计划等提出变更 项目管理计划更新 进度管理计划,成本基准 项目文件更新 活动属性，活动清单，持续时间估算，经验教训登记册，资源需求，风险登记册控制进度 定义 监督项目状态、以更新项目进度和管理进度基准变更的过程 作用 在整个项目期间保持对进度基准的维护 时间点 整个项目期间开展ITTO 输入（I） 项目管理计划 进度管理计划， 进度基准，范围基准，绩效测量基准 项目文件 经验教训登记册，项目日历，项目进度计划，资源日历，进度数据 工作绩效数据 包含关于项目状态的数据 组织过程资产 工具与技术（TT） 数据分析 挣值分析(进度) 进度绩效测量指标用于评价偏离初始进度基准的程度 迭代燃尽图 用于追踪迭代未完成项中尚未完成的工作 绩效审查 根据进度基准，测量、对比和分析进度绩效 趋势分析 检查项目绩效随时间的变化情况，以确定绩效是在改善还是恶化 偏差分析 关注实际开始和完成日期与计划的偏离，实际持续时间与计划的差异，以及浮动时间的偏差 包括确定偏离进度基准的原因和程度，评估这些偏差对未来工作的影响，以及确定是否需要采取纠正措施或预防措施 假设情景分析 关键路径法 项目管理信息系统 资源优化 提前量和滞后量 进度压缩 输出（O） 工作绩效信息 包括与进度基准相比较的项目工作执行情况 进度预测 根据已有的信息和知识，对项目未来的情况和事件进行估算或预计 变更请求 项目管理计划更新 进度管理计划、进度基准、成本基准、绩效测量基准 项目文件更新 假设日志、估算依据、经验教训登记册、项目进度计划、资源日历、风险登记册、进度数据","categories":[{"name":"项目管理","slug":"项目管理","permalink":"http://www.whoosh.site/categories/项目管理/"}],"tags":[{"name":"PMP","slug":"PMP","permalink":"http://www.whoosh.site/tags/PMP/"},{"name":"PMBOK","slug":"PMBOK","permalink":"http://www.whoosh.site/tags/PMBOK/"}]},{"title":"项目范围管理","slug":"20180420_项目范围管理","date":"2018-04-20T03:15:58.000Z","updated":"2018-06-20T22:39:28.885Z","comments":true,"path":"2018/04/20/20180420_项目范围管理/","link":"","permalink":"http://www.whoosh.site/2018/04/20/20180420_项目范围管理/","excerpt":"","text":"范围管理 项目范围管理确保项目做且只做所需的全部工作。 范围包括产品范围（某些产品、服务或成果所具有的特征和功能）和项目范围（为交付具有规定特性与功能的产品、服务或成果而必须完成的工作）。 在适应型或敏捷型生命周期中，每次迭代都会重复开展确认范围和控制范围两个过程。 在预测型生命周期中，经过批准的项目范围说明书、WBS和WBS词典构成范围基准，只有通过正式变更控制程序，才能进行修改。 项目范围的完成情况根据项目管理计划来衡量，产品范围的完成情况根据产品需求来衡量规划范围管理 定义 为了记录如何定义、确认和控制项目范围及产品范围，而创建范围管理计划的过程 作用 在整个项目期间对如何管理范围提供指南和方向 时间点 仅开展一次或仅在预定义节点开展ITTO 输入（I） 项目章程 项目管理计划 质量管理计划 在项目中实施组织的质量政策、方法和标准的方式会影响管理项目和产品范围的方式 项目生命周期描述 定义了项目从开始到完成所经历的一系列阶段 开发方法 定义了项目采用瀑布式、迭代型、适应型、敏捷型还是混合型开发方式 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 数据分析 备选方案分析 用于评估收集需求、描述项目和产品范围、创造产品、确认范围和控制范围的各种方法 会议 输出（O） 范围管理计划 描述将如何定义、制定、监督、控制和确认项目范围 需求管理计划 描述将如何分析、记录和管理项目和产品需求收集需求 定义 为实现目标而确定、记录并管理相关方的需要和需求的过程 作用 为定义产品范围和项目范围奠定基础 时间点 仅开展一次或仅在预定义点开展 备注 需求：根据特定协议或其他强制性规范，产品、服务或成果必须具备的条件或能力。包括发起人、客户和其他相关方的已量化且书面记录的需要和期望ITTO 输入（I） 项目章程 项目管理计划 范围管理计划，需求管理计划，相关方参与计划 项目文件 假设日志，经验教训登记册，相关方登记册 商业文件 商业论证：描述了为满足业务需要应达到的必要、期望及可选标准 协议 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 数据收集 头脑风暴 访谈 焦点小组 召集同职能的相关方和主题专家讨论项目风险、成功标准和其他议题，比访谈有利于交流 问卷调查 适用于受众多样化，需要快速完成调查，受访者地理位置分散，并且适合开展统计分析 标杆对照 将实际或计划的产品，过程和实践，与其他可比组织的实践进行比较，以便识别最佳实践，形成改进意见，并为绩效考核提供依据 可比组织可是内部的，也可以是外部的 数据分析 文件分析：包括审核和评审任何相关的文件信息 决策 投票：原则包括一致同意（德尔菲法）、大多数同意（&gt;50%）、相对多数同意 独裁型决策制订 多标准决策分析 数据表现 亲和图 用来对大量创意进行分组的技术，以便进一步审查和分析 思维导图 把从头脑风暴中获得的创意整合成一张图，反映创意之间的共性和差异，激发新创意 人际关系与团队技能 名义小组技术 向集体提出一个问题或难题 主持人在活动挂图上记录所有人的想法 集体讨论各个想法，直到全体成员达成一个明确的共识 进行多轮投票，个人私下投票决出各种想法的优先排序 观察/交谈 工作跟随，直接观察个人在各自的环境中如何执行工作和实施流程，来体验该流程或程序实施过程，以便挖掘隐藏需求 引导 联合应用设计或开发（JAD） 软件开发行业，把业务主题专家和开发团队集中在一起，以收集需求和改进软件开发过程 质量功能展开（QFD） 制造行业，用于确定新产品的关键特征 用户故事 需求研讨会，对所需的功能的简短文字描述 引导式研讨会用于快速定义跨职能需求并协调相关方的需求差异 系统交互图 对产品范围的可视化描述，显示业务系统及其与人和其他系统之间的交互方式 原型法 使得相关方可以体验最终产品的模型，而不是仅限于讨论抽象的需求描述 原型法有助于减轻返工的风险，其流程：1.创建模型、2.用户体验、3.反馈收集、4.修改原型 输出（O） 需求文件 描述各种单一需求将如何满足项目相关的业务需求，一开始可能只有高层级的需求，然后随着有关需求信息的增加而逐步细化 需求类别：业务需求、相关方需求、解决方案需求（功能需求/非功能需求）、过渡和就绪需求（当前状态到将来状态）、项目需求、质量需求 需求跟踪矩阵 把产品需求从其来源连接到能满足需求的可交付成果的一种表格 提供了在整个项目生命周期中跟踪需求的一种方法，有助于确保需求文件中被批准的每项需求在项目结束的时候都能交付 需求跟踪矩阵还为管理产品范围变更提供了框架。定义范围 定义 制定项目和产品详细的过程 作用 描述产品、服务或成果的边界和验收标准 时间点 经开展一次或在预定义点开展 备注 定义范围从需求文件中选取最终的项目需求，然后制定出关于项目及其产品、服务或成果的详细描述ITTO 输入（I） 项目章程 包含对项目的高层级描述、产品特征和审批要求 项目管理计划 范围管理计划：记录了如何定义、确认和控制范围 项目文件 假设日志 需求文件：识别了应纳入范围的需求 风险登记册 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 数据分析 备选方案分析 决策 多标准决策分析 人际关系与团队技能 引导 产品分析 用于定义产品和服务，把高层级的产品或服务描述转变为有意义的可交付成果 输出（O） 项目范围说明书 对项目范围、主要可交付成果、假设条件和制约因素的描述 包括：产品范围描述（渐进明细），可交付成果，验收标准，项目的除外责任(有助于管理相关方的期望及减少范围蔓延) 项目章程包含高层级的信息，范围说明书则是对范围组成部分的详细描述 项目文件更新 包括：假设日志，需求文件，需求跟踪矩阵，相关方登记册创建WBS 定义 把项目可交付成果和项目工作分解成较小、更易于管理的组件的过程 作用 为所有交付的内容提供架构 时间点 仅开展一次或仅在项目的预定义节点开展 备注 WBS组织并定义了项目的总范围，代表着经批准的当前项目范围说明书所规定的工作 WBS最底层的组成部分是工作包，“工作”是指为活动结果的工作产品或可交付成果，而不是活动本身 规划包：低于控制账户而高于工作包的工作分解结构组件，工作内容已知，但详细的进度活动未知ITTO 输入（I） 项目管理计划 范围管理计划 项目文件 项目范围说明书 需要实施的工作及不包含在项目中的工作 需求文件 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 分解：把项目范围和项目可交付成果逐步划分为更小、更便于管理的组成部分的技术 流程： 识别和分析可交付成果及相关工作 确定WBS的结构和编排方法 自上而下逐层细化分解 为WBS组成部分制定和分配标识编码 核实可交付成果分解的程度是否恰当 不同可交付成果可以分解到不同的层次，可以把主要可交付成果作为分解的第二层,也可以以项目生命周期的各个阶段作为分解的第二层，把产品和项目可交付成果放在第三层 过细的分解或造成管理低效及数据汇总困难，一般按照4~6层，80小时，100%原则和单一责任人或组织原则分解工作包 作为外包工作的一部分，卖方需制定相应的合同WBS 如果采用敏捷方法，可以将长篇故事分解成用户故事（收集需求中提到） 输出（O） 范围基准 经过批准的范围说明书、WBS（控制账户-规划包-工作包）和相应的WBS词典(某个WBS组件的详细范围描述)，只有通过正式的变更控制过程才能进行变更 在控制账户节点，把范围、预算和进度加以整合，并与挣值相比较，以测量绩效 项目文件更新 假设日志, 需求文件确认范围 定义 正式验收已完成的项目可交付成果的过程 作用 使验收过程具有客观性，同时通过每个可交付成果的验收，来提高最终产品、服务或成果获得验收的可能性 时间点 整个项目期间开展 备注 确认范围过程与控制质量过程不同之处在于，前者关注可交付成果的验收，后者关注可交付成果的正确性及是否满足质量要求ITTO 输入（I） 项目管理计划 范围管理计划, 需求管理计划,范围基准 项目文件 经验教训登记册,质量报告,需求文件,需求跟踪矩阵 核实的可交付成果 已经完成、并被控制质量过程检查为正确的可交付成果 工作绩效数据 工具与技术（TT） 检查 开展测量、审查与确认等活动，来判断工作和可交付成果是否符合需求和产品验收标准 决策 投票 输出（O） 验收的可交付成果 由客户或发起人正式签字批准的符合验收标准的可交付成果，最后交给结束项目或阶段过程 工作绩效信息 项目进展信息，即可交付成果的验收情况 变更请求 对已经完成但未通过正式验收的可交付成果及其未通过验收的原因，应该记录在案，之后提交变更请求 项目文件更新 经验教训登记册 需求文件 需求跟踪矩阵 控制范围 定义 监督项目和产品的范围状态，管理范围基准变更的过程 作用 在整个项目期间保持对范围基准的维护 时间点 整个项目期间开展 备注 范围蔓延：未经控制的产品或项目范围的扩大，包括内部的镀金和外部的范围潜变 一旦出现范围蔓延，就必须要走变更控制流程ITTO 输入（I） 项目管理计划 范围管理计划，需求管理计划， 变更管理计划，范围基准 配置管理计划 定义了哪些配置项需要正式变更控制，以及变更控制过程 绩效测量基准 经过整合的项目范围、进度和成本基准 使用挣值分析比较绩效测量基准与实际结果差异，判断是否有必要进行变更、采取纠正措施或预防措施 项目文件 经验教训登记册， 需求文件，需求跟踪矩阵 工作绩效数据 变更请求的收到、接受的数量，核实、确认和完成的可交付成果的数量 组织过程资产 工具与技术（TT） 数据分析 偏差分析 用于将基准与实际结果进行比较，确定偏差是否需要采取纠正或预防措施 趋势分析 审查项目绩效随时间的变化情况，判断绩效是改善还是恶化 输出（O） 工作绩效信息 变更请求 项目管理计划更新 范围管理计划, 范围基准, 进度基准,成本基准,绩效测量基准 项目文件更新 经验教训登记册, 需求文件,需求跟踪矩阵","categories":[{"name":"项目管理","slug":"项目管理","permalink":"http://www.whoosh.site/categories/项目管理/"}],"tags":[{"name":"PMP","slug":"PMP","permalink":"http://www.whoosh.site/tags/PMP/"},{"name":"PMBOK","slug":"PMBOK","permalink":"http://www.whoosh.site/tags/PMBOK/"}]},{"title":"项目整合管理","slug":"20180414_项目整合管理","date":"2018-04-14T13:53:50.000Z","updated":"2018-06-22T02:26:17.900Z","comments":true,"path":"2018/04/14/20180414_项目整合管理/","link":"","permalink":"http://www.whoosh.site/2018/04/14/20180414_项目整合管理/","excerpt":"","text":"整合管理 项目整合管理由项目经理负责，该责任不能被授权或转移，项目经理必须对整个项目承担最终责任。 在整个项目生命周期中积累知识并传达给目标受众，以防止知识流失 项目经理被要求介入启动和结束项目阶段，需要更全面地识别相关方，包括管理项目经理与各职能部门、运营部门和高级管理人员之间的接口。 迭代和敏捷的方法能够促进团队以相关领域专家的身份参与整合管理，项目经理的关注点在于营造一个合作性的决策氛围，并确保团队有能力应对变更。 制定项目章程 定义 编写一份正式批准项目并授权项目经理在项目活动中使用组织资源的文件的过程 作用 明确项目与组织战略之间的直接关系、确立项目的正式地位，并展示组织对项目的承诺 时间点 仅开展一次或仅在项目的预定义点开展 备注 项目章程在项目执行组织（乙方）与需求组织（甲方）之间建立其伙伴关系,通常用正式的合同来达成合作协议 最好在制定项目章程时，最晚也要在规划开始之前就任命项目经理 项目章程一旦被批准，就标志着项目的正式启动 项目由项目以外的机构来启动，如发起人、项目集或项目管理办公室、项目组合治理委员会主席或授权代表 项目启动者或发起人应该具有一定的职权，能为项目获取资金并提供资源 通过编制项目章程，来确认项目符合组织战略和日常运营的需要 ITTO 输入（I） 商业文件：在项目之前制定，但需要定期审核 包含商业需求和成本效益分析，以论证项目的合理性并确定项目边界 商业文件不是项目文件，项目经理不可以对其进行更新或修改，但能提出相关建议 协议 用于定义启动项目的初衷，通常以合同形式出现 事业环境因素和组织过程资产 工具与技术（TT） 专家判断： 具有专业学历、知识、技能、经验或培训经历的任何小组或个人 数据收集 头脑风暴 短时间内获得大量创意，并对创意进行分析，倾向于数量，不注重质量 不质疑、不批判、不反对，可与思维导图结合使用 焦点小组 召集同职能的相关方和主题专家讨论项目风险、成功标准和其他议题，比访谈有利于交流 访谈 通过与相关方直接交谈来了解高层级需求、假设条件、制约因素、审批标准以及其他信息（例如一些机密信息） 人际关系与团队技能 冲突管理 有助于相关方就目标、项目描述、总体里程碑等内容达成一致意见 引导 有效引导团队活动成功以达成决定、解决方案或结论的能力 引导者确保参与者有效参与，相互理解，考虑所有意见，按既定决策流程全力支持得到的结论或结果。 引导式研讨会用于快速定义跨职能需求并协调相关方的需求差异 会议管理 会前：包括准备议程、确保邀请每个关键相关方群体的代表 会中：确保讨论内容切题，避免冲突以及解决冲突 会后：准备和发送会议纪要和行动计划 会议 启动会（initiating meeting）：发布项目章程、任命并授权项目经理，各相关方进行认识、表达决心、调动积极性 输出（O） 项目章程 记录了关于项目和项目预期交付的产品、服务或成果的高层级信息。 包括：项目目的、可测量的项目目标和相关的成功标准、高层级需求、高层级项目描述，边界定义以及主要可交付成果、整体项目风险、总体里程碑进度计划、预先批准的财务资源、关键相关方名单、项目审批要求、项目退出标准、委派的项目经理及其职责和职权等。 假设日志 用于记录整个项目生命周期中所有假设条件和制约因素 高层级的战略和运营假设条件记录在项目章程中 低层级的活动和任务假设条件记录在假设日志中制定项目管理计划 定义 定义、准备和协调项目计划的所有组成部分，并把它们整合为一份综合项目管理计划的过程 作用 生成一份综合文件、用于确定所有项目工作的基础及其执行方式 时间点 仅开展一次或仅在项目的预定义点开展，在规划阶段后期进行整合 备注 项目管理计划应基准化、一旦确定了基准，就只能通过实施整体变更控制过程进行更新 项目管理计划需要通过不断更新来渐进明细，并且这些更新需要得到控制和批准ITTO 输入（I） 项目章程 初始项目规划的起始点 其他过程的输出 其他规划过程所输出的子计划和基准，以及变更之后对项目管理计划的相应更新 事业环境因素和组织过程资产 工具与技术（TT） 专家诊断 确定项目所需的资源与技能水平 确定哪些项目文件受制于正式的变更控制过程 数据收集 头脑风暴 核对单 指导项目经理制定计划或帮助检查项目管理计划是否包含所需全部信息 焦点小组 访谈 人际关系与团队技能 冲突管理 引导 会议管理 会议 开工会（kick-off meeting）：在规划阶段即将结束时召开，旨在传达项目目标、获得团队对项目的承诺，以及阐明每个相关方的角色和职责 输出（O） 项目管理计划 计划 范围管理计划 需求管理计划 进度管理计划 成本管理计划 资源管理计划 质量管理计划 沟通管理计划 采购管理计划 风险管理计划 相关方管理计划 变更管理计划 在整个项目期间如何正式审批和采纳变更请求。为变更控制过程提供指导，并记录变更控制委员会的角色和职责 配置管理计划 描述项目的配置项、识别应记录和更新的配置项，以保持产品的一致性和有效性 对配置要素（图纸、原型等）的任何变更都应该提出变更请求，并经过正式控制 基准 范围基准 提供项目和产品定义 进度基准 用于评估变更对项目进度的影响 成本基准 用于评估变更对项目成本的影响 绩效测量基准 经过整合的项目范围、进度和成本基准，用作项目执行的比较依据，以测量和管理项目绩效 其他组件 项目生命周期描述 开发方法指导与管理项目工作 定义 为实现项目目标而领导和执行项目管理计划中所确定的工作，并实施已批准的变更的过程 作用 对项目工作和可交付成果开展综合管理，以提高项目成功的可能性 时间点 整个项目期间开展ITTO 输入（I） 项目管理计划的任何组件 项目文件 包括：变更日志、经验教训登记册、里程碑清单、项目沟通记录、需求跟踪矩阵、风险登记册、风险报告 批准的变更请求 实施整体变更控制过程的输出，包括项目经理、变更控制委员会（CCB）审查和批准的变更请求 流程： 作为指导与管理项目工作的输入，输出变更请求 作为实施整体变更控制的输入，输出批准的变更请求 可能继续循环1过程 可能作为控制质量的输入，输出变更请求 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 项目信息管理系统（PMIS） PMIS是事业环境因素的组成部分，系统包括进度计划软件工具、工作授权系统、配置管理系统、信息收集与发布系统，并且自动收集和报告关键绩效指标（KPI）。 会议 输出（O） 可交付成果 是在某一过程、阶段或项目完成时，必须产出的任何独特并可核实的产品、服务或成果。 流程： 指导与管理项目工作输出可交付成果 作为控制质量的输入，输出核实的可交付成果 作为确认范围的输入，输出验收的可交付成果 作为结束项目或阶段的输入，输出最终的产品、服务或成果 工作绩效数据 在执行项目工作的过程中，从每个正在执行的活动中收集到的原始观察结果和测量值，再交由控制过程进一步分析 流程： 指导与管理项目工作输出工作绩效数据 作为除整合外其他子监控过程的输入，输出工作绩效信息 作为整合中的监控项目工作的输入，输出工作绩效报告 用于管理沟通和实施整体变更控制 问题日志 一种记录和跟进所有问题的项目文件，包括类型、提出者、提出时间、描述、优先级、负责人、解决日期、状态等 问题日志可以帮助项目经理有效跟进和管理问题，确保他们得到调查和解决 在整个项目生命周期随同监控活动更新问题日志 变更请求应对措施 纠正措施（纠偏差） 为了使项目工作绩效重新与项目管理计划一致。 预防措施（防风险） 为了确保项目工作的未来绩效符合项目管理计划 缺陷补救（补质量） 为了修正不一致产品或组件的有目的的活动 更新（改基准） 对正式受控的项目文件或计划进行变更 项目管理计划更新 任何变更都要以变更请求的形式提出，且通过组织的变更控制过程进行处理 项目文件更新 包括活动清单，假设日志，经验教训登记册，需求文件，风险登记册，相关方登记册 组织过程资产更新管理项目知识 定义 使用现有知识并生成新知识，以实现项目目标，并帮助组织学习的过程。 作用 利用已有的项目组织知识来创造和改进项目成果，并且使当前项目创造的知识可用于支持组织运营和未来的项目或阶段。 时间点 整个项目期间开展 备注 知识通常分为显性知识和隐性知识ITTO 输入（I） 项目管理计划 项目文件 包括：经验教训登记册,项目团队派工单,资源分解结构,供方选择标准,相关方登记册 可交付成果 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 知识管理 营造一种相互信任的氛围（如：面对面互动），激励人们分享知识或关注他人的知识。 侧重隐性知识，注重合作、分享、集成 信息管理 创造信息并建立人们与信息之间的联系，增加互动要素（如：与我联系） 侧重显性知识 人际关系与团队技能 积极倾听 有助于减少误解并促进沟通和知识分享 引导 有助于指引团队成功地达成决定、解决方案或结论 领导力 有助于沟通愿景并鼓舞项目团队关注合适的知识和知识目标 人际交往 有助于项目相关方之间建立非正式的联系和关系，为显性或隐形的知识分享创造条件 政治意识 有助于项目经理根据项目环境和组织的政治环境规划沟通 输出（O） 经验教训登记册 包括情况的类别、描述、相关影响、建议和行动方案等，还可以记录遇到的挑战、问题、意识到的风险和机会，以及其他适用的内容 项目管理计划更新 组织过程资产监控项目工作 定义 跟踪、审查和报告整体项目进展，以实现项目管理计划中确定的绩效目标的过程 作用 让相关方了解项目的当前状态并认可为处理绩效问题而采取的行动，以及通过成本和进度预测，让相关方了解项目状态 时间点 整个项目期间开展ITTO 输入（I） 项目管理计划 项目文件 包括：假设日志,估算依据,成本预测,问题日志,经验教训登记册,里程碑清单,质量报告,风险登记册,风险报告,进度预测 工作绩效信息 把执行过程中收集的工作绩效数据，交由控制过程做进一步分析，对比项目的实际绩效与项目管理计划的差异 协议 包括采购协议在内的所有协议都要符合项目的特定要求，以及组织的采购政策 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 数据分析 备选方案分析 用于在出现偏差时选择要执行的纠正措施或纠正措施和预防措施组合 成本效益分析 有助于在项目出现偏差时确定最节约成本的纠正措施 挣值分析 对范围、进度和成本进行综合分析 根本原因分析 识别问题的主要原因，以及出现偏差的原因和为达成项目目标需要关注的领域 趋势分析 根据以往结果预测未来绩效，根据分析结果提出必要的预防措施建议 偏差分析 审查目标绩效与实际绩效之间的差异，涉及持续时间估算、成本估算、资源使用、资源费率、技术绩效和其他测量指标 决策 常见投票的形式，原则包括一致同意（德尔菲法）、大多数同意（&gt;50%）、相对多数同意 会议 输出（O） 工作绩效报告 包含挣值图表和信息、趋势线和预测、储备燃尽图、缺陷直方图、合同绩效信息和风险情况概述，可以用实体或者电子形式加以合并、记录和分发。 变更请求 纠正措施、预防措施、缺陷补救 项目管理计划更新 项目文件更新 成本预测,问题日志,经验教训登记册,风险登记册,进度预测实施整体变更控制 定义 审查所有变更请求、批准变更，管理对可交付成果、项目文件和项目管理计划的变更，并对变更处理结果进行沟通的过程 作用 确保对项目中已记录在案的变更做综合评审。即审查对项目文件、可交付成果或项目管理计划的所有变更请求，并确定变更请求的处置方案 时间点 整个项目期间 备注 参与项目的任何相关方都可以提出变更请求，可以口头提出，但所有变更请求都必须以书面形式记录 需要了解变更对进度和成本的影响 每项记录在案的变更请求都必须由一位责任人批准、推迟或拒绝 在基准确定之前，变更无需正式受控与实施整体变更控制过程，一旦确定了项目基准，就必须按照实施整体变更控制过程来处理变更请求ITTO 输入（I） 项目管理计划 变更管理计划 为变更控制过程提供指导，并记录变更控制委员会的角色和职责 配置管理计划 描述项目的配置项，识别应记录和更新的配置项 范围基准 进度基准 成本基准 项目文件 估算依据 用于计算变更对时间、预算和资源的影响 需求跟踪矩阵 有助于评估变更对项目范围的影响 风险报告 提供了与变更请求有关的整体和单个项目风险的来源信息 工作绩效报告 资源可用情况、进度和成本数据、挣值报告、燃尽图 变更请求 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 变更控制工具 配置管理活动 识别配置项 记录并报告配置项状态 进行配置项核实和登记 变更管理活动 流程：1.记录、2.评估、3.提交、4.更新、5.通知 记录：可以口头提出请求，但一定要项目经理书面记录，或要求变更提出者提交书面的变更请求 评估：充分了解变更， 评估变更带来的影响；与相关方沟通评估出的影响。 批准：提交责任人审批；是指项目经理将变更请求和评估的结果提交给CCB。 更新：不管变更通过还是不通过，必须更新变更日志；如果变更通过，更新项目管理计划和（或）项目文件 通知：应将变更的结果通知相关方（受影响） 如问变更的依据：则优先选择题目涉及的知识领域对应的管理计划，次选变更管理计划 如问变更的流程：则优先选择实施整体变更流程，次选以上的5步骤 变更请求批准人：优选项目管理计划或组织中指定的责任人，次选CCB，再选PMO、发起人、项目经理 数据分析 备选方案分析 成本效益分析 决策 投票 常见投票的形式，原则包括一致同意、大多数同意、相对多数同意 独裁型决策制定 由一个人负责为整个集体制定决策 多标准决策分析 根据一系列定义的准则，用系统分析方法评估变更请求 会议 变更控制会 输出（O） 批准的变更请求 对于批准的变更请求应通过指导与管理项目过程加以实施，对于推迟或否决的变更请求，应通知提出变更请求的个人或小组 项目管理计划更新 对基准的变更，只能基于最新版本的基准且针对将来的情况，而不能变更以往的绩效 项目文件更新 以项目文件更新的形式，在变更日志中记录所有的变更请求和处理情况 结束项目或阶段 定义 终结项目、阶段或合同的所有活动过程 作用 存档项目或阶段信息，完成计划的工作，释放组织团队资源已开展新的工作 时间点 经开展一次或仅在项目预定义点开展 备注 项目正常收尾的流程 获得项目验收 移交可交付成果 客户满意度调查 总结经验教训 更新组织过程资产 文件归档 庆功会 释放资源 如果项目在完工前提前终止 制定程序，调查和记录提前终止的原因 在正式的收尾文件中说明终止的原因 把已完成和未完成的可交付成果移交他人 把历史信息和经验教训信息存入经验教训知识库ITTO 输入（I） 项目章程 项目管理计划 项目文件 确保所有的项目文件和可交付成果都是最新版本 验收的可交付成果 包括批准的产品规范、交货收据和工作绩效文件 商业文件 商业论证，用于确定是否达到了经济可行性研究的预期结果 效益管理计划，用于测量是否达到了计划的效益 协议 采购文档 组织过程资产 工具与技术（TT） 专家判断 数据分析 文件分析 有助于总结经验教训和分享知识，以改进未来的项目和组织资产 回归分析 作用于项目结果的不同项目变量之间的相互关系，以提高未来项目的绩效 趋势分析 用于确认组织所用模式的有效性，以调整未来项目的模式 偏差分析 通过比较最初的计划目标与最终结果来改进组织的测量指标 会议 收尾报告会、客户总结会、经验教训总结会、庆祝会 输出（O） 项目文件更新 经验教训登记册 最终产品、服务或成果移交 把项目交付的最终产品、服务和成果从一个团队转移到另一个团队 最终报告 组织过程资产更新 包括项目文件，运营和支持文件，项目或阶段收尾文件，经验教训知识库 项目或阶段收尾文件表明项目或阶段完工的文件，用来将完成的项目或阶段的可交付成果移交给他人的正式文件","categories":[{"name":"项目管理","slug":"项目管理","permalink":"http://www.whoosh.site/categories/项目管理/"}],"tags":[{"name":"PMP","slug":"PMP","permalink":"http://www.whoosh.site/tags/PMP/"},{"name":"PMBOK","slug":"PMBOK","permalink":"http://www.whoosh.site/tags/PMBOK/"}]},{"title":"项目管理概念","slug":"20180406_项目管理概念","date":"2018-04-06T13:13:58.000Z","updated":"2018-06-22T01:10:16.767Z","comments":true,"path":"2018/04/06/20180406_项目管理概念/","link":"","permalink":"http://www.whoosh.site/2018/04/06/20180406_项目管理概念/","excerpt":"","text":"引论项目 项目是为创造独特的产品、服务或成果而进行的临时性工作。是组织创造价值和效益的主要方式。 12345678910111213独特的产品、服务或成果* 开展项目的目的是为了通过`可交付成果`达成`目标`,* 可交付成果:在某一个过程、阶段或者项目完成时，必须产出的任何独特并`可核实的` 产品、成果或服务能力，可以是有形的，也可以是无形的。* 目标：工作所指向的结果，例如：战略地位、目的、成果、产品或服务等。* 项目的独特性带来不确定性（风险）临时性工作* 项目有明确的起点和终点，并不意味着项目的持续时间短。* 可交付成果可能会在项目终止后依然存在，不具备临时性渐进明细* 项目是一个渐进明细的过程，通过滚动式规划实现 项目驱动组织进行变更 推动组织从一个状态转到另一个状态，从而达成特定目标。 项目创造商业价值 特定项目成果能够为相关方带来收益，收益可以是有形的、无形的或者二者皆有。 项目启动背景 符合法规、法律或社会需求；满足相关方的要求或需求；执行、变更业务或技术战略；创造、改进或修复产品、过程或服务。 项目管理的重要性 项目管理：将知识、技能与技术应用到项目活动中，以满足项目的要求。可以使组织能够有效且高效的开展项目。 项目是组织创造价值和效益的主要方式。 有效和高效的项目管理，使组织能够： 将项目成果与业务目标联系起来； 更有效地展开市场竞争； 支持组织发展； 通过适当调整项目管理计划，以应对商业环境改变给项目带来的影响。 项目、项目集、项目组合 项目的三种模式：独立项目、在项目集内、在项目组合内。 项目集：是一组相互关联且被协调管理的项目、子项目集和项目集活动，以便获得分别管理所无法获得的利益。项目集不是大型项目，注重项目与项目之间、项目与项目集之间的依赖关系。 项目组合：是为实现战略目标而组合在一起管理的项目、项目集、子项目组合和运营工作。项目组合中的项目集或项目不一定彼此依赖或直接相关 项目和项目集管理的重点在于以正确的方式开展项目集和项目。 项目组合管理的重点在于开展正确的项目集和项目。 三者之间的区别： 组织级项目管理（OPM）和战略：为实现战略目标而整合项目组合、项目集和项目管理与组织驱动因素的框架。旨在确保组织开展正确的项目并合适地分配关键资源。 运营管理：关注产品的持续生产和（或）服务的持续运作，是一个持续的、重复的风险几乎为零的过程。 在每个交叉点，可交付成果即知识在项目与运营之间转移，已完成工作交接。 项目往往来自于运营，又服务运营。 项目生命周期 项目生命周期：项目从启动到完成、开始到结束所经历的一些列阶段，通用生命周期包括：开始项目、组织与准备、执行项目工作、结束项目。 成本与人力投入：项目开始时缓慢增加，在执行工作期间达到最高，项目快结束时迅速回落 风险与不确定性、相关方的影响力、变更的数量：项目开始时最大，后续逐步降低；变更的代价、风险的影响：项目开始时较小，后续显著增高。 项目生命周期：预测型或适应型 开发生命周期：预测型、迭代型、增量型、适应型或混合型 产品生命周期可能包含多个项目生命周期 项目生命周期包含一个或多个开发生命周期 项目管理生命周期是五大过程组 生命周期 描述 预测型 在生命周期的早期阶段确定项目范围、时间和成本。对任何范围的变更都要进行仔细管理。预测型生命周期也称为瀑布型生命周期，是计划驱动的。充分了解产品,厚实的行业实践基础,整批一次性交付有利于相关方 迭代型 在生命周期的早期确定，但时间及成本估算将随着项目团队对产品理解的不断深入而定期修改。迭代方法是通过一系列重复的循环活动来开发产品。不断变化目标和范围,需降低项目复杂性(大型复杂),部分交付有利于相关方 增量型 通过在预定的时间区间内渐进增加产品功能的一系列迭代来产出可交付成果。只有在最后一次迭代之后，可交付成果具有了必要和足够的能力，才能被视为完整的。增量方法是渐进地增加产品的功能 适应型 详细范围在迭代开始之前就得到了定义和批准。适应型生命周期也称为敏捷或变更驱动型生命周期。需应对快速变化的环境,需求和范围难以事先确定,较小增量改进有利于相关方 混合型 充分了解或有确定需求的项目要素遵循预测型开发生命周期，而仍在发展中的要素遵循适应型开发生命周期，是预测型生命周期和适应型生命周期的组合。 项目阶段：一组具有逻辑关系的项目活动的集合，项目可以分解为不同的阶段或子组件，包括阶段的准入标准和退出标准 项目关口：设在阶段结束点，也被称为阶段审查、关键决策点和阶段入口或阶段出口、生死点、里程碑等。 项目管理过程：通过合适的项目管理工具和技术将一个或多个输入转化成一个或多个输出。一个过程的输出通常成为另一个过程的输入，也可能成为项目或项目阶段的可交付成果。 过程通常分为三类： 123&gt; 仅开展一次或仅在项目预定义点开展的过程（例如制定项目章程以及结束项目或阶段）&gt; 根据需要定期开展的过程（在需要资源时执行获取资源。在需要采购之前执行实施采购）&gt; 贯穿项目始终执行的过程（从项目开始到项目结束需要持续开展许多监控过程） 五大过程组： 名称 描述 启动过程组 定义一个新项目或现有项目的一个新阶段，授权开始该项目或阶段的一组过程 规划过程组 明确项目范围，优化目标，为实现目标制定行动方案的一组过程 执行过程组 完成项目管理计划中确定的工作，以满足项目要求的一组过程 监控过程组 跟踪、审查和调整项目进展与绩效，识别必要的计划变更并启动相应变更的一组过程 收尾过程组 正式完成或结束项目、阶段或合同所执行的过程 十大知识领域： 名称 描述 整合管理 识别、定义、组合、统一和协调个项目过程组的各个过程和活动而开展的过程与活动 范围管理 确保项目做且只做所需的全部工作，已成功完成项目的各个过程 进度管理 为管理项目按时完成所需的各个过程 成本管理 为项目在批准的预算内完成而对成本进行规划、估算、预算、融资、筹资、管理和控制的各个过程 质量管理 把组织的质量政策应用于规划、管理、控制项目和产品质量要求，以满足相关方的期望的各个过程 资源管理 识别、获取和管理所需资源以成功完成项目的各个过程 沟通管理 为确保项目信息及时且恰当地规划、收集、生成、发布、存储、检索、管理、控制、监督和最终处置所需的各个过程 风险管理 规划风险管理、识别风险、开展风险分析、规划风险应对、实施风险应对和 监督风险的各个过程。 采购管理 从项目团队外部采购或获取所需产品、服务或成功的各个过程 相关方管理 识别影响或受项目影响的人员、团队或组织，分析相关方对项目的期望和影响，制定合适的管理策略来有效调动相关方参与项目决策和执行 五大过程组和十大知识领域 知识领域 启动过程组 规划过程组 执行过程组 监控过程组 收尾过程组 整合管理 制定项目章程 制定项目管理计划 指导与管理项目工作、管理项目知识 监控项目管理工作、实施整体变更控制 结束项目或阶段 范围管理 规划范围管理、收集需求、定义范围、创建WBS 确认范围、控制范围 进度管理 规划进度管理、定义活动、估算活动时间、排列活动顺序、制定项目进度计划 控制进度 成本管理 规划成本管理、估算成本、制定预算 控制成本 质量管理 规划质量管理 管理质量 控制质量 资源管理 规划资源管理、估算活动资源 获取资源、建设团队、管理团队 控制资源 沟通管理 规划沟通管理 管理沟通 监督沟通 风险管理 规划风险管理、识别风险、实施定性风险分析、实施定量风险分析、规划风险应对 实施风险应对 监督风险 采购管理 规划采购管理 管理采购 控制采购 相关方管理 识别相关方 规划相关方管理 管理相关方参与 监督相关方参与 工作绩效数据、工作绩效信息和工作绩效报告 工作绩效数据：在执行过程组收集到的原始观察结果和测量值（反映项目当前情况（范、进、成）的第一手、基础的数据） 工作绩效信息：在各子监控过程中进行整合分析得到的绩效数据（工作绩效数据和基准计划对比后的偏差结果） 工作绩效报告：在整合管理的监控过程中汇编工作绩效信息形成的文件（可真实提交给相关方，能全面反映项目情况的真实文件），用于管理沟通过程。 项目管理商业文件 项目商业论证：文档化的可行性研究报告，列出了项目启动的目标和理由，有助于在项目结束时根据项目目标衡量项目是否成功。 项目效益管理计划：为发起组织和项目预期受益方创造价值的行动、行为、产品、服务或成果的结果。描述了项目实现效益的方式和时间，以及应制定的效益衡量机制。 项目成功标准 完成项目效益管理计划 达到商业论证中记录的已商定的财务测量指标 完成组织从当前状态转到将来状态 达到组织战略、目的和目标 使相关方满意 项目运行环境事业环境因素 事业环境因素是指项目团队不能控制的，将对项目产生影响、限制或指令作用的各种条件，这些条件可能来源于组织内部也可能来源于组织外部。 1234&gt; 组织内部因素：组织文化、结构和治理；设施和资源的地理分布； 基础设施；`信息技术软件(PMIS)`；资源可用性；`员工能力`等。&gt; 组织外部因素：市场条件、社会和文化影响与问题；`法律限制`； `商业数据库`；学术研究；政府或行业标准；财务考虑因素；物理环境要素等。 组织过程资产 组织过程资产是执行组织所特有并使用的计划、过程、政策、程序和知识库，会影响对具体项目的管理。组织过程资产包括过程、政策和程序和组织知识库两大类。 123&gt; 过程、政策和程序：包括但不限于启动和规划、执行和监控、收尾的流程与程序&gt; 组织项目库：包括但不限于配置管理知识库、`财务数据库`、历史信息与经验教训知识库、 问题与缺陷管理数据库、测量指标数据库以及以往项目的项目档案等。 组织系统 组织系统因素包括管理要素、治理框架和组织结构类型。 管理要素：组织内部关键职能部门或一般管理原则的组成部分。 组织治理框架：治理是在组织内部行使职权的框架，包括但不限于规则、政策、程序、规范、关系、系统、过程。会影响到组织目标的设定和实现方式、风险监控和评估方式、绩效优化方式。 组织结构类型：主要是职能型-弱矩阵型-平衡矩阵型-强矩阵型-项目型（权力由小到大，以平衡矩阵型为关注点），另外还有系统型或简单型、多部门、项目导向、虚拟、混合等。 项目管理办公室（PMO）：是对与项目相关的治理过程进行标准化，并促进资源、方法论、工具和技术共享的一个组织结构。主要职能通过各种方式向项目经理提供支持。 支持型：文档支持。是顾问、项目资源库，对项目控制程度很低 控制型：支持+要求服从，对项目控制程度中等 指令型：直接管理和控制，对项目控制程度很高 项目经理的角色项目经理的定义 项目经理–专注项目目标的达成。由执行组织委派，领导团队实现项目目标的个人。 职能经理–专注某个职能领域或业务部门的管理监督 运营经理–专注业务运营的高效性 项目经理的影响力范围 项目经理的影响力范围：项目、组织、行业、专业学科、跨领域 项目经理的胜任力 PMI人才三角：技术项目管理、领导力、战略和商务管理 技术项目管理：有效运用项目管理知识实现项目集或项目的预期成果的能力 领导力：包括指导、激励和带领团队的能力 战略和商务管理技能：纵览组织概况并有效协商和执行有利于战略调整和创新的决策和行动的能力 权力 权力种类 权力来源 好坏顺序 对谁有效 专家权力 来自于项目经理个人具有的某些技能或技术专长 最好 与本专业相关者 参照权力（潜示权力） 来自于项目经理个人吸引他人并建立起他人对自己的忠诚度的能力 较好 任何人 奖励权力 来自于项目经理职位通过给予他人有价值的物质奖励的能力 较好 下属 正式权力（法定权力） 来自于项目经理职位和职务所拥有的权力 一般 下属 惩罚权力 来自于项目经理职位通过使用或威胁使用惩罚手段来影响他人的能力 不好（慎用） 下属 领导力风格 放任型：无为而治，允许团队自主决策和设定目标 交易性：关注目标、反馈和成就以确定奖励，例外管理 服务型：服务优先于领导，关注他人的成长、学习、发展、人际关系、团体与合作 变更型：通过理想化特质和行为、鼓舞性激励、促进创新和创造，以及个人关怀提高追随者能力 魅力型：精神饱满、热情洋溢、充满自信、说服力强、能够激励他人 交互型：结合了交易型、变更型和魅力型的特点。 执行整合 执行项目整合时，项目经理承担双重角色： 与项目发起人携手合作，既要了解战略目标并确保项目目标和成果与项目组合、项目集以及业务领域保持一致。项目经理以这种方式有助于项目的整合与执行。 在项目层面上，项目经理负责指导团队关注真正重要的事务并协同工作。为此，项目经理需要整合过程、知识和人员。 整合的层面：过程层面、认知层面、背景层面 执行整合 内容 过程层面 项目经理整合相互作用的项目过程，在整个项目期间实施整体变更控制过程是为了整合变更请求。 认知层面 项目经理应尽量掌握所有项目管理知识领域。熟练掌握这些知识领域之后，项目经理可以将经验、见解、领导力、技术以及商业管理技能运用到项目管理中。 背景层面 项目经理需要意识到项目背景和一些新因素（新技术、社交网络、多元文化、新价值观等），然后项目经理可以决定如何在项目中最好地利用这些新环境因素，以获得项目成功。 整合与复杂性：项目的复杂性来源于组织的系统行为、人类行为以及模糊性。","categories":[{"name":"项目管理","slug":"项目管理","permalink":"http://www.whoosh.site/categories/项目管理/"}],"tags":[{"name":"PMP","slug":"PMP","permalink":"http://www.whoosh.site/tags/PMP/"},{"name":"PMBOK","slug":"PMBOK","permalink":"http://www.whoosh.site/tags/PMBOK/"}]},{"title":"PDCharts局部放电图谱库","slug":"20180318_PDCharts局部放电图谱库","date":"2018-03-18T13:13:58.000Z","updated":"2018-03-20T14:13:38.383Z","comments":true,"path":"2018/03/18/20180318_PDCharts局部放电图谱库/","link":"","permalink":"http://www.whoosh.site/2018/03/18/20180318_PDCharts局部放电图谱库/","excerpt":"","text":"概述PDCharts是为满足业务需求在Echarts基础上进行二次封装的图谱库。 &emsp;&emsp;ECharts，一个纯 Javascript 的图表库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖轻量级的 Canvas 类库 ZRender，提供直观，生动，可交互，可高度个性化定制的数据可视化图表。 PDcharts目前支持以下图谱： AE：幅值图谱、时域波形图谱、相位图谱、飞行图谱； UHF/HFCT：PRPS二维图谱、PRPS三维图谱、PRPD二维图谱、PRPD三维图谱、周期图谱； 红外：温度矩阵图谱； 铁芯接地：接地电流图谱； 机械特性：电机电流曲线、原始电流曲线、线圈电流曲线、扭矩曲线、振动信号曲线、振动频率信号曲线、行程曲线、开关量曲线 项目地址：https://github.com/zhangzqiang/pdcharts 使用说明由于pdcharts.js依赖于echarts.js，在使用时，需要在HTML页面中引入echarts.js，另外，如果需要用到PRPS三维图谱或者PRPD三维图谱，还需要引入echarts-gl.js\u001c，点击这里下载echarts。 123&lt;script type=\"text/javascript\" src=\"echarts.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"echarts-gl.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"pdcharts.js\"&gt;&lt;/script&gt; PDCharts对外提供图谱类型对象chartType、绘图方法draw(targetEl, opts)和更新图谱配置updateOption(chart, opts)，下面具体介绍使用方法。 &gt; chartType获取pdcharts支持的图谱类型： 1var chartType = pdcharts.chartType; AE：amplitude,wave,phase,fly UHF/HFCT：prps2d,prps3d,prpd2d,prpd3d,cycle,prpsd 铁芯接地：earthcurrent 红外：infrared 机械特性：mech,switches &emsp;&emsp;注:prpsd用于云诊断或报告中的三维PRPS或者PRPD图谱；switches用于开关量图谱，且图谱数据无需进行偏移处理。 &gt; draw(targetEl, opts)draw()是在目标Div中\u001d根据一些配置参数进行图谱绘制的方法，其中engine、type、data为必选配置项，width、height为可选配置项。 engine：当前采用哪种绘图引擎，目前仅支持echarts，后期添加canves，svg type：图谱类型，参见 chartType data：图谱数据，不同图谱类型数据结构不同，具体参见数据结构说明 width：图谱宽度，如果没有配置，则默认为当前浏览器的宽度。 height：图谱高度，如果没有配置，则默认为当前浏览器的高度。 cover：图谱显示方式，false为居中显示，true为平铺显示。默认为false。 12345678910111213141516171819202122232425262728293031323334353637383940var targetEl=document.getElementById('amplitude');var chartBody=&#123; title: \"AE幅值图谱\", axisInfo: &#123; valDesc: \"测量值\", valColor: \"#1BA261\", bgValDesc: \"背景值\", bgColor: \"#DD5044\", unit: \"mV\", frequecy: 50 &#125;, series: [&#123; name: \"有效值\", min: -1, max: 10, dataList: [0.2, 1.2] &#125;, &#123; name: \"周期最大值\", min: 0, max: 20, dataList: [0.4, 7.5] &#125;, &#123; name: \"频率成份1\", min: 0, max: 2, dataList: [0, 0.2] &#125;, &#123; name: \"频率成份2\", min: 0, max: 2, dataList: [0, 0.2] &#125;]&#125;pdcharts.draw(targetEl, &#123; engine: echarts, type: chartType.amplitude, data: chartBody, width: 360, height: 320&#125;); &emsp;&emsp;注:当调整targetEl的宽度或者高度，图谱会进行自适应（prpsd图谱除外）。 &gt; updateOption(chart, opts)考虑到默认的图谱配置项有可能无法满足具体业务需求，提供updateOption()对图谱进行个性化的设计。其中opts需要满足Echarts提供配置项结构。 123456789101112var chart=pdcharts.draw(targetEl, &#123; engine: echarts, type: chartType.amplitude, data: chartBody, width: 360, height: 320&#125;);pdcharts.updateOption(chart,&#123; title:&#123; text:'自定义标头' &#125;,&#125;) &emsp;&emsp;注:prpsd图谱除外。 数据结构说明 幅值(amplitude)图谱数据结构 title：图谱标头 axisInfo：坐标信息 axisInfo.valDesc：测量值描述 axisInfo.valColor：测量值对应颜色，默认值：#1BA261 axisInfo.bgValDesc：背景值描述 axisInfo.bgColor：背景值对应颜色，默认值：#DD5044 axisInfo.unit：单位，默认值：mV axisInfo.frequecy：电网频率，默认值：50 series：系列列表，包括有效值、周期最大值、频率成份1、频率成份2 series.name：系列名称，例如：有效值 series.min：系列最小值 series.max：系列最大值 series.dataList：[背景值,测量值] 12345678910111213141516chartBody: &#123; title: '', axisInfo: &#123; valDesc: '', valColor: '#1BA261', bgValDesc: '', bgColor: '#DD5044', unit: 'mV', frequecy: 50 &#125;, series: [&#123; name: '', min: 0, max: 0, dataList: [0, 0] &#125;,……] 图列： 时域波形(wave)图谱数据结构 title：图谱标头 axisInfo：坐标信息 axisInfo.xDesc：X轴描述，周期 axisInfo.xRangeMax：X轴范围，最大值 axisInfo.xRangeMin：X轴范围，最小值 axisInfo.xUnit：X轴单位，默认值：T axisInfo.yDesc：Y轴描述，幅值 axisInfo.yRangeMax：Y轴范围，最大值 axisInfo.yRangeMin：Y轴范围，最小值 axisInfo.yUnit：Y轴单位，默认值：mV trigger：触发线 trigger.desc：触发值描述 trigger.value：触发值 trigger.color：触发线颜色，默认值：#ff00ff series：系列列表 series.color：波形线颜色，默认值：_#ff0000 series.dataList：[[周期值,幅值],……] 12345678910111213141516171819202122chartBody: &#123; title: '', axisInfo: &#123; xDesc: '', xRangeMax: 0, xRangeMin: 0, xUnit: 'T', yDesc: '', yRangeMax: 0, yRangeMin: 0, yUnit: 'mV', &#125;, trigger: &#123; desc: '', value: 0, color: '#ff00ff' &#125;, series: [&#123; color: '#ff0000', dataList: [[0,0],……], &#125;]&#125; 图列： 相位(phase)图谱数据结构 title：图谱标头 axisInfo：坐标信息 axisInfo.xDesc：X轴描述，相位 axisInfo.xRangeMax：X轴范围，默认值：360 axisInfo.xRangeMin：X轴范围，默认值：0 axisInfo.xUnit：X轴单位，默认值：° axisInfo.yDesc：Y轴描述，幅值 axisInfo.yRangeMax：Y轴范围，最大值 axisInfo.yRangeMin：Y轴范围，最小值 axisInfo.yUnit：Y轴单位，默认值：mV axisInfo.zDesc：Z轴描述，脉冲个数 axisInfo.zRangeMax：Z轴范围，默认值：64 axisInfo.zRangeMin：Z轴范围，默认值：0 axisInfo.zUnit：Y轴单位，默认值：空 trigger：触发线 trigger.desc：触发值描述 trigger.value：触发值 trigger.color：触发线颜色，默认值：#ff00ff series：系列列表 series.color：数据点颜色系，如果不配置或者值为空，数据点颜色则按照数据集合中的颜色显示，默认值：tlb series.dataList：[[相位值,幅值,脉冲个数,数据点颜色],……]，其中数据点颜色可选 1234567891011121314151617181920212223242526chartBody: &#123; title: '', axisInfo: &#123; xDesc: '', xRangeMax: 360, xRangeMin: 0, xUnit: '°', yDesc: '', yRangeMax: 0, yRangeMin: 0, yUnit: 'mV', zDesc: '', zRangeMax: 64, zRangeMin: 0, zUnit: '', &#125;, trigger: &#123; desc: '', value: 0, color: '#ff00ff' &#125;, series: [&#123; colors: 'tlb', dataList: [[0,0,0,'#ff0000'],……], &#125;]&#125; 图列： 飞行(fly)图谱数据结构 title：图谱标头 axisInfo：坐标信息 axisInfo.xDesc：X轴描述，时间间隔 axisInfo.xRangeMax：X轴范围，最大值 axisInfo.xRangeMin：X轴范围，最小值 axisInfo.xUnit：X轴单位，默认值：ms axisInfo.yDesc：Y轴描述，幅值 axisInfo.yRangeMax：Y轴范围，最大值 axisInfo.yRangeMin：Y轴范围，最小值 axisInfo.yUnit：Y轴单位，默认值：mV axisInfo.zDesc：Z轴描述，脉冲个数 axisInfo.zRangeMax：Z轴范围，默认值：64 axisInfo.zRangeMin：Z轴范围，默认值：0 axisInfo.zUnit：Y轴单位，默认值：空 trigger：触发线 trigger.desc：触发值描述 trigger.value：触发值 trigger.color：触发线颜色，默认值：#ff00ff series：系列列表 series.color：数据点颜色系，如果不配置或者值为空，数据点颜色则按照数据集合中的颜色显示，默认值：tlb series.dataList：[[时间间隔,幅值,脉冲个数,数据点颜色],……]，其中数据点颜色可选 1234567891011121314151617181920212223242526chartBody: &#123; title: '', axisInfo: &#123; xDesc: '', xRangeMax: 360, xRangeMin: 0, xUnit: '°', yDesc: '', yRangeMax: 0, yRangeMin: 0, yUnit: 'mV', zDesc: '', zRangeMax: 64, zRangeMin: 0, zUnit: '', &#125;, trigger: &#123; desc: '', value: 0, color: '#ff00ff' &#125;, series: [&#123; colors: 'blaze', dataList: [[0,0,0,'#ff0000'],……], &#125;]&#125; 图列： PRPS图谱数据结构 title：图谱标头 axisInfo：坐标信息 axisInfo.xDesc：X轴描述，相位 axisInfo.xRangeMax：X轴范围，默认值：360 axisInfo.xRangeMin：X轴范围，默认值：0 axisInfo.xUnit：X轴单位，默认值：° axisInfo.yDesc：Y轴描述，周期 axisInfo.yRangeMax：Y轴范围，默认值：50 axisInfo.yRangeMin：Y轴范围，默认值：0 axisInfo.yUnit：Y轴单位，默认值：T axisInfo.zDesc：Z轴描述，幅值 axisInfo.zRangeMax：Z轴范围，最大值 axisInfo.zRangeMin：Z轴范围，最小值 axisInfo.zUnit：Y轴单位，默认值：mV axisInfo.phaseShift：相位偏移值，默认值：xRangeMin axisInfo.zRange：Z轴显示范围，默认值：[zRangeMin, zRangeMax] series：系列列表 series.color：数据点颜色系，如果不配置或者值为空，数据点颜色则按照数据集合中的颜色显示，默认值：blaze series.dataList：[[时间间隔,幅值,脉冲个数,数据点颜色],……]，其中数据点颜色可选 1234567891011121314151617181920212223chartBody: &#123; title: '', axisInfo: &#123; xDesc: '', xRangeMax: 360, xRangeMin: 0, xUnit: '°', yDesc: '', yRangeMax: 50, yRangeMin: 0, yUnit: 'T', zDesc: '', zRangeMax: 64, zRangeMin: 0, zUnit: 'mV', phaseShift: 0, zRange: [0, 64] &#125;, series: [&#123; colors: 'blaze', dataList: [[0,0,0],……], &#125;]&#125; 图列： PRPSD图谱适用浏览器无法展示展示三维图谱时替代，即可用于PRPS三维图也可用于PRPD三维图。 PRPD图谱数据结构 title：图谱标头 axisInfo：坐标信息 axisInfo.xDesc：X轴描述，相位 axisInfo.xRangeMax：X轴范围，默认值：360 axisInfo.xRangeMin：X轴范围，默认值：0 axisInfo.xUnit：X轴单位，默认值：° axisInfo.yDesc：Y轴描述，幅值 axisInfo.yRangeMax：Y轴范围，最大值 axisInfo.yRangeMin：Y轴范围，最小值 axisInfo.yUnit：Y轴单位，默认值：mV axisInfo.zDesc：Z轴描述，脉冲个数 axisInfo.zRangeMax：Z轴范围，默认值：100 axisInfo.zRangeMin：Z轴范围，默认值：0 axisInfo.zUnit：Y轴单位，默认值：空 series：系列列表 series.color：数据点颜色系，如果不配置或者值为空，数据点颜色则按照数据集合中的颜色显示，默认值：blaze series.dataList：[[时间间隔,幅值,脉冲个数,数据点颜色],……]，其中数据点颜色可选 123456789101112131415161718192021chartBody: &#123; title: '', axisInfo: &#123; xDesc: '', xRangeMax: 0, xRangeMin: 0, xUnit: '°', yDesc: '', yRangeMax: 0, yRangeMin: 0, yUnit: 'mV', zDesc: '', zRangeMax: 100, zRangeMin: 0, zUnit: '', &#125;, series: [&#123; colors: 'blaze', dataList: [[0,0,0],……], &#125;]&#125; 图列： 铁芯接地电流(earthcurrent)图谱数据结构 title：图谱标头 axisInfo：坐标信息 axisInfo.desc：描述，电流值 axisInfo.rangeMax：电流值最大值 axisInfo.rangeMin：电流值最小值 axisInfo.unit：单位，默认值：mA axisInfo.nomalMax：正常值，默认值：100 axisInfo.nomalColor：正常颜色，默认值：#1BA261 axisInfo.warningMax：预警值，默认值：300 axisInfo.warningColor：预警颜色，默认值：#FCAB53 axisInfo.alarmMax：报警值，默认值：500 axisInfo.alarmColor：报警颜色，默认值：#DD5044 axisInfo.value：测量值 12345678910111213141516chartBody: &#123; title: '', axisInfo: &#123; desc: '', rangeMax: 500, rangeMin: 0, unit: 'mA', nomalMax: 100, nomalColor: '#1BA261', warningMax: 300, warningColor: '#FCAB53', alarmMax: 500, alarmColor: '#DD5044', value:0 &#125;&#125; 图列： 红外温度矩阵(infrared)图谱数据结构 title：图谱标头 axisInfo：坐标信息 axisInfo.desc：描述，温度值 axisInfo.widht：图像宽度，默认值：360 axisInfo.height：图像高度，默认值：256 axisInfo.rangeMax：温度最大值 axisInfo.rangeMin：温度最小值 axisInfo.unit：温度单位，默认值：℃ series：系列列表 series.color：点/线颜色，默认值：iron series.dataList：[[高度坐标,宽度坐标,温度值],……] 123456789101112131415chartBody: &#123; title: '', axisInfo: &#123; desc: '', widht: 360, height: 256, rangeMax: 0, rangeMin: 0, unit: '℃', &#125;, series: [&#123; colors: 'iron', dataList: [[0,0,0],……], &#125;]&#125; 图列： 机械特性(mech)图谱数据结构 适用电机电流曲线、原始电流曲线、线圈电流曲线、扭矩曲线、振动信号曲线、振动频率信号曲线、行程曲线 title：图谱标头 axisInfo：坐标信息 axisInfo.xDesc：X轴描述，不同曲线不同 axisInfo.xRangeMax：X轴最大值 axisInfo.xRangeMin：X轴最小值 axisInfo.xUnit：单位 axisInfo.yDesc：Y轴描述 axisInfo.yUnit：Y轴单位 axisInfo.pointNum：数据点数 series：系列列表 series.name：系列名称，例如：A相、X轴等 series.color：点/线颜色，默认值：#1BA261 series.dataList：[对应曲线值,……] 1234567891011121314151617chartBody: &#123; title: '', axisInfo: &#123; xDesc: '', xRangeMax: 0, xRangeMin: 0, xUnit: 's', yDesc: '', yUnit: 'A', pointNum: 0, &#125;, series: [&#123; name: 'A', color: '#1BA261', dataList: [0,……] &#125;,……],&#125; 图列： 开关量(switches)曲线数据结构 title：图谱标头 axisInfo：坐标信息 axisInfo.xDesc：X轴描述，时间 axisInfo.xRangeMax：X轴最大值 axisInfo.xRangeMin：X轴最小值 axisInfo.xUnit：单位 axisInfo.yDesc：Y轴描述 axisInfo.yUnit：Y轴单位 axisInfo.pointNum：数据点数 axisInfo.valDesc：开关状态 axisInfo.valDesc.on：开状态描述 axisInfo.valDesc.off：关状态描述 series：系列列表 series.name：系列名称，例如：A相等 series.color：点/线颜色，默认值：#1BA261 series.dataList：[开关状态量,……] 123456789101112131415161718192021chartBody: &#123; title: '', axisInfo: &#123; xDesc: '', xRangeMax: 0, xRangeMin: 0, xUnit: 'ms', yDesc: '', yUnit: '', pointNum: 0, valDesc: &#123; on: '', off: '' &#125; &#125;, series: [&#123; name: 'A', color: '#1BA261', dataList: [0,……] &#125;,……],&#125; 图列： 周期图谱(cycle)数据结构 title：图谱标头 axisInfo：坐标信息 axisInfo.xDesc：X轴描述，相位 axisInfo.xRangeMax：X轴最大值 axisInfo.xRangeMin：X轴最小值 axisInfo.xUnit：X轴单位 axisInfo.yDesc：Y轴描述，幅值 axisInfo.yRangeMax：Y轴最大值 axisInfo.yRangeMin：Y轴最小值 axisInfo.yUnit：Y轴单位 trigger：触发线 trigger.desc：触发值描述 trigger.value：触发值，对应状态的最大值 trigger.color：触发线颜色，默认值：#ff00ff series：系列列表 series.name：系列名称，例如：正常 series.color：点/线颜色，默认值：#008000 series.dataList：[[相位值,幅值],……] 12345678910111213141516171819202122232425let init = &#123; title: '', axisInfo: &#123; xDesc: '', xRangeMax: 0, xRangeMin: 0, xUnit: '°', yDesc: '', yRangeMax: 0, yRangeMin: 0, yUnit: 'dB', yMaxValue: 0, yMaxColor: '#ff00ff' &#125;, trigger: [&#123; desc: '', value: 0, color: '#008000' &#125;], series: [&#123; name:'', color:'' dataList: [[0, 0],……], &#125;]&#125;; 图列：","categories":[{"name":"业务相关","slug":"业务相关","permalink":"http://www.whoosh.site/categories/业务相关/"}],"tags":[{"name":"PDCharts","slug":"PDCharts","permalink":"http://www.whoosh.site/tags/PDCharts/"},{"name":"ECharts","slug":"ECharts","permalink":"http://www.whoosh.site/tags/ECharts/"}]},{"title":"高效能人士的七个习惯","slug":"20180315_高效能人士的七个习惯","date":"2018-03-15T13:13:58.000Z","updated":"2018-06-20T15:11:14.995Z","comments":true,"path":"2018/03/15/20180315_高效能人士的七个习惯/","link":"","permalink":"http://www.whoosh.site/2018/03/15/20180315_高效能人士的七个习惯/","excerpt":"","text":"前言 2018-01-13 我就是我生命的创造力 要完成最渴望的目标，战胜最艰巨的挑战，必须发掘并应用一些原则或自然法则（套路）。任何努力的成功，都离不开恰到好处并游刃有余地应用这些原则。 人类面临最普遍的集中挑战：恐惧感和不安全感、我现在就想得到、谴责和抱怨、绝望无助、缺乏人生平衡、我的定位在哪儿、渴望被理解、冲突和分歧、个人的停滞不前 犬儒主义：源于古希腊犬儒学派学者主张的哲学思潮(创始人：安提斯泰尼，集大成者：第欧根尼)，该派的本意是指人不应被一切世俗的事物，包括宗教、礼节、惯常的衣食住行方面等习俗束缚，提倡对道德的无限追求，同时过着极简朴而非物质的生活。现代的犬儒主义演变成了虚无主义、愤世嫉俗、玩世不恭。 重新探索自我 皮格马利翁效应（Pygmalion Effect, 又称比马龙效应）指人们基于对某种情境的知觉而形成的期望或预言，会使该情境产生适应这一期望或预言的效应。 个人领域的成功：从依赖到独立1. 积极主动：个人愿景2. 以终为始：自我领导3. 要事第一：自我管理公众领域的成功：从独立到互赖4. 双赢思维：人际领导5. 知己解彼：移情沟通6. 统合综效：创造性合作自我提升和改善7. 不断更新：平衡的自我更新","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://www.whoosh.site/categories/读书笔记/"}],"tags":[{"name":"管理类书籍","slug":"管理类书籍","permalink":"http://www.whoosh.site/tags/管理类书籍/"}]},{"title":"普吉蜜月旅行","slug":"20180311_普吉蜜月旅行","date":"2018-03-11T13:13:58.000Z","updated":"2018-03-11T15:16:20.046Z","comments":true,"path":"2018/03/11/20180311_普吉蜜月旅行/","link":"","permalink":"http://www.whoosh.site/2018/03/11/20180311_普吉蜜月旅行/","excerpt":"","text":"出发前准备蜜月旅行之所以选择去泰国，主要考虑到这是一次意义非凡的旅行，不想把婚假白白浪费在国内，还有就是安全因素了，毕竟第一次出国，没有经验，就选了个近的，而且跟了团（胆子小嘛）。 虽说跟团出行，但是出发前还是要准备一些东西的： 护照：出国必备品，在公安局出入境大厅办理，携带身份证、户口本原件，2寸照即可办理，工本费200。 签证：也是必备品，可以自己去大使馆办理、找旅行社办理、也可以落地签（看目的地是否可以），我们本来想自己办理，结果需要提供一堆的证明，懒得弄就选择了落地签了。 泰铢：泰国要求游客每人必须携带20000泰铢或等值人民币，可以去银行换一些小额的泰铢，例如20、50、100，因为泰国是一个小费国家，经常要用到。 电话卡：专为游客设计的happy卡，在泰国激活后可用8天，2.5G高速流量，100分钟通话时长，但是打电话必须要在号码前要加0040086，基本上这些足够用了，反正我的没有用完。 夏装：普吉岛没有最热只有更热，一定要带上夏装过去，例如拖鞋、大裤衩、防晒品之类的，当然这些在本地也能买到，价格嘛肯定要贵点的。 泰国是一个非常适合养老的地方，不仅当地人生活节奏非常慢，猫狗也都非常的慵懒，见到它们肥嘟嘟的躺在地上晒太阳，相当的闲适了，可惜没有留下照片。 欢乐时光 总结这是一次非常开心的旅行，见识到不一样的世界，遇到不一样的人。生活在不停的忙碌后需要一段时间来调节下，然后继续追逐着梦想，不禁感慨，活着真好。","categories":[{"name":"游记","slug":"游记","permalink":"http://www.whoosh.site/categories/游记/"}],"tags":[{"name":"旅行","slug":"旅行","permalink":"http://www.whoosh.site/tags/旅行/"}]},{"title":"Canvas的基本用法","slug":"20170702_Canvas的基本用法","date":"2017-07-02T14:13:58.000Z","updated":"2018-03-20T14:38:33.564Z","comments":true,"path":"2017/07/02/20170702_Canvas的基本用法/","link":"","permalink":"http://www.whoosh.site/2017/07/02/20170702_Canvas的基本用法/","excerpt":"","text":"浏览器支持表格中的数字表示支持 &lt;canvas&gt; 元素的第一个浏览器版本号。 元素 &lt;canvas&gt; 4.0 9.0 2.0 3.1 9.0 属性和方法 属性 名称 描述 颜色 fillStyle 设置或返回用于填充绘画的颜色、渐变或模式 strokeStyle 设置或返回用于笔触的颜色、渐变或模式 阴影 shadowColor 设置或返回用于阴影的颜色 shadowBlur 设置或返回用于阴影的模糊级别 shadowOffsetX 设置或返回阴影距形状的水平距离 shadowOffsetY 设置或返回阴影距形状的垂直距离 线条样式 lineCap 设置或返回线条的结束端点样式 lineJoin 设置或返回两条线相交时，所创建的拐角类型 lineWidth 设置或返回当前的线条宽度 miterLimit 设置或返回最大斜接长度 文本 font 设置或返回文本内容的当前字体属性 textAlign 设置或返回文本内容的当前对齐方式 textBaseline 设置或返回在绘制文本时使用的当前文本基线 像素 width 返回 ImageData 对象的宽度 height 返回 ImageData 对象的高度 data 返回一个对象，其包含指定的 ImageData 对象的图像数据 图像合成 globalAlpha 设置或返回绘图的当前 alpha 或透明值 globalCompositeOperation 设置或返回新图像如何绘制到已有的图像上 方法 名称 描述 样式 createLinearGradient() 创建线性渐变（用在画布内容上） createPattern() 在指定的方向上重复指定的元素 createRadialGradient() 创建放射状/环形的渐变（用在画布内容上） addColorStop() 规定渐变对象中的颜色和停止位置 矩形 rect() 创建矩形 fillRect() 绘制“被填充”的矩形 strokeRect() 绘制矩形（无填充） clearRect() 在给定的矩形内清除指定的像素 路径 fill() 填充当前绘图（路径） stroke() 绘制已定义的路径 beginPath() 起始一条路径，或重置当前路径 closePath() 创建从当前点回到起始点的路径 moveTo() 把路径移动到画布中的指定点，不创建线条 lineTo() 添加一个新点，然后在画布中创建从该点到最后指定点的线条 clip() 从原始画布剪切任意形状和尺寸的区域 quadraticCurveTo() 创建二次贝塞尔曲线 bezierCurveTo() 创建三次方贝塞尔曲线 arc() 创建弧/曲线（用于创建圆形或部分圆） arcTo() 创建两切线之间的弧/曲线 isPointInPath() 如果指定的点位于当前路径中，则返回 true，否则返回 false 转换 scale() 缩放当前绘图至更大或更小 rotate() 旋转当前绘图 translate() 重新映射画布上的 (0,0) 位置 transform() 替换绘图的当前转换矩阵 setTransform() 将当前转换重置为单位矩阵。然后运行 transform() 文本 fillText() 在画布上绘制“被填充的”文本 strokeText() 在画布上绘制文本（无填充） measureText() 返回包含指定文本宽度的对象 像素 createImageData() 创建新的、空白的 ImageData 对象 getImageData() 返回 ImageData 对象，该对象为画布上指定的矩形复制像素数据 putImageData() 把图像数据（从指定的 ImageData 对象）放回画布上 图像绘制 drawImage() 向画布上绘制图像、画布或视频 其他 save() 保存当前环境的状态 restore() 返回之前保存过的路径状态和属性 getContext() 返回一个用于在画布上绘图的环境 toDataURL() 获取画布的Base64字符串 toBlob() 获取画布的二进制数据 fillStylecontext.fillStyle=color|gradient|pattern; color 指示绘图填充色的 CSS 颜色值。默认值是 #000000。 gradient 用于填充绘图的渐变对象（线性或放射性） pattern 用于填充绘图的 pattern 对象 实例11234var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.fillStyle=\"#0000ff\";ctx.fillRect(20,20,150,100); 实例21234567var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");var my_gradient=ctx.createLinearGradient(0,0,0,170);my_gradient.addColorStop(0,\"black\");my_gradient.addColorStop(1,\"white\");ctx.fillStyle=my_gradient;ctx.fillRect(20,20,150,100); 实例3123456789var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.clearRect(0,0,c.width,c.height); var img=document.getElementById(\"lamp\")//direction=repeat|repeat-x|repeat-y|no-repeatvar pat=ctx.createPattern(img,'repeat');ctx.rect(0,0,300,150);ctx.fillStyle=pat;ctx.fill(); strokeStylecontext.strokeStyle=color|gradient|pattern; color 指示绘图笔触颜色的 CSS 颜色值。默认值是 #000000。 gradient 用于填充绘图的渐变对象（线性或放射性） pattern 用于创建 pattern 笔触的 pattern 对象 实例11234var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.strokeStyle=\"#0000ff\";ctx.strokeRect(20,20,150,100); 实例212345678910var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");var gradient=ctx.createLinearGradient(0,0,170,0);gradient.addColorStop(\"0\",\"magenta\");gradient.addColorStop(\"0.5\",\"blue\");gradient.addColorStop(\"1.0\",\"red\");// 用渐变进行填充ctx.strokeStyle=gradient;ctx.lineWidth=5;ctx.strokeRect(20,20,150,100); shadowColorcontext.shadowColor=color; color 用于阴影的 CSS 颜色值。默认值是 #000000。 实例1123456var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.shadowBlur=20;ctx.shadowColor=\"black\";ctx.fillStyle=\"blue\";ctx.fillRect(20,20,100,80); shadowBlurcontext.shadowBlur=number; number 阴影的模糊级数 实例1123456var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.shadowBlur=200;ctx.shadowColor=\"red\";ctx.fillStyle=\"blue\";ctx.fillRect(20,20,100,80); shadowOffsetXcontext.shadowOffsetX=number; number 正值（右侧）或负值（左侧），定义阴影与形状的水平距离。 实例11234567var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.shadowBlur=10;ctx.shadowOffsetX=20;ctx.shadowColor=\"black\";ctx.fillStyle=\"blue\";ctx.fillRect(20,20,100,80); shadowOffsetYcontext.shadowOffsetY=number; number 正值（右侧）或负值（左侧），定义阴影与形状的垂直距离。 实例11234567var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.shadowBlur=10;ctx.shadowOffsetY=20;ctx.shadowColor=\"black\";ctx.fillStyle=\"blue\";ctx.fillRect(20,20,100,80); lineCapcontext.lineCap=”butt|round|square”; butt 默认。向线条的每个末端添加平直的边缘。 round 向线条的每个末端添加圆形线帽。 square 向线条的每个末端添加正方形线帽。 实例11234567var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.beginPath();ctx.lineCap=\"round\";ctx.moveTo(20,20);ctx.lineTo(20,200);ctx.stroke(); lineJoincontext.lineJoin=”bevel|round|miter”; bevel 创建斜角。 round 创建圆角。 miter 创建尖角。默认值。 实例112345678var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.beginPath();ctx.lineJoin=\"round\";ctx.moveTo(20,20);ctx.lineTo(100,50);ctx.lineTo(20,100);ctx.stroke(); lineWidthcontext.lineWidth=number; number 当前线条的宽度，以像素计，默认值1。 实例11234var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.lineWidth=10;ctx.strokeRect(20,20,80,100); miterLimitcontext.miterLimit=number; number 正数。规定最大斜接长度。只有当 lineJoin 属性为 “miter” 时，miterLimit 才有效。如果斜接长度超过 miterLimit 的值，边角会以 lineJoin 的 “bevel” 类型来显示。 实例1123456789var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.lineWidth=10;ctx.lineJoin=\"miter\";ctx.miterLimit=5;ctx.moveTo(20,20);ctx.lineTo(50,27);ctx.lineTo(20,34);ctx.stroke(); fontcontext.font=”italic small-caps bold 12px arial”; font-style 规定字体样式。可能的值：normal、italic、oblique。 font-variant 规定字体变体。可能的值：normal、small-caps。 font-weight 规定字体的粗细。可能的值：normal、bold、bolder、lighter、100、200、300、400、500、600、700、800、900。 font-size 规定字号，以像素计。 line-height 规定行高，以像素计。 font-family 规定字体系列。 caption 使用标题控件的字体（比如按钮、下拉列表等）。 icon 使用用于标记图标的字体。 menu 使用用于菜单中的字体（下拉列表和菜单列表）。 message-box 使用用于对话框中的字体。 small-caption 使用用于标记小型控件的字体。 status-bar 使用用于窗口状态栏中的字体。 实例11234var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.font=\"40px Arial\";ctx.fillText(\"Hello World\",10,50); textAligncontext.textAlign=”center|end|left|right|start”; start 默认。文本在指定的位置开始。 end 文本在指定的位置结束。 center 文本的中心被放置在指定的位置。 left 文本左对齐。 right 文本右对齐。 实例112345678910111213141516171819202122var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");// 在位置 150 创建蓝线ctx.strokeStyle=\"blue\";ctx.moveTo(150,20);ctx.lineTo(150,170);ctx.stroke();ctx.font=\"15px Arial\";// 显示不同的 textAlign 值ctx.textAlign=\"start\";ctx.fillText(\"textAlign=start\",150,60);ctx.textAlign=\"end\";ctx.fillText(\"textAlign=end\",150,80);ctx.textAlign=\"left\";ctx.fillText(\"textAlign=left\",150,100);ctx.textAlign=\"center\";ctx.fillText(\"textAlign=center\",150,120);ctx.textAlign=\"right\";ctx.fillText(\"textAlign=right\",150,140); textBaselinecontext.textBaseline=”alphabetic|top|hanging|middle|ideographic|bottom”; alphabetic 默认。文本基线是普通的字母基线。 top 文本基线是 em 方框的顶端。。 hanging 文本基线是悬挂基线。 middle 文本基线是 em 方框的正中。 ideographic 文本基线是表意基线。 bottom 文本基线是 em 方框的底端。 实例112345678910111213141516171819202122var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");//在位置 y=100 绘制蓝色线条ctx.strokeStyle=\"blue\";ctx.moveTo(5,100);ctx.lineTo(395,100);ctx.stroke();ctx.font=\"20px Arial\"//在 y=200 以不同的 textBaseline 值放置每个单词ctx.textBaseline=\"top\";ctx.fillText(\"Top\",5,100);ctx.textBaseline=\"bottom\";ctx.fillText(\"Bottom\",50,100);ctx.textBaseline=\"middle\";ctx.fillText(\"Middle\",120,100);ctx.textBaseline=\"alphabetic\";ctx.fillText(\"Alphabetic\",190,100);ctx.textBaseline=\"hanging\";ctx.fillText(\"Hanging\",290,100); widthimgData.width; width 属性返回 ImageData 对象的宽度，以像素计。 实例11alert(\"Width of imgData is: \" + imgData.width); heightimgData.height; height 属性返回 ImageData 对象的高度，以像素计。 实例11alert(\"Width of imgData is: \" + imgData.height); dataimageData.data; 对于 ImageData 对象中的每个像素，都存在着四方面的信息，即 RGBA 值：R - 红色 (0-255)G - 绿色 (0-255)B - 蓝色 (0-255)A - alpha 通道 (0-255; 0 是透明的，255 是完全可见的)color/alpha 以数组形式存在，并存储于 ImageData 对象的 data 属性中。 实例11234567891011var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");var imgData=ctx.createImageData(100,100);for (var i=0;i&lt;imgData.data.length;i+=4) &#123; imgData.data[i+0]=255; imgData.data[i+1]=0; imgData.data[i+2]=0; imgData.data[i+3]=255; &#125;ctx.putImageData(imgData,10,10); globalAlphacontext.globalAlpha=number; number 透明值。必须介于 0.0（完全透明） 与 1.0（不透明） 之间。 实例112345678910var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.fillStyle=\"red\";ctx.fillRect(20,20,75,50);// 调节透明度ctx.globalAlpha=0.2;ctx.fillStyle=\"blue\";ctx.fillRect(50,50,75,50);ctx.fillStyle=\"green\";ctx.fillRect(80,80,75,50); globalCompositeOperationcontext.globalCompositeOperation=”source-over”; source-over 默认。在目标图像上显示源图像。 source-atop 在目标图像顶部显示源图像。源图像位于目标图像之外的部分是不可见的。 source-in 在目标图像中显示源图像。只有目标图像内的源图像部分会显示，目标图像是透明的。 source-out 在目标图像之外显示源图像。只会显示目标图像之外源图像部分，目标图像是透明的。 destination-over 在源图像上方显示目标图像。 destination-atop 在源图像顶部显示目标图像。源图像之外的目标图像部分不会被显示。 destination-in 在源图像中显示目标图像。只有源图像内的目标图像部分会被显示，源图像是透明的。 destination-out 在源图像外显示目标图像。只有源图像外的目标图像部分会被显示，源图像是透明的。 lighter 显示源图像 + 目标图像。 copy 显示源图像。忽略目标图像。 xor 使用异或操作对源图像与目标图像进行组合。 实例11234567891011121314var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.fillStyle=\"red\";ctx.fillRect(20,20,75,50);ctx.globalCompositeOperation=\"source-over\";ctx.fillStyle=\"blue\";ctx.fillRect(50,50,75,50);ctx.fillStyle=\"red\";ctx.fillRect(150,20,75,50);ctx.globalCompositeOperation=\"destination-over\";ctx.fillStyle=\"blue\";ctx.fillRect(180,50,75,50); createLinearGradient()context.createLinearGradient(x0,y0,x1,y1); x0 渐变开始点的 x 坐标 y0 渐变开始点的 y 坐标 x1 渐变结束点的 x 坐标 y1 渐变结束点的 y 坐标 实例1123456789var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");var grd=ctx.createLinearGradient(0,0,170,0);grd.addColorStop(0,\"black\");grd.addColorStop(1,\"white\");ctx.fillStyle=grd;ctx.fillRect(20,20,150,100); createPattern()context.createPattern(image,”repeat|repeat-x|repeat-y|no-repeat”); image 规定要使用的图片、画布或视频元素。 repeat 默认。该模式在水平和垂直方向重复。 repeat-x 该模式只在水平方向重复。 repeat-y 该模式只在垂直方向重复。 no-repeat 该模式只显示一次（不重复）。 实例112345678var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.clearRect(0,0,c.width,c.height); var img=document.getElementById(\"lamp\")var pat=ctx.createPattern(img,'repeat');ctx.rect(0,0,300,150);ctx.fillStyle=pat;ctx.fill(); createRadialGradient()context.createRadialGradient(x0,y0,r0,x1,y1,r1); x0 渐变的开始圆的 x 坐标 y0 渐变的开始圆的 y 坐标 r0 开始圆的半径 x1 渐变的结束圆的 x 坐标 y1 渐变的结束圆的 y 坐标 r1 结束圆的半径 实例112345678910var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");var grd=ctx.createRadialGradient(75,50,5,90,60,100);grd.addColorStop(0,\"red\");grd.addColorStop(1,\"white\");// Fill with gradientctx.fillStyle=grd;ctx.fillRect(10,10,150,100); addColorStop()gradient.addColorStop(stop,color); stop 介于 0.0 与 1.0 之间的值，表示渐变中开始与结束之间的位置。 color 在结束位置显示的 CSS 颜色值 实例112345678910111213var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");var grd=ctx.createLinearGradient(0,0,170,0);grd.addColorStop(0,\"black\");grd.addColorStop(\"0.3\",\"magenta\");grd.addColorStop(\"0.5\",\"blue\");grd.addColorStop(\"0.6\",\"green\");grd.addColorStop(\"0.8\",\"yellow\");grd.addColorStop(1,\"red\");ctx.fillStyle=grd;ctx.fillRect(20,20,150,100); rect()context.rect(x,y,width,height); x 矩形左上角的 x 坐标 y 矩形左上角的 y 坐标 width 矩形的宽度，以像素计 height 矩形的高度，以像素计 实例11234567891011121314151617181920212223var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");// 红色矩形ctx.beginPath();ctx.lineWidth=\"6\";ctx.strokeStyle=\"red\";ctx.rect(5,5,290,140);ctx.stroke();// 绿色矩形ctx.beginPath();ctx.lineWidth=\"4\";ctx.strokeStyle=\"green\";ctx.rect(30,30,50,50);ctx.stroke();// 蓝色矩形ctx.beginPath();ctx.lineWidth=\"10\";ctx.strokeStyle=\"blue\";ctx.rect(50,50,150,80);ctx.stroke(); fillRect()context.fillRect(x,y,width,height); x 矩形左上角的 x 坐标 y 矩形左上角的 y 坐标 width 矩形的宽度，以像素计 height 矩形的高度，以像素计 实例1123var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.fillRect(20,20,150,100); strokeRect()context.strokeRect(x,y,width,height); x 矩形左上角的 x 坐标 y 矩形左上角的 y 坐标 width 矩形的宽度，以像素计 height 矩形的高度，以像素计 实例1123var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.strokeRect(20,20,150,100); clearRect()context.clearRect(x,y,width,height); x 要清除的矩形左上角的 x 坐标 y 要清除的矩形左上角的 y 坐标 width 要清除的矩形的宽度，以像素计 height 要清除的矩形的高度，以像素计 实例112345var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.fillStyle=\"red\";ctx.fillRect(0,0,300,150);ctx.clearRect(20,20,100,50); fill()context.fill(); 如果路径未关闭，那么 fill() 方法会从路径结束点到开始点之间添加一条线，以关闭该路径，然后填充该路径 实例112345var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.rect(20,20,150,100);ctx.fillStyle=\"green\";ctx.fill(); stroke()context.stroke(); 会实际地绘制出通过 moveTo() 和 lineTo() 方法定义的路径。默认颜色是黑色 实例112345678var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.beginPath();ctx.moveTo(20,20);ctx.lineTo(20,100);ctx.lineTo(70,100);ctx.strokeStyle=\"green\";ctx.stroke(); beginPath()context.beginPath(); 开始一条路径，或重置当前的路径 实例1123456789101112131415var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.beginPath();ctx.lineWidth=\"5\";ctx.strokeStyle=\"red\"; // 红色路径ctx.moveTo(0,75);ctx.lineTo(250,75);ctx.stroke(); // 进行绘制ctx.beginPath();ctx.strokeStyle=\"blue\"; // 蓝色路径ctx.moveTo(50,0);ctx.lineTo(150,130);ctx.stroke(); // 进行绘制 closePath()context.closePath(); 创建从当前点到开始点的路径 实例112345678910var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.beginPath();ctx.moveTo(20,20);ctx.lineTo(20,100);ctx.lineTo(70,100);ctx.closePath();ctx.stroke();ctx.fillStyle=\"green\";ctx.fill(); moveTo()context.moveTo(x,y); x 路径的目标位置的 x 坐标 y 路径的目标位置的 y 坐标 实例1123456var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.beginPath();ctx.moveTo(0,0);ctx.lineTo(300,150);ctx.stroke(); lineTo()context.lineTo(x,y); x 路径的目标位置的 x 坐标 y 路径的目标位置的 y 坐标 实例11234567var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.beginPath();ctx.moveTo(20,20);ctx.lineTo(20,100);ctx.lineTo(70,100);ctx.stroke(); clip()context.clip(); 从原始画布中剪切任意形状和尺寸。一旦剪切了某个区域，则所有之后的绘图都会被限制在被剪切的区域内（不能访问画布上的其他区域）。您也可以在使用 clip() 方法前通过使用 save() 方法对当前画布区域进行保存，并在以后的任意时间对其进行恢复（通过 restore() 方法）。 实例1123456789var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");// 剪切矩形区域ctx.rect(50,20,200,120);ctx.stroke();ctx.clip();// 在 clip() 之后绘制绿色矩形ctx.fillStyle=\"green\";ctx.fillRect(0,0,150,100); quadraticCurveTo()context.quadraticCurveTo(cpx,cpy,x,y); cpx 贝塞尔控制点的 x 坐标 cpy 贝塞尔控制点的 y 坐标 x 结束点的 x 坐标 y 结束点的 y 坐标 实例1123456var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.beginPath();ctx.moveTo(20,20);ctx.quadraticCurveTo(20,100,200,20);ctx.stroke(); bezierCurveTo()context.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y); cp1x 第一个贝塞尔控制点的 x 坐标 cp1y 第一个贝塞尔控制点的 y 坐标 cp2x 第二个贝塞尔控制点的 x 坐标 cp2y 第二个贝塞尔控制点的 y 坐标 x 结束点的 x 坐标 y 结束点的 y 坐标 实例1123456var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.beginPath();ctx.moveTo(20,20);ctx.bezierCurveTo(20,100,200,100,200,20);ctx.stroke(); arc()context.arc(x,y,r,sAngle,eAngle,counterclockwise); x 圆的中心的 x 坐标。 y 圆的中心的 y 坐标。 r 圆的半径。 sAngle 起始角，以弧度计。（弧的圆形的三点钟位置是 0 度）。 eAngle 结束角，以弧度计。 counterclockwise 可选。规定应该逆时针还是顺时针绘图。False = 顺时针，true = 逆时针。 实例112345var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.beginPath();ctx.arc(100,75,50,0,2*Math.PI);ctx.stroke(); arcTo()context.fillRect(x1,y1,x2,y2,r); x1 弧的起点的 x 坐标 y1 弧的起点的 y 坐标 x2 弧的终点的 x 坐标 y2 弧的终点的 y 坐标 r 弧的半径 实例1123456789var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.beginPath();ctx.beginPath();ctx.moveTo(20,20); // 创建开始点ctx.lineTo(100,20); // 创建水平线ctx.arcTo(150,20,150,70,50); // 创建弧ctx.lineTo(150,120); // 创建垂直线ctx.stroke(); // 进行绘制 isPointInPath()context.isPointInPath(x,y); x 测试的 x 坐标 y 测试的 y 坐标 实例11234567var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.rect(20,20,150,100);if (ctx.isPointInPath(20,50))&#123; ctx.stroke();&#125;; scale()context.scale(scalewidth,scaleheight); scalewidth 缩放当前绘图的宽度 (1=100%, 0.5=50%, 2=200%, 依次类推) scaleheight 缩放当前绘图的高度 (1=100%, 0.5=50%, 2=200%, etc.) 如果您对绘图进行缩放，所有之后的绘图也会被缩放。定位也会被缩放。 实例1123456789var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.strokeRect(5,5,25,15);ctx.scale(2,2);ctx.strokeRect(5,5,25,15);ctx.scale(2,2);ctx.strokeRect(5,5,25,15);ctx.scale(2,2);ctx.strokeRect(5,5,25,15); rotate()context.rotate(angle); angle 旋转角度，以弧度计。如需将角度转换为弧度，请使用 degrees*Math.PI/180 公式进行计算。 实例11234var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.rotate(20*Math.PI/180);ctx.fillRect(50,20,100,50); translate()context.translate(x,y); x 添加到水平坐标（x）上的值 y 添加到垂直坐标（y）上的值 实例112345var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.fillRect(10,10,100,50);ctx.translate(70,70);ctx.fillRect(10,10,100,50); transform()context.transform(a,b,c,d,e,f); a 水平缩放绘图 b 水平倾斜绘图 c 垂直倾斜绘图 d 垂直缩放绘图 e 水平移动绘图 f 垂直移动绘图 每当您调用 transform() 时，它都会在前一个变换矩阵上构建 实例112345678910111213var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.fillStyle=\"yellow\";ctx.fillRect(0,0,250,100)ctx.transform(1,0.5,-0.5,1,30,10);ctx.fillStyle=\"red\";ctx.fillRect(0,0,250,100);ctx.transform(1,0.5,-0.5,1,30,10);ctx.fillStyle=\"blue\";ctx.fillRect(0,0,250,100); setTransform()context.setTransform(a,b,c,d,e,f); a 水平旋转绘图 b 水平倾斜绘图 c 垂直倾斜绘图 d 垂直缩放绘图 e 水平移动绘图 f 垂直移动绘图 把当前的变换矩阵重置为单位矩阵，然后以相同的参数运行 transform() 实例112345678910111213var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.fillStyle=\"yellow\";ctx.fillRect(0,0,250,100)ctx.setTransform(1,0.5,-0.5,1,30,10);ctx.fillStyle=\"red\";ctx.fillRect(0,0,250,100);ctx.setTransform(1,0.5,-0.5,1,30,10);ctx.fillStyle=\"blue\";ctx.fillRect(0,0,250,100); drawImage()context.drawImage(img,x,y);context.drawImage(img,x,y,width,height);context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height); img 规定要使用的图像、画布或视频。 sx 可选。开始剪切的 x 坐标位置。 sy 可选。开始剪切的 y 坐标位置。 swidth 可选。被剪切图像的宽度。 sheight 可选。被剪切图像的高度。 x 在画布上放置图像的 x 坐标位置。 y 在画布上放置图像的 y 坐标位置。 width 可选。要使用的图像的宽度。（伸展或缩小图像） height 可选。要使用的图像的高度。（伸展或缩小图像） 实例11234var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");var img=document.getElementById(\"tulip\");ctx.drawImage(img,10,10,240,160); 实例21234var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");var img=document.getElementById(\"scream\");ctx.drawImage(img,90,130,90,80,20,20,90,80); 实例312345678910111213var v=document.getElementById(\"video1\");var c=document.getElementById(\"myCanvas\");ctx=c.getContext('2d');v.addEventListener('play',function() &#123; var i=window.setInterval(function() &#123; ctx.drawImage(v,0,0,270,135)&#125;,20); &#125;,false);v.addEventListener('pause',function() &#123; window.clearInterval(i); &#125;,false);v.addEventListener('ended',function() &#123; clearInterval(i); &#125;,false); fillText()context.fillText(text,x,y,maxWidth); text 规定在画布上输出的文本。 x 开始绘制文本的 x 坐标位置（相对于画布）。 y 开始绘制文本的 y 坐标位置（相对于画布）。 maxWidth 可选。允许的最大文本宽度，以像素计。 实例1123456789101112131415var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.font=\"20px Georgia\";ctx.fillText(\"Hello World!\",10,50);ctx.font=\"30px Verdana\";// Create gradientvar gradient=ctx.createLinearGradient(0,0,c.width,0);gradient.addColorStop(\"0\",\"magenta\");gradient.addColorStop(\"0.5\",\"blue\");gradient.addColorStop(\"1.0\",\"red\");// Fill with gradientctx.fillStyle=gradient;ctx.fillText(\"www.whoosh.site\",10,90); strokeText()context.strokeText(text,x,y,maxWidth); text 规定在画布上输出的文本。 x 开始绘制文本的 x 坐标位置（相对于画布）。 y 开始绘制文本的 y 坐标位置（相对于画布）。 maxWidth 可选。允许的最大文本宽度，以像素计。 实例1123456789101112131415var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.font=\"20px Georgia\";ctx.strokeText(\"Hello World!\",10,50);ctx.font=\"30px Verdana\";// Create gradientvar gradient=ctx.createLinearGradient(0,0,c.width,0);gradient.addColorStop(\"0\",\"magenta\");gradient.addColorStop(\"0.5\",\"blue\");gradient.addColorStop(\"1.0\",\"red\");// Fill with gradientctx.strokeStyle=gradient;ctx.strokeText(\"www.whoosh.site\",10,90); measureText()context.measureText(text).width; text 要测量的文本。 实例1123456var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.font=\"30px Arial\";var txt=\"Hello World\"ctx.fillText(\"width:\" + ctx.measureText(txt).width,10,50)ctx.fillText(txt,10,100); createImageData()context.createImageData(imageData);context.createImageData(width,height); width ImageData 对象的宽度，以像素计。 height ImageData 对象的高度，以像素计。 imageData 另一个 ImageData 对象。 实例11234567891011var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");var imgData=ctx.createImageData(100,100);for (var i=0;i&lt;imgData.data.length;i+=4) &#123; imgData.data[i+0]=255; imgData.data[i+1]=0; imgData.data[i+2]=0; imgData.data[i+3]=255; &#125;ctx.putImageData(imgData,10,10); getImageData()context.getImageData(x,y,width,height); x 开始复制的左上角位置的 x 坐标。 y 开始复制的左上角位置的 y 坐标。 width 将要复制的矩形区域的宽度。 height 将要复制的矩形区域的高度。 实例11234567891011var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.fillStyle=\"green\";ctx.fillRect(10,10,50,50);var imgData=ctx.getImageData(30,30,50,50);red=imgData.data[0];green=imgData.data[1];blue=imgData.data[2];alpha=imgData.data[3];alert(red + \" \" + green + \" \" + blue + \" \" + alpha); putImageData()context.putImageData(imgData,x,y,dirtyX,dirtyY,dirtyWidth,dirtyHeight); imgData 规定要放回画布的 ImageData 对象。 x ImageData 对象左上角的 x 坐标，以像素计。 y ImageData 对象左上角的 y 坐标，以像素计。 dirtyX 可选。水平值（x），以像素计，在画布上放置图像的位置。 dirtyY 可选。水平值（y），以像素计，在画布上放置图像的位置。 dirtyWidth 可选。在画布上绘制图像所使用的宽度。 dirtyHeight 可选。在画布上绘制图像所使用的高度。 实例112345678910var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.fillStyle=\"green\";ctx.fillRect(10,10,50,50);function copy()&#123; var imgData=ctx.getImageData(10,10,50,50); ctx.putImageData(imgData,10,70);&#125; save()context.save(); 保存当前环境的状态 实例112345678const ctx = wx.createCanvasContext('canvas')ctx.save() ctx.setFillStyle('red') ctx.scale(2, 2)ctx.fillRect(10, 10, 150, 100) // 红色矩形一ctx.restore()ctx.fillRect(50, 50, 150, 100) // 黑色矩形二ctx.draw() restore()context.restore(); 获取上一次save保存的状态 实例112345678const ctx = wx.createCanvasContext('canvas')ctx.save() ctx.setFillStyle('red') ctx.scale(2, 2)ctx.fillRect(10, 10, 150, 100) // 红色矩形一ctx.restore()ctx.fillRect(50, 50, 150, 100) // 黑色矩形二ctx.draw() getContext()Canvas.getContext(contextID) contextID 当前唯一合法值2d，未来会支持3d 实例112var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\"); toDataURL()canvas.toDataURL(type) type image/jpeg，image/png 实例112345var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.fillRect(10, 10, 150, 100); dataURL=c.toDataURL('image/jpeg'); //转换图片为dataURL//data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAMCAgICAgMCAgIDAwMDBAYEBAQEBAgGBgUGCQgKCgkICQkKDA8MCgsOCwkJDRENDg8QEBEQCgwSExIQEw8QEBD/2wBDAQMDAwQDBAgEBAgQCwkLEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBD/wAARCACWASwDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAn/xAAUEAEAAAAAAAAAAAAAAAAAAAAA/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/AJVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//9k= toBlob()canvas.toBlob(callback, type, encoderOptions); callback 回调函数，可获得一个单独的Blob对象参数。 type 可选，DOMString类型，指定图片格式，默认格式为image/png。 encoderOptions 可选，Number类型，值在0与1之间，当请求图片格式为image/jpeg或者image/webp时用来指定图片展示质量。如果这个参数的值不在指定类型与范围之内，则使用默认值，其余参数将被忽略。 实例112345678var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.fillRect(10, 10, 150, 100); c.toBlob(function(b)&#123; //图片的二进制数据 console.log(b)&#125;,'image/png',1);","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://www.whoosh.site/categories/前端技术/"}],"tags":[{"name":"Canvas","slug":"Canvas","permalink":"http://www.whoosh.site/tags/Canvas/"}]},{"title":"Svg的基本用法","slug":"20170503_Svg的基本用法","date":"2017-05-03T14:13:58.000Z","updated":"2018-03-29T15:38:26.411Z","comments":true,"path":"2017/05/03/20170503_Svg的基本用法/","link":"","permalink":"http://www.whoosh.site/2017/05/03/20170503_Svg的基本用法/","excerpt":"","text":"浏览器支持表格中的数字表示支持Svg的第一个浏览器版本号。 元素 &lt;svg&gt; 12.0 6.0(部分)/9.0 5.1 3.2 10.6 形状SVG 预定义的形状元素：矩形 &lt;rect&gt;、圆形 &lt;circle&gt;、椭圆 &lt;ellipse&gt;、线 &lt;line&gt;、折线 &lt;polyline&gt;、多边形 &lt;polygon&gt;、路径 &lt;path&gt;。 矩形12345&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; &lt;rect width=\"250\" height=\"100\" x=\"20\" y=\"20\" rx=\"20\" ry=\"20\" style=\"fill:red;stroke-width:5;stroke:black;fill-opacity:0.1; stroke-opacity:0.9;opacity:0.5\"/&gt;&lt;/svg&gt; 查看样例 width 属性定义矩形的宽度 height 属性定义矩形的高度 x 属性定义矩形的左侧位置（例如，x=”0” 定义矩形到浏览器窗口左侧的距离是 0px） y 属性定义矩形的顶端位置（例如，y=”0” 定义矩形到浏览器窗口顶端的距离是 0px） rx 属性可使矩形产生圆角。 ry 属性可使矩形产生圆角。 style 属性用来定义 CSS 属性 CSS 的 fill 属性定义矩形的填充颜色（rgb 值、颜色名或者十六进制值） CSS 的 stroke-width 属性定义矩形边框的宽度 CSS 的 stroke 属性定义矩形边框的颜色 CSS 的 fill-opacity 属性定义填充颜色透明度（合法的范围是：0 - 1） CSS 的 stroke-opacity 属性定义笔触颜色的透明度（合法的范围是：0 - 1） CSS 的 opacity 属性定义整个元素的透明值（合法的范围是：0 - 1） 圆形1234&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; &lt;circle cx=\"100\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"2\" fill=\"red\"/&gt;&lt;/svg&gt; 查看样例 cx和cy属性定义圆点的x和y坐标。如果省略cx和cy，圆的中心会被设置为(0, 0) r属性定义圆的半径 椭圆1234&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; &lt;ellipse cx=\"300\" cy=\"150\" rx=\"200\" ry=\"80\" style=\"fill:rgb(200,100,50);stroke:rgb(0,0,100);stroke-width:2\"/&gt;&lt;/svg&gt; 查看样例 cx 属性定义圆点的 x 坐标 cy 属性定义圆点的 y 坐标 rx 属性定义水平半径 ry 属性定义垂直半径 直线1234&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; &lt;line x1=\"0\" y1=\"0\" x2=\"300\" y2=\"300\" style=\"stroke:rgb(99,99,99);stroke-width:2\"/&gt;&lt;/svg&gt; 查看样例 x1 属性在 x 轴定义线条的开始 y1 属性在 y 轴定义线条的开始 x2 属性在 x 轴定义线条的结束 y2 属性在 y 轴定义线条的结束 多边形1234&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; &lt;polygon points=\"220,100 300,210 170,250 123,234\" style=\"fill:#cccccc;stroke:#000000;stroke-width:1\"/&gt;&lt;/svg&gt; 查看样例 points 属性定义多边形每个角的 x 和 y 坐标,中间用空格分隔 折线1234&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; &lt;polyline points=\"0,0 0,20 20,20 20,40 40,40 40,60\" style=\"fill:white;stroke:red;stroke-width:2\"/&gt;&lt;/svg&gt; 查看样例 points 属性定义多边形每个角的 x 和 y 坐标,中间用空格分隔 路径1234&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; &lt;path d=\"M250 150 L150 350 L350 350 Z\" style=\"fill:white;stroke:red;stroke-width:2\"/&gt;&lt;/svg&gt; 查看样例 path 属性定义了一条路径，它开始于位置 250 150，到达位置 150 350，然后从那里开始到 350 350，最后在 250 150 关闭路径M = movetoL = linetoH = horizontal linetoV = vertical linetoC = curvetoS = smooth curvetoQ = quadratic Belzier curveT = smooth quadratic Belzier curvetoA = elliptical ArcZ = closepath 文本1234567891011&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt; &lt;defs&gt; &lt;path id=\"path1\" d=\"M75,20 a1,1 0 0,0 100,0\" /&gt; &lt;/defs&gt; &lt;text x=\"10\" y=\"100\" fill=\"red\" transform=\"rotate(30 20,40)\" style=\"fill:red;\"&gt; &lt;textPath xlink:href=\"#path1\"&gt;I love SVG In Text Path&lt;/textPath&gt; &lt;a xlink:href=\"http://www.whoosh.site/\" target=\"_blank\"&gt; &lt;tspan x=\"10\" y=\"45\"&gt; I love SVG&lt;/tspan&gt; &lt;/a&gt; &lt;/text&gt;&lt;/svg&gt; 查看样例 x 属性定义文本的左侧位置 y 属性定义文本的顶端位置 transform 属性定义空间转换，位移translate, 旋转rotate, 缩放scale, 斜切skew 样式Stroke12345678&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; &lt;g fill=\"none\" stroke=\"black\" stroke-width=\"4\"&gt; &lt;path stroke=\"red\" d=\"M5 20 l215 0\" /&gt; &lt;path stroke-width=\"4\" d=\"M5 40 l215 0\" /&gt; &lt;path stroke-linecap=\"round\" d=\"M5 60 l215 0\" /&gt; &lt;path stroke-dasharray=\"20,10,5,5,5,10\" d=\"M5 80 l215 0\" /&gt; &lt;/g&gt;&lt;/svg&gt; 查看样例 stroke：定义一条线，文本或元素轮廓颜色 stroke-width：定义了一条线，文本或元素轮廓厚度 stroke-linecap：定义不同类型的开放路径的终结 stroke-dasharray：定义用于创建虚线 滤镜在 SVG 中，可用的滤镜有： feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feFlood feGaussianBlur feImage feMerge feMorphology feOffset feSpecularLighting feTile feTurbulence feDistantLight fePointLight feSpotLight模糊效果 123456789&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt; &lt;defs&gt; &lt;filter id=\"Gaussian_Blur\"&gt; &lt;feGaussianBlur in=\"SourceGraphic\" stdDeviation=\"3\" /&gt; &lt;/filter&gt; &lt;/defs&gt; &lt;ellipse cx=\"200\" cy=\"150\" rx=\"70\" ry=\"40\" style=\"fill:#ff0000;stroke:#000000;stroke-width:2;filter:url(#Gaussian_Blur)\"/&gt;&lt;/svg&gt; 查看样例 &lt;filter&gt; 标签的 id 属性可为滤镜定义一个唯一的名称（同一滤镜可被文档中的多个元素使用） filter:url 属性用来把元素链接到滤镜。当链接滤镜 id 时，必须使用 # 字符 滤镜效果是通过 &lt;feGaussianBlur&gt; 标签进行定义的。fe 后缀可用于所有的滤镜 &lt;feGaussianBlur&gt; 标签的 stdDeviation 属性可定义模糊的程度 in=&quot;SourceGraphic&quot; 这个部分定义了由整个图像创建效果 阴影12345678910111213&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; &lt;defs&gt; &lt;filter id=\"f1\" x=\"0\" y=\"0\" width=\"200%\" height=\"200%\"&gt; &lt;feOffset result=\"offOut\" in=\"SourceGraphic\" dx=\"20\" dy=\"20\" /&gt; &lt;feColorMatrix result=\"matrixOut\" in=\"offOut\" type=\"matrix\" values=\"0.2 0 0 0 0 0 0.2 0 0 0 0 0 0.2 0 0 0 0 0 1 0\" /&gt; &lt;feGaussianBlur result=\"blurOut\" in=\"matrixOut\" stdDeviation=\"10\" /&gt; &lt;feBlend in=\"SourceGraphic\" in2=\"blurOut\" mode=\"normal\" /&gt; &lt;/filter&gt; &lt;/defs&gt; &lt;rect width=\"90\" height=\"90\" stroke=\"green\" stroke-width=\"3\" fill=\"yellow\" filter=\"url(#f1)\" /&gt;&lt;/svg&gt; 查看样例 &lt;filter&gt;元素id属性定义一个滤镜的唯一名称 &lt;rect&gt;元素的滤镜属性用来把元素链接到”f1”滤镜 &lt;feOffset&gt;偏移一个矩形（带） &lt;feBlend&gt;混合偏移图像顶部 &lt;feColorMatrix&gt;过滤器是用来转换偏移的图像使之更接近黑色的颜色。 ‘0.2’矩阵的三个值都获取乘以红色，绿色和蓝色通道。降低其值带来的颜色至黑色（黑色为0） &lt;feGaussianBlur&gt;元素的stdDeviation属性定义了模糊量 渐变1234567891011121314151617&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; &lt;defs&gt; &lt;linearGradient id=\"orange_red\" x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"0%\"&gt; &lt;stop offset=\"0%\" style=\"stop-color:rgb(255,255,0);stop-opacity:1\"/&gt; &lt;stop offset=\"100%\" style=\"stop-color:rgb(255,0,0);stop-opacity:1\"/&gt; &lt;/linearGradient&gt; &lt;/defs&gt; &lt;ellipse cx=\"200\" cy=\"190\" rx=\"85\" ry=\"55\" style=\"fill:url(#orange_red)\"/&gt; &lt;defs&gt; &lt;radialGradient id=\"grey_blue\" cx=\"50%\" cy=\"50%\" r=\"50%\" fx=\"50%\" fy=\"50%\"&gt; &lt;stop offset=\"0%\" style=\"stop-color:rgb(200,200,200);stop-opacity:0\"/&gt; &lt;stop offset=\"100%\" style=\"stop-color:rgb(0,0,255);stop-opacity:1\"/&gt; &lt;/radialGradient&gt; &lt;/defs&gt; &lt;ellipse cx=\"230\" cy=\"200\" rx=\"110\" ry=\"100\" style=\"fill:url(#grey_blue)\"/&gt;&lt;/svg&gt; 查看样例 &lt;linearGradient&gt; 标签的 id 属性可为渐变定义一个唯一的名称 fill:url(#orange_red) 属性把 ellipse 元素链接到此渐变 &lt;linearGradient&gt; 标签的 x1、x2、y1、y2 属性可定义渐变的开始和结束位置 渐变的颜色范围可由两种或多种颜色组成。每种颜色通过一个 标签来规定。offset 属性用来定义渐变的开始和结束位置 &lt;radialGradient&gt; 标签的 id 属性可为渐变定义一个唯一的名称，fill:url(#grey_blue) 属性把 ellipse 元素链接到此渐变，cx、cy 和 r 属性定义外圈，而 fx 和 fy 定义内圈 渐变的颜色范围可由两种或多种颜色组成。每种颜色通过一个 标签来规定。offset 属性用来定义渐变的开始和结束位置。 参考网站菜鸟教程W3CSchoolSVG模板","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://www.whoosh.site/categories/前端技术/"}],"tags":[{"name":"Svg","slug":"Svg","permalink":"http://www.whoosh.site/tags/Svg/"}]},{"title":"使用PhantomJS实现服务端截屏","slug":"20170303_使用PhantomJS实现服务端截屏","date":"2017-03-03T03:13:58.000Z","updated":"2018-03-18T02:41:47.798Z","comments":true,"path":"2017/03/03/20170303_使用PhantomJS实现服务端截屏/","link":"","permalink":"http://www.whoosh.site/2017/03/03/20170303_使用PhantomJS实现服务端截屏/","excerpt":"","text":"简介在一些前端项目中，有时会需要对页面或者某个div进行截屏，常见的方式是使用html2canvas来实现，这个方式的好处是显而易见的。但是，有时候也会出现以外，例如笔者碰到将复杂的svg截屏之后，发现图片与页面展示不一致，为了解决这个问题，查阅了很多资料。最后，通过PhantomJS实现了这个功能。 PhantomJS介绍PhantomJS是一个服务器端的JavaScriptAPI的WebKit。它使用QtWebKit作为它核心浏览器的功能，作为隐形的浏览器，提供了诸如CSS选择器、支持Web标准、DOM操作、JSON、HTML5、Canvas、SVG等（WebGL、Flash、Video、Audio、CSS 3D是不支持的），同时也提供了处理文件I/O的操作，从而使你可以向操作系统读写文件等。PhantomJS的用处非常广泛，诸如网络监测、网页截屏、无需浏览器的 Web 测试、页面访问自动化等。 PhantomJS使用目前官方支持windows\\Mac OS\\Linux三大主流的环境的运行包，你可以根据你的运行环境选择要下载的包。下载地址：http://phantomjs.org/download.html 笔者的运行环境是win10，下载完成后解压文件，将bin目录下的phantomjs.exe和examples目录下的hello.js放到一个文件目录下，然后在cmd下运行phantomjs.exe，结果如下图。 phantomjs的命令格式如下： 1phantomjs [options] somescript.js [arg1 [arg2 [...]]] 详细介绍参见Command Line Interface 接下来介绍如何实现服务端截屏功能，编写screenshot.js文件，先介绍下webpage、system、fs。 webpage:主要是提供了一套可以访问和操作web文档的核心方法，包括操作DOM、事件捕获、用户事件模拟等等。 system:该模块提供了一些与操作系统相关的接口，例如访问操作系统信息、访问系统环境变量、接受命令行参数等等与程序执行相关的系统信息。 fs:即FileSystem（类似NodeJS）。fs提供了执行文件I/O操作的标准接口，如读写文件、删除文件等。它使得你持久化一些文件（如logfile等）变得非常容易。 12345678910111213141516171819202122232425262728293031323334353637383940414243\"use strict\";/** * phantomjs screenshot.js \"http://192.168.14.180/index.html\" \"image/456.png\" * phantomjs screenshot.js \"wwwroot/index.html\" \"image/456.png\"*/var page = require('webpage').create();var system = require('system');var address, output;if (system.args.length &lt; 3 || system.args.length &gt; 5) &#123; phantom.exit(1);&#125; else &#123; address = system.args[1]; output = system.args[2]; //定义宽高 page.viewportSize = &#123; width: 1000, height: 800 &#125;; page.open(address, function (status) &#123; if (status == 'success') &#123; var bb = page.evaluate(function () &#123; return document.getElementsByTagName('html')[0].getBoundingClientRect(); &#125;); page.clipRect = &#123; top: bb.top, left: bb.left, width: bb.width, height: bb.height &#125;; window.setTimeout(function () &#123; //保存图片或者pdf，根据文件后缀名自动判断 page.render(output); page.close(); console.log('渲染成功...'); phantom.exit(); &#125;, 1000); &#125; else &#123; page.close(); phantom.exit(); &#125; &#125;);&#125; 在服务端定义一个方法，该方法创建一个cmd进程，让这个进程调用phantomjs命令格式即可。 12345678910111213141516171819202122232425262728/// &lt;summary&gt;/// 进行截图/// &lt;/summary&gt;/// &lt;param name=\"webPageUrl\"&gt;截图网页链接&lt;/param&gt;/// &lt;param name=\"imagePath\"&gt;截图生成的文件存放的路径及其文件名&lt;/param&gt;/// &lt;param name=\"serverPath\"&gt;phantomjs.exe与screenshot.js所在目录的路径&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool GetImg(string webPageUrl, string imagePath, string serverPath)&#123; try &#123; //实例化进程 //phantomjs.exe screenshot.js \"wwwroot/index.html\" \"image/456.png\" Process p = new Process(); p.StartInfo.FileName = serverPath + @\"\\phantomjs.exe\"; p.StartInfo.WorkingDirectory = serverPath + @\"\\\"; p.StartInfo.Arguments = string.Format(serverPath + @\"\\screenshot.js \" + webPageUrl + \" \" + imagePath); p.StartInfo.CreateNoWindow = true; p.StartInfo.WindowStyle = ProcessWindowStyle.Hidden; p.Start(); return true; &#125; catch (Exception ex) &#123; Console.WriteLine(ex.Message); return false; &#125;&#125; 无浏览器图形界面项目 软件名 介绍 支持语言 Awesomium 基于Chromium无图形界面浏览器引擎。 C++,.NET benv Benv是node.js开发的无界面浏览器测试环境，用于测试客户端代码。 JavaScript browser-launcher Browser-Launcher可以检测系统上的所有浏览器版本，并在一个独立的配置文件中启动它们，用于自动测试。 JavaScript browser.rb 无界面Ruby浏览器。 Ruby Browserjet 无界面webkit浏览器，采用node.js接口。 JavaScript BrowserKit 可模拟浏览器的行为。 PHP CasperJS CasperJS是一个开源的导航脚本和测试工具，使用JavaScript基于 PhantomJS 编写，用于测试Web应用功能，PhantomJS是一个服务器端的JavaScriptAPI的WebKit。其支持各种Web标准：DOM处理,CSS选择器,JSON,Canvas,和SVG。 JavaScript DalekJS DalekJS 是一个基于JavaScript（或Node.js）的免费和开源的自动化测试接口。它能够同时运行测试一组流行的浏览器（Chrome，IE，Firefox和WebKit）。 JavaScript Erik Erik是一款基于WebKit的无界面浏览器，可用于功能函数的测试，使用JavaScript对网页进行操作访问。 Swift Geb Geb是浏览器自动化（browserautomation）测试解決方案。 Groovy ghost ghost.py是一个Python的Webkit的Web客户端。 Python Ghostbuster Ghostbuster是一款自动化浏览器测试工具，基于phantomjs，意味着你得到一个仿真浏览器，一个真正的DOM，仿真测试环境。 JavaScript grope Grope是无ＧUI浏览器环境，使用WebKitFramework+RubyCocoa。 Ruby Guillotine Guillotine是一款采用C#开发的.NET无界面浏览器。 .NET Headless Headless是一款无界面浏览器，支持快速网络接受测试，采用.Net环境。 .NET headless_browser Headless-Browser是一款采用C++开发的基于WebKit无界面浏览器。 C++ HeadlessBrowser HeadlessBrowser是一款轻量级无图形界面浏览器，用于DOM测试。 JavaScript HtmlUnit HtmlUnit是一个isa”Java程序GUI-Less浏览器”。 Java Jabba-Webkit Jabba-Webkit是一款无图形化WebKit浏览器，主要用来抓取Ajax网页。 Python Jasmine-Headless-Webkit Jasmine-Headless-Webkit是一款基于jasmine的无图形化web工具。 Python,JavaScript,Ruby Jaunt JavaWeb网页抓取&amp;自动化API Java jBrowserDriver jBrowserDriver是一款采用纯Java编写的无图形化浏览器，基于WebKit，和Selenium兼容。 Java jedi-crawler Jedi-Crawler是一款轻量级 Node/PhantomJS爬虫，可以动态的抓取网页内容。 JavaScript Lotte Lotte是一款自动化无图形化浏览器测试工具，采用phantomJs。 JavaScript MechanicalSoup MechanicalSoup是一个与网站自动交互Python库。 Python mechanize 状态编程的Web浏览。 Python Nightmare 高层次浏览器自动化库，构建于PhantomJS。 JavaScript PhantomJS PhantomJS是一个服务器端的JavaScriptAPI的WebKit JavaScript,Python,Ruby,Java,C#,Haskell,Objective-C,Perl,PHP,R(via Selenium) phantompy Phantompy是一款headlessWebKit引擎，构建于强大的 Qt5WebkitAPI之上。 Python Python-Webkit Python-Webkit是一个Webkitpython扩展，可完整的访问网页的DOM。 Python RoboBrowser RoboBrowser是一款简单的浏览网页的Pythonic库，无需依赖独立的浏览器。 Python Selenium 跨平台自动化web浏览器。 JavaScript,Python,Ruby,Java,C#,Haskell,Objective-C,Perl,PHP,R SimpleBrowser SimpleBrowser是专门为自动化任务而设计的一个灵活而直观的浏览器引擎，内置.Net4framework。 .NET SlimerJS SlimerJS是一个提供给 Web 开发人员，可通过脚本编程控制的浏览器。 JavaScript Splash Splash是一款HTTPAPI轻量级浏览器，采用Python和ＱT开发。 Any Splinter Splinter是一个用Python编写的Web应用程序进行验收测试的工具。 Python Spynner Spynner是一个可编程Web浏览器Python模块。支持AJAX。 Python SST SST(selenium-simple-test)是一个Web测试框架，使用Python来生成基于浏览器的功能测试。 Python stanislaw Stanislaw一款Pythonheadless浏览器测试工具。 Python trifleJS 一个headlessIE浏览器。采用.NETWebBrowser类，拥有JavascriptAPI，运行在V8引擎。 JavaScript twill Twill是一种简单的语言，允许用户通过一个命令行界面浏览网页。 Python WatiN Watin是一个面向.net的Web自动化测试开源项目，对应Web元素提供了丰富的类库，而且使用起来非常简单。 .NET Watir-WebDriver Watir的实现基于WebDriver的Ruby绑定。 Ruby WKZombie WKZombie是针对iOS/OSX的不需要用户界面或API就能进行网站导航和数据收集的一个Swift框架，也被称为无界面浏览器。 Swift Zombie.js 一个轻量级的框架，用于在一个模拟的环境中测试客户端的JavaScript代码。Zombie.js使用Node.js实现快速的headlessfull-stack测试平台。 JavaScript","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://www.whoosh.site/categories/浏览器/"}],"tags":[{"name":"PhantomJS","slug":"PhantomJS","permalink":"http://www.whoosh.site/tags/PhantomJS/"}]},{"title":"ReactNative自学04-Props和State","slug":"20161127_ReactNative自学04_Props和State","date":"2016-11-27T14:37:58.000Z","updated":"2018-04-07T14:37:43.639Z","comments":true,"path":"2016/11/27/20161127_ReactNative自学04_Props和State/","link":"","permalink":"http://www.whoosh.site/2016/11/27/20161127_ReactNative自学04_Props和State/","excerpt":"","text":"概述我们使用两种数据来控制一个组件：props和state。 无状态组件 — 只有 props, 没有 state。 除去render() 函数和所有围绕props的逻辑之外，没有什么要关心的地方。这使他们易于理解且易于测试 有状态组件 — 既有 props 又有 state。也被称作状态管理者 。他们负责客户端-服务器通信(通过XHR, web sockets, 等)，数据处理和给用户行为反馈。 Propsprops是一个组件的配置选项。是由上到下指定且不可改变的。一个组件不能改变自身的props, 但要负责设置子组件的 props。例如，在Greeting组件中将name作为一个属性来定制，这样可以复用这一组件来制作各种不同的“问候语”。1234567891011121314151617181920import React, &#123; Component &#125; from 'react';import &#123; Text, View &#125; from 'react-native';class Greeting extends Component &#123; render() &#123; return ( &lt;Text&gt;Hello &#123;this.props.name&#125;!&lt;/Text&gt; ); &#125;&#125;export default class LotsOfGreetings extends Component &#123; render() &#123; return ( &lt;View style=&#123;&#123;alignItems: 'center'&#125;&#125;&gt; &lt;Greeting name='React Native' /&gt; &lt;/View&gt; ); &#125;&#125; State对于需要改变的数据，我们需要使用state（状态）。在ES6中，我们在constructor中初始化state。在ES5中，使用的是getInitialState方法来初始化state（这一做法会逐渐被淘汰）。 123456789101112131415import React, &#123; Component &#125; from 'react';class Test extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; showText: true &#125;; // 每1000毫秒对showText状态做一次取反操作 setInterval(() =&gt; &#123; this.setState(previousState =&gt; &#123; return &#123; showText: !previousState.showText &#125;; &#125;); &#125;, 1000); &#125;&#125; Props和State对比 操作 Props State 能否在组件内部设置默认值 Yes Yes 能否在组件内部修改 No Yes 能否从父组件获取初始值 Yes No 能否由父组件修改 Yes No 能否设置子组件初始值 Yes No 能否修改子组件的值 Yes No 相同点 props和state改变，都会引发render的重新渲染。 都能由自身组件的相应初始化函数设定初始值。 不同点 初始值来源：props来自于父组件或者自身getDefaultProps，state的初始值来自于自身的getInitalState（constructor）函数。 修改方式：props只能由父组件修改，不能在自身组件修改，state只能在自身组件中setState修改，不能由父组件修改。 对子组件：props是一个父组件传递给子组件的数据流，这个数据流可以一直传递到子孙组件，state代表的是一个组件内部自身的状态，只能在自身组件中存在。 Tips 尝试把尽可能多的组件无状态化。 state应该包括那些可能被组件的事件处理器改变并触发用户界面更新的数据。 尽可能使用 props 来作为组件外部数据来源。","categories":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://www.whoosh.site/categories/ReactNative/"}],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://www.whoosh.site/tags/ReactNative/"}]},{"title":"ReactNative自学03-组件的生命周期","slug":"20161115_ReactNative自学03_组件的生命周期","date":"2016-11-15T12:30:58.000Z","updated":"2018-04-07T14:05:56.650Z","comments":true,"path":"2016/11/15/20161115_ReactNative自学03_组件的生命周期/","link":"","permalink":"http://www.whoosh.site/2016/11/15/20161115_ReactNative自学03_组件的生命周期/","excerpt":"","text":"组件的生命周期概述一般说到组件的生命周期，基本上都会遵循创建、运行、销毁三个过程，RN组件的生命周期也如此。下面是在网上转载的RN生命周期流程图。 创建按照构造函数-&gt;componentWillMount-&gt;render-&gt;componentDidMount顺序依次执行，这个过程在组件的生命周期中只执行一次。等componentDidMount执行完毕之后，组件就进入了运行状态。 void getDefaultProps() 调用：组件创建前调用，多个实例间共享引用。仅调用一次。 目的：获取父组件传递过来的Props，如果Props和该函数中定义的Props的key一样，将会被覆盖。 void getInitState() 调用：组件创建前调用。仅调用一次。 目的：初始化组件内部的状态值，ES6中时在constructor中初始化state，ES5中使用的是getInitialState方法来初始化state（这一做法会逐渐被淘汰），建议初始化state的时候尽可能给每一个可能用到的值都赋一个初始值，避免在使用中出现空值。 void componentWillMount() 调用：组件挂载前触发。仅调用一次。 目的：常用于改变state的操作。 void render() 调用：渲染组件时。至少调用一次(在运行过程中也可能会调用)。 目的：渲染函数，返回一个Virtual DOM。在函数内部尽量保持纯净，只渲染组件，不修改状态，不执行副操作（如计时器、网络操作等）。 void componetDidMount() 调用：组件挂载结束触发。仅调用一次。 目的：在该函数中修改状态、执行网络请求、定时器开启等相关操作。 运行运行过程实际上就是监测props和state是否发生改变，当props发生改变后，会先回调componentWillReceiveProps并传入新的props。然后会执行更新界面相关的一系列回调方法。 当state发生改变后，会执行更新相关的回调方法。 void componentWillReceiveProps(nextProps) 调用：组件接收到新的props时被调用。 目的：新的props将会作为参数传递进来，老的props可以根据this.props来获取。另外，可以在该函数中对state作一些处理。且在该函数中更新state不会引起二次渲染。 bool shouldComponentUpdate(nextProps, nextState) 调用：组件接收到新的props和state时被调用。 目的：该函数主要对传递过来的nextProps和nextState作判断。如果返回true则重新渲染，如果返回false则不重新渲染。 void componentWillUpdate(prevProps, prevState) 调用：props或者state改变，且shouldComponentUpdate方法返回true时 目的：和初始化中的componentWillMount函数功能类似。可以在这个函数中为即将发生的重新渲染做一些准备，但不能在这个函数中通过this.setState再次改变状态机变量的值组件。 void render() 调用：组件重新渲染时调用。 目的：和初始化中的render函数功能类似。重新渲染组件，返回一个新的Virtual DOM。 void componentDidUpdate(prevProps, prevState) 调用：组件重新渲染完成后调用。 目的：和初始化中的componentDidMount函数功能类似。在该函数中修改状态、执行网络请求、定时器开启等相关操作 销毁当组件将要被卸载时，会先调用componentWillUnmount函数。 void componentWillUnmount() 调用：组件卸载和销毁之前调用。仅调用一次。 目的：进行定时器，监听等操作的销毁工作。","categories":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://www.whoosh.site/categories/ReactNative/"}],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://www.whoosh.site/tags/ReactNative/"}]},{"title":"ReactNative自学02-ES6语法","slug":"20161031_ReactNative自学02-ES6语法","date":"2016-10-31T11:34:58.000Z","updated":"2018-03-11T13:37:07.273Z","comments":true,"path":"2016/10/31/20161031_ReactNative自学02-ES6语法/","link":"","permalink":"http://www.whoosh.site/2016/10/31/20161031_ReactNative自学02-ES6语法/","excerpt":"","text":"简介ECMAScript 6.0（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 JavaScript的创造者Netscape公司，之后将JavaScript提交给国际标准化组织ECMA，希望这种语言能够成为国际标准，ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现， 之所以不叫JavaScript，主要是由于以下两个原因： 商标，Java是Sun公司的商标，根据授权协议，只有Netscape公司可以合法地使用JavaScript这个名字，且JavaScript本身也已经被Netscape公司注册为商标。 想体现这门语言的制定者是ECMA，不是Netscape，这样有利于保证这门语言的开放性和中立性。 变量在线将ES6代码转为ES5代码Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。这意味着，你可以用ES6的方式编写程序，又不用担心现有环境是否支持。 变量声明ES5只有2种声明变量的方法：var、function ES6共有6种声明变量的方法：var、function、let、const、import(require)、class。 1.var命令123456789101112131415161718var a = 10;var b = 20;var c = 30;var a = 10,b = 20,c = 30;var arr = [1,2,3,4,5];var a = arr[0];var b = arr[1];var c = arr[3];var obj = &#123; name: 'gary', age: 20&#125;var a = obj.name;var b = obj.age; 没有用var关键字，使用直接赋值方式声明的是全局变量，例如：1a = 10; 全局对象是最顶层的对象，在浏览器环境指的是window对象，在Node.js指的是global对象。ES5之中，全局对象的属性与全局变量是等价的。1234window.a = 1;a // 1a = 2;window.a // 2 2.function命令var 方式定义的函数，不能先调用函数，后声明，只能先声明函数，然后调用。function方式定义函数可以先调用，后声明。1234567891011aaa();//这样调用就会出错 var aaa = function()&#123; alert(\"aaa\"); &#125; aaa();//这样就不会出错 //先调用后声明 bbb(); function bbb()&#123; alert(\"bbb\"); &#125; 3.let命令 块级有效 ES5只有全局作用域和函数作用域，没有块级作用域，在ES6中，let实际上为JavaScript新增了块级作用域。 用来声明变量，用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; for循环的计数器，就很合适使用let命令。例如：1234567891011121314151617var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[5](); //10a[6](); // 10var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[5](); //5a[6](); // 6 变量提升 let不像var那样会发生“”现象1234console.log(foo); // 输出undefinedconsole.log(bar); // 报错ReferenceErrorvar foo = 2;let bar = 2; 实测结果两个都是undefined，应该是网上资料错误，可以通过Babel来了解底层原理 暂时性死区 只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。12345678910var tmp='dev';if (true) &#123; console.log(tmp); let tmp; console.log(tmp); tmp = 123; console.log(tmp);&#125; 在let命令声明变量tmp之前，都属于变量tmp的“死区”。 不允许重复声明 let不允许在相同作用域内，重复声明同一个变量。12345678910// 报错function test() &#123; let a = 10; var a = 1;&#125;// 报错function test() &#123; let a = 10; let a = 1;&#125; 因此，不能在函数内部重新声明参数。12345678function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; 4.const命令const声明一个只读的常量。一旦声明，就必须立即初始化，不能留到以后赋值。也不能改变。123const PI = 3.1415;console.log(PI); // 3.1415PI = 3;// TypeError: Assignment to constant variable. const的作用域与let命令相同：只在声明所在的块级作用域内有效，声明的常量，也与let一样不可重复声明。 const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。1234const foo = &#123;&#125;;foo.prop = 123;console.log(foo.prop);// 123foo = &#123;&#125;; // TypeError: \"foo\" is read-only var命令和function命令声明的全局变量，依旧是全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。也就是说，从ES6开始，全局变量将逐步与全局对象的属性脱钩。123456var a = 1;// 如果在Node的REPL环境，可以写成global.a// 或者采用通用方法，写成this.awindow.a // 1let b = 1;window.b // undefined 5.import命令(模块)模块的功能主要由 export 和 import 组成.每一个模块都有自己单独的作用域，模块之间的相互调用关系是通过 export 来规定模块对外暴露的接口，通过import来引用其它模块提供的接口。同时还为模块创造了命名空间，防止函数的命名冲突。 ES6将一个文件视为一个模块，通过export 向外输出了一个变量。一个模块也可以同时往外面输出多个变量。1234//test.jsvar name = 'Rainbow';var age = '24';export &#123;name, age&#125;; 定义好模块的输出以后就可以在另外一个模块通过import引用。1import &#123;name, age&#125; from './test.js' 整体输入，module指令1234567//test.jsexport function getName() &#123; return name;&#125;export function getAge()&#123; return age;&#125; 通过 import * as 就完成了模块整体的导入。1import * as test form './test.js'; 通过指令 module 也可以达到整体的输入。12module test from 'test.js';test.getName(); 不用关心模块输出了什么，通过 export default 指令就能加载到默认模块，不需要通过 花括号来指定输出的模块,一个模块只能使用 export default 一次123456789101112// default 导出export default function getAge() &#123;&#125; // 或者写成function getAge() &#123;&#125;export default getAge;// 导入的时候不需要花括号import test from './test.js';// 一条import 语句可以同时导入默认方法和其它变量.import defaultMethod, &#123; otherMethod &#125; from 'xxx.js'; 7.class命令如果你用过纯面向对象语言，那么你会对class的语法非常熟悉。1234567891011class People &#123; constructor(name) &#123; //构造函数 this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;var p = new People(\"Tom\");p.sayName(); 上面定义了一个People类，他有一个属性 name 和一个方法 sayName()，还有一个构造函数。 就像函数有函数声明和函数表达式两种定义方式，类也可以通过类表达式来定义： 1234567891011121314151617181920212223let People = class &#123; constructor(name) &#123; //构造函数 this.name = name; &#125; sayName() &#123; console.log(this.name); &#125; &#125;``` 你可能以为类声明和类表达式的区别在于变量提升的不同。但是事实是无论是类声明还是类表达式的方式来定义，都不会有变量提升。通过关键字 extends 来继承一个类，并且，可以通过 super 关键字来引用父类。```jsclass Student extends People &#123; constructor(name, grade) &#123; //构造函数 super(name); //通过 super 调用父类的构造函数的。 this.grade = grade; &#125; sayGrade() &#123; console.log(this.grade); &#125;&#125; 上面的例子中我们定义了一个 Student ，他是 People 的子类。下面我们给 name 属性定义 getter 和 setter123456789101112131415161718class People &#123; constructor(name) &#123; //构造函数 this.name = name; &#125; get name() &#123; return this._name.toUpperCase(); &#125; set name(name) &#123; this._name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;var p = new People(\"tom\");console.log(p.name); //TOMconsole.log(p._name); //tomp.sayName(); //TOM 仔细看上面的例子，搞清楚最后三行分别会输出什么，就明白getter 和 setter该怎么用了。 主要是要区分 this._name 和 this.name 的区别。因为我们定义了 name 的读写器，而没有定义 _name 的读写器，所以访问这两个属性的结果是不同的。 但是要注意一点，不要这样写：123set name(name) &#123; this.name = name;&#125; 因为给 this.name 赋值的时候会调用 set name ，这样会导致无限递归直到栈溢出。 通过 static 关键字定义静态方法：123456789101112class People &#123; constructor(name) &#123; //构造函数 this.name = name; &#125; sayName() &#123; console.log(this.name); &#125; static formatName(name) &#123; return name[0].toUpperCase() + name.sustr(1).toLowerCase(); &#125;&#125;console.log(People.formatName(\"tom\")); 解构赋值ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 模式匹配只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。 如果解构不成功，变量的值就等于undefined。12345678910111213141516171819202122232425let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [x, , y] = [1, 2, 3];//不完全解构x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // \"a\"y // undefinedz // []//解构赋值允许指定默认值。var [foo = true] = [];foo // true[x, y = 'b'] = ['a']; // x='a', y='b'[x, y = 'b'] = ['a', undefined]; // x='a', y='b' 注意，ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError 解构赋值不仅适用于var命令，也适用于let和const命令。123var [v1, v2, ..., vN ] = array;let [v1, v2, ..., vN ] = array;const [v1, v2, ..., vN ] = array; 对于Set结构，也可以使用数组的解构赋值。12let [x, y, z] = new Set([\"a\", \"b\", \"c\"]);x // \"a\" 对象的解构赋值解构不仅可以用于数组，还可以用于对象。123var &#123; foo, bar &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;foo // \"aaa\"bar // \"bbb\" 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。123456var &#123; bar, foo &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;foo // \"aaa\"bar // \"bbb\"var &#123; baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;baz // undefined 如果变量名与属性名不一致，必须写成下面这样。123456var &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;baz // \"aaa\"let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world' 这实际上说明，对象的解构赋值是下面形式的简写。1var &#123; foo: foo, bar: bar &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;; 也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。123var &#123; foo: baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;baz // \"aaa\"foo // error: foo is not defined 变量的解构赋值变量的声明和赋值是一体的。对于let和const来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。1234let foo;let &#123;foo&#125; = &#123;foo: 1&#125;; // SyntaxError: Duplicate declaration \"foo\"let baz;let &#123;bar: baz&#125; = &#123;bar: 1&#125;; // SyntaxError: Duplicate declaration \"baz\" 上面代码中，解构赋值的变量都会重新声明，所以报错了。不过，因为var命令允许重新声明，所以这个错误只会在使用let和const命令时出现。如果没有第二个let命令，上面的代码就不会报错。 如果要将一个已经声明的变量用于解构赋值，必须非常小心。1234// 错误的写法var x;&#123;x&#125; = &#123;x: 1&#125;;// SyntaxError: syntax error 上面代码的写法会报错，因为JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。12// 正确的写法(&#123;x&#125; = &#123;x: 1&#125;); 数组的解构赋值由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。1234var arr = [1, 2, 3];var &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3 结构的解构赋值和数组一样，解构也可以用于嵌套结构的对象。123456789var obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;var &#123; p: [x, &#123; y &#125;] &#125; = obj;x // \"Hello\"y // \"World\" 注意，这时p是模式，不是变量，因此不会被赋值。123456789101112var node = &#123; loc: &#123; start: &#123; line: 1, column: 5 &#125; &#125;&#125;;var &#123; loc: &#123; start: &#123; line &#125;&#125; &#125; = node;line // 1loc // error: loc is undefinedstart // error: start is undefined 默认值生效的条件是，对象的属性值严格等于undefined。 字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。123456const [a, b, c, d, e] = 'hello';a // \"h\"b // \"e\"c // \"l\"d // \"l\"e // \"o\" 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。12let &#123;length : len&#125; = 'hello';len // 5 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。1234let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。 函数参数的解构解构赋值的规则是，只要等号右边的值不是对象，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。12let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 函数参数的解构也可以使用默认值。1234567function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。1234567function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0] 函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。 事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。12345678910function* fibs() &#123; var a = 0; var b = 1; while (true) &#123; yield a; [a, b] = [b, a + b]; &#125;&#125;var [first, second, third, fourth, fifth, sixth] = fibs();sixth // 5 解构赋值用途 交换变量的值1[x, y] = [y, x]; 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。 从函数返回多个值函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。 12345678910111213// 返回一个数组function example() &#123; return [1, 2, 3];&#125;var [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;var &#123; foo, bar &#125; = example(); 函数参数的定义 解构赋值可以方便地将一组参数与变量名对应起来。123456// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 提取JSON数据 解构赋值对提取JSON对象中的数据，尤其有用。12345678var jsonData = &#123; id: 42, status: \"OK\", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, \"OK\", [867, 5309] 上面代码可以快速提取JSON数据的值。 函数参数的默认值1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;; 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || &#39;default foo&#39;;这样的语句。 遍历Map结构任何部署了Iterator接口的对象，都可以用for…of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。12345678var map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + \" is \" + value);&#125;// first is hello// second is world 如果只想获取键名，或者只想获取键值，可以写成下面这样。12345678// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; 输入模块的指定方法 加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。1const &#123; SourceMapConsumer, SourceNode &#125; = require(\"source-map\"); 编程风格采用严格模式：use strict主要有以下限制： 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀0表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global* [prop] eval不会在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface） let取代var在块级作用域下，let完全可以取代var，因为两者语义相同，而且let没有副作用。 在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。所有的函数都应该设置为常量。这符合函数式编程思想，有利于将来的分布式运算。const声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。 长远来看，JavaScript可能会有多线程的实现（比如Intel的River Trail那一类的项目），这时let表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。 字符串静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。 解构赋值使用数组成员对变量赋值时，优先使用解构赋值。 函数的参数如果是对象的成员，优先使用解构赋值。 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。 对象单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。 另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。 数组使用扩展运算符（…）拷贝数组。 使用Array.from方法，将类似数组的对象转为数组。 函数立即执行函数可以写成箭头函数的形式。 那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了this。 简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。 不要在函数体内使用arguments变量，使用rest运算符（…）代替。因为rest运算符显式表明你想要获取参数，而且arguments是一个类似数组的对象，而rest运算符可以提供一个真正的数组。 Map结构注意区分Object和Map，只有模拟现实世界的实体对象时，才使用Object。如果只是需要key: value的数据结构，使用Map结构。因为Map有内建的遍历机制。 Class总是用Class，取代需要prototype的操作。因为Class的写法更简洁，更易于理解。 使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。 模块首先，Module语法是JavaScript模块的标准写法，坚持使用这种写法。使用import取代require。 如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，不要export default与普通的export同时使用。 不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。 如果模块默认输出一个对象，对象名的首字母应该大写。 网络资源http://www.w3school.com.cn/js/index.asp http://es6.ruanyifeng.com/ http://babeljs.io/","categories":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://www.whoosh.site/categories/ReactNative/"}],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://www.whoosh.site/tags/ReactNative/"},{"name":"ES6","slug":"ES6","permalink":"http://www.whoosh.site/tags/ES6/"}]},{"title":"ReactNative自学01-基础篇","slug":"20160925_ReactNative自学01-基础篇","date":"2016-09-25T10:59:58.000Z","updated":"2018-03-11T13:37:07.249Z","comments":true,"path":"2016/09/25/20160925_ReactNative自学01-基础篇/","link":"","permalink":"http://www.whoosh.site/2016/09/25/20160925_ReactNative自学01-基础篇/","excerpt":"","text":"React-Native技术背景目前跨平台移动开发主要分一下4个主要流派为：Web流，代码转换流，编译流，和虚拟机流。 Web 流：也被称为 Hybrid 技术，它基于 Web 相关技术来实现界面及功能 代码转换流：将某个语言转成 Objective-C、Java 或 C#，然后使用不同平台下的官方工具来开发 编译流：将某个语言编译为二进制文件，生成动态库或打包成 apk/ipa/xap 文件 虚拟机流：通过将某个语言的虚拟机移植到不同平台上来运行 facebook之前投入了大量精力在html5，虽然取得很大进展，但始终不如人意，后来就转向native开发，性能和体验都近乎完美，但无法摆脱苹果的束缚，在版本更新和维护上非常的麻烦，同时，一些公司采用混合开发模式（Hybrid）即：native+web,但是webview的性能在移动断是受限的，所以也不是一种特别好的模式。 之后，facebook在react框架基础上推出react-native(react.js用于开发网页)，在性能上仅次于native，但比Hybrid和html5优越很多。同时，RN不仅可以使用前端开发的模式开发应用，还可以调用原生应用的UI和组件 现在除了Facebook，很多大公司都在尝试这一技术来降低开发和维护成本，如：淘宝部分功能、qq空间、携程部分产品等，而且微软未来在UWP应用上也会支持RN技术。 搭建开发环境 安装node.js，会自动安装包管理器npm，查看安装结果node -v, npm -v 安装java开发环境，java sdk、java jdk，并配置java环境变量，查看环境变量echo %path% 配置环境变量,在系统环境中添加JAVA_HOME,在Path中添%JAVA_HOME%/bin 安装android开发环境，并配置android环境变量 在系统环境中添加ANDROID_HOME,在Path中添加 %ANDROID_HOME%\\tools %ANDROID_HOME%\\platform_tools 在系统环境中添加CLASSPATH,值：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar 下载Android SDK, Tools:Android SDK Tools、Android SDK Platform-tools、Android SDK Build tools（必须是版本23.0.1） Android 6.0(API23):SDK Platform、Google APIs、Soucre for Android SDK（如果装虚拟机：Google APIs Intel x86 Atom_64 System Image） Extras:Android Support Repository、Android Support Libarary（Obsolete）、Google USB Driver（如果虚拟机：Inter x86 Emulator Accelerate[HAXM install]） 安装代码编辑环境，我使用的是vscode,可以很方便的调试程序，也可以使用WebStorm。首先，安装react native tools插件，安装Bable ES6/Es7插件 安装代码版本工具，git，方便项目管理，和clone开源资源（可选） 第一个RN项目切换npm镜像12npm config set registry https://registry.npm.taobao.orgnpm config set disturl https://npm.taobao.org/dist 安装react-native-cli1npm install react-native-cli -g //全局安装cli 初始化实例1react-native init Mytest NPM加载开源包123npm install //安装project.json中的资源包npm install 包名 -save //最新版本npm install 包名@2.1.1 -save //指定版本 运行RN项目12react-native run-androidreact-native run-ios 其他常用命令1234567adb devices //查看当前连接设备adb reverse tcp:8081 tcp:8081 //重新链接设备adb shell input keyevent 82 //调出开发者菜单npm cache clean //清理npm本地缓存npm kill-server //结束npmnpm start-server //开启npmreact-native upgrade //更新react-native版本 相关资源 RN官网： http://facebook.github.io/react-native/docs/getting-started.html RN中文官网： http://reactnative.cn/ ES语法： http://es6.ruanyifeng.com/ Android资源：http://www.android-studio.org/ npm淘宝镜像：http://npm.taobao.org/ 所用软件：百度网盘 密码：oo3t","categories":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://www.whoosh.site/categories/ReactNative/"}],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://www.whoosh.site/tags/ReactNative/"}]},{"title":"Markdown语法简介","slug":"20160901_Markdown语法简介","date":"2016-09-01T12:30:58.000Z","updated":"2018-03-16T15:20:56.985Z","comments":true,"path":"2016/09/01/20160901_Markdown语法简介/","link":"","permalink":"http://www.whoosh.site/2016/09/01/20160901_Markdown语法简介/","excerpt":"","text":"概述Markdown 是一个 Web 上使用的文本到HTML的转换工具，可以通过简单、易读易写的文本格式生成结构化的HTML文档。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。 Markdown 并非要取代 HTML，而是以一种简单的书写格式，实现一种更加友好的页面呈现，并且，如果所需的标签不在 Markdown 涵盖范围之内，可以直接在文档里面用 HTML 撰写。但要制约的只有一些 HTML 区块元素――比如 &lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt; 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。 另外 Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 &lt;p&gt; 标签，且书写时一定要在 Markdown 标签和内容之间加上空格，例如：# 标题 基本标签段落一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。 如图所示： 换行Markdown 允许段落内的强迫换行，例如直接插入换行符&lt;br/&gt;，如果你确实想要依赖 Markdown 的格式来换行的话，可以在插入处先按入两个以上的空格或者至少一个 Tab 键，然后回车即可。 如图所示： 缩进普通段落不该用空格或制表符来缩进，因为用了也无效，可以通过在段落前添加需要的空格编码，已达到显示效果。 半角空格 &amp;ensp; 或 &amp;#8194; 全角空格 &amp;emsp; 或 &amp;#8195; 不断行空格 &amp;nbsp; 或 &amp;#160; 如图所示： 标题Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。 类 Setext 形式是用底线的形式，利用任意数量的 = （一级标题）和 - （二级标题） 类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 一级 到 六级 如图所示： 列表Markdown 支持有序列表和无序列表。 无序列表使用星号、加号或是减号作为列表标记 有序列表则使用数字接着一个英文句点，如果排序错乱，Markdown 仍会以第一个数字进行排序，所以，第一个项目最好还是从 1. 开始 区块引用Markdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式。 可以自己先将内容断好行，然后在每行的最前面加上在每一行加上 &gt; ，如区块引用1 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ，如区块引用2 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ，如区块引用2，3 如图所示： 代码 如果要标记一小段行内代码，你可以用反引号把它包起来，如： `代码` 如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段 代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号 在代码区段内，&amp; 和方括号都会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易 如图所示： 代码区块在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以 如图所示： 超链接超链接允许两种样式： 行内式和参考式。 行内式的形式为： 方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字 接着一个冒号 接着一个以上的空格或制表符 接着链接的网址 选择性地接着 title 内容，可以用单引号、双引号或是括弧包着，最好使用双引号 参考式的形式为： 在链接文字的括号后面再接上另一个方括号 而在第二个方括号里面要填入用以辨识链接的标记 如图所示： 图片Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。 其形式为： 一个惊叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 title 文字。 如图所示： 表格Markdown 的表格格式虽然简单，但制作起来是很不容易的。 如图所示： 强调Markdown 使用星号 * 和底线 _ 作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 &lt;em&gt; 标签包围，用两个 或 _ 包起来的话，则会被转成 &lt;strong&gt;。但是，如果你的 `或_` 两边都有空白的话，它们就只会被当成普通的符号。 如图所示： 分隔线Markdown 允许在一行中用三个以上的星号、减号、底线来建立一个分隔线，也可以在星号或是减号中间插入空格，但行内不能有其他东西。 如图所示： 其他反斜杠Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \\ 反斜线` 反引号* 星号_ 底线{} 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 自动链接Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接&lt;http://baidu.com/&gt; 如图所示： 特殊字符在 HTML 文件中，有两个字符需要特殊处理： &lt; 和 &amp; 。 &lt; 符号用于起始标签，&amp; 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式 &amp;lt; 和 &amp;amp;。但是 code 范围内，不论是行内还是区块， &lt; 和 &amp; 两个符号都一定会被转换成 HTML 实体 推荐MarkDown 中文 VSCode 代码编辑器","categories":[{"name":"Development Language","slug":"Development-Language","permalink":"http://www.whoosh.site/categories/Development-Language/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://www.whoosh.site/tags/Markdown/"}]},{"title":"树莓派3 声音传感器(Win10 IoT)","slug":"20160425_树莓派3 声音传感器-Win10","date":"2016-04-24T16:35:58.000Z","updated":"2018-03-18T13:47:03.265Z","comments":true,"path":"2016/04/25/20160425_树莓派3 声音传感器-Win10/","link":"","permalink":"http://www.whoosh.site/2016/04/25/20160425_树莓派3 声音传感器-Win10/","excerpt":"","text":"序这段时间太忙了，项目收尾一直没有时间继续捣鼓树莓派，正好趁这个双休抽点时间来和我的小伙伴玩耍一把。上篇文章提到我想用Win10 Iot Core和买来的一堆传感器摩擦出一些火花，虽然，已经有很多前辈做过，但是我没有做过啊，没做过又怎么能体会到实践的乐趣呢。先来一张传感器全家福吧！ 声音传感器这么一大堆传感器，要先玩那个呢，啊！纠结症又犯了，挑挑拣拣了好久，最后决定先搞一个简单点的—声音检测传感器。 那么，接下来就是看资料了，还好店家提供相关技术文档，这里为避嫌，就不提供店家地址。其实原理很简单，电路图如下： 以下是我摘录的： 模块描述 可以检测周围环境的声音强度 ,使用注意：此传感器只能识别声音的有无（根据震动原理）不能识别声音的大小或者特定频率的声音 灵敏度可调（图中蓝色数字电位器调节） 工作电压3.3V-5V 输出形式数字开关量输出（0和1高低电平）模块接口说明 VCC外接3.3V-5V电压（可以直接与 5v 单片机和3.3v单片机相连） GND外接GND DO小板数字量输出接口（0和 1）使用说明 声音模块对环境声音强度最敏感，一般用来检测周围环境的声音强度。 模块在环境声音强度达不到设定阈值时，DO口输出高电平，当外界环境声音强度超过设定阈值时，模块 D0输出低电平 小板数字量输出 D0可以与单片机直接相连，通过单片机来检测高低电平，由此来检测环境的声音 检查传感器了解了声音传感器基本结构后，我们要做的就是检查声音传感器是否正常：在相对安静的环境中，将模块的VCC接到树莓派的3.3V PWR电源正极上，将模块的GND接到树莓派的GND上（我选了39），此时，模块的电源指示灯会亮，说明你的传感器OK。如果开关提示也亮了，说明传感器对当前环境声音太灵敏了，可以调节蓝色数字电位器，使之灵敏度降低。附上测试接线图和树莓派GPIO引脚位置图： 如何接线我使用了6根杜邦线（3根公对母，3根公对公），具体接线步骤： 将第一根公对母杜邦线母端接到树莓派3.3V PWR电源引脚上，公端接到面包 板的正极上（红线） 将第二根公对母杜邦线母端接到树莓派GND负极引脚上，公端接到面包板负极上（棕线） 将第三根公对母杜邦线母端接到树莓派GPIO 5引脚上，公端接到LED灯长脚上（灰线） 将第一根公对公杜邦线的一端接到面包板电源正极上，另一端接到传感器VCC上（红线） 将第二根公对公杜邦线的一端接到面包板电源负极上，另一端接到传感器GND上（棕线） 将最后一根公对公杜邦线的一端接到传感器的OutPut(DO)上，另一端接到LED等的短脚上（紫线）。 最后接线如图所示： 代码实现见证奇迹的时刻到了，新建一个UWP空白应用（通用Windows），将以下代码粘到MainPage中，然后部署到树莓派中的Win10中即可。至于怎么安装系统、部署应用和web远程控制，待我下次整理出一个文档，当然，你也可以自己在网上搜。另外：源码来源于网友汪宇杰Edi.Wang。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public sealed partial class MainPage : Page &#123; //LED灯引脚 public GpioPin LedPin &#123; get; set; &#125; //声音传感器引脚 public GpioPin SoundPin &#123; get; set; &#125; //保存LED灯的开关状态 public bool IsLightOn &#123; get; set; &#125; public MainPage() &#123; this.InitializeComponent(); Loaded += OnLoaded; &#125; /// &lt;summary&gt; /// Loaded事件 /// &lt;/summary&gt; /// &lt;param name=\"sender\"&gt;&lt;/param&gt; /// &lt;param name=\"routedEventArgs\"&gt;&lt;/param&gt; private void OnLoaded(object sender, RoutedEventArgs routedEventArgs) &#123; //初始化GPIO控制器 var controller = GpioController.GetDefault(); if (null != controller) &#123; //LED是高电平输出表示开，所以第一次启动的时候要关灯，输出低电平 LedPin = controller.OpenPin(5); LedPin.SetDriveMode(GpioPinDriveMode.Output); LedPin.Write(GpioPinValue.Low); //FC-04的GPIO 06端口是接受信号的，所以是输入 SoundPin = controller.OpenPin(6); SoundPin.SetDriveMode(GpioPinDriveMode.Input); //监测声音传感器引脚值得变化 SoundPin.ValueChanged += (pin, args) =&gt; &#123; //读取引脚值（FC-04传感器只有两个值0、1） var pinValue = SoundPin.Read(); //FC-04检测到声音时候会在DO输出低电平 if (pinValue == GpioPinValue.Low) &#123; Debug.WriteLine(\"Sound Detected!\"); //开关灯操作（设置LED引脚值） LedPin.Write(IsLightOn ? GpioPinValue.Low : GpioPinValue.High); IsLightOn = !IsLightOn; &#125; &#125;; &#125; &#125; &#125; 总结在实践过程中遇到了不少问题，毕竟是小白，有很多不懂不会的地方，但是，还是那句话，只要思想不倒退，办法总比困难多。最后，来看一下效果图吧！","categories":[{"name":"树莓派","slug":"树莓派","permalink":"http://www.whoosh.site/categories/树莓派/"}],"tags":[{"name":"树莓派3","slug":"树莓派3","permalink":"http://www.whoosh.site/tags/树莓派3/"},{"name":"传感器","slug":"传感器","permalink":"http://www.whoosh.site/tags/传感器/"},{"name":"Win10 IoT","slug":"Win10-IoT","permalink":"http://www.whoosh.site/tags/Win10-IoT/"}]},{"title":"树莓派3 使用体验","slug":"20160410_树莓派3 使用体会","date":"2016-04-10T15:35:00.000Z","updated":"2018-03-16T15:23:47.629Z","comments":true,"path":"2016/04/10/20160410_树莓派3 使用体会/","link":"","permalink":"http://www.whoosh.site/2016/04/10/20160410_树莓派3 使用体会/","excerpt":"","text":"序以前听说过树莓派，那时候感觉这玩意离自己很遥远，都是一些极客才会玩的东西。但是，随着微软针对Raspberry Pi推出的Win10 Iot Core版本，便勾起了我的兴趣了，没办法，谁叫我是一个资深软粉呢！虽说有兴趣，但真要买一个玩玩，还是下了很大决心的，主要原因并不是浪费钱（板子不贵，240左右天朝币），而是根据微软这么多年的尿性，怕学了也没什么卵用。当年搞WP开发就被坑了，好在也学到了不少东西，嗯，就这样安慰自己吧。 树莓派3一出来，我就坐不住了，上一周在X宝上攒了一套，包括主板，还有一堆的配件（各种传感器、面包板、杜邦线、小零件），要吐槽一下快递，这种东西店家一般都要收快递费，所以要买的话，一次性买齐。而且不巧的是，当时正赶上深圳的禁摩限电，搞了一周才到货。 还要说一下杜邦线，我拿到货就傻眼了，40根全是母对母的，本以为是公对母的呢，最后想了个办法，把缝衣针折断来替代，也是醉了。说了这么多废话，接下来进入正题。 先来一张定妆照： 使用体验那么这几天我都用这货干了些什么呢，先来看一下有哪些系统可以跑在树莓派上呢，Raspberry Pi官网给出了如下图系统，这些系统下载地址都可以在这个页面中找到，我就尝试了下图中箭头所指的4个系统，那么就逐个来说说体验过程中遇到的问题吧。 RaspBian官方支持的操作系统，Noobs是一个比RaspBian更容易安装的版本，其实都很简单的，网上有这方面的教程，就是通过win32diskimager-v0.9-binary，将img镜像写入到SD卡中，然后把SD卡插到主板上，通电就OK了。我就不在赘述了点击下载 需要强调的是，如果你没有显示器，可以使用替代方法，例如：远程访问，根据上面地址文章中的步骤，进入到RaspBian系统后，安装Linux下远程桌面xrdp即可在window下通过远程桌面访问到桌面版的RaspBian了。 安装远程访问xrdp命令 1sudo apt-get install xrdp Ubuntu Mate使用这个系统的时候，我也想着像上一个步骤那样，通过远程访问来搞定，但现实是残酷滴，我无法知道Ubuntu系统的用户名和密码，就没法登陆进去，这可难倒我了，最终还是办法总是多于困难的，现在的电视机一半都自带VGA或者HDMI接口，这个时候，就可以通过HDMI线或者HDMI转VGA接头连接到电视上，要说明的是，网上说HDMI转接头最好需要带外部电源的，可是我用了个无源的转接头也是Ok的，前提是主板电源输出不要太低，官方说是2.5A，实际上我用的是2.0A。 另外，如果用HDMI直链电视的话，国内的电视显示器分辨率很杂，我家里的就是，接上去也通电了，但就是黑屏，于是各种查啊。这里就需要修改系统分区下config.txt文件，建议使用notepad++打开文档，添加或修改配置项hdmi_ignore_edid=0xa5000080，具体步骤请移步。 Win10 IoT话说我就是因为Win10才买树莓派的，物联网要火了，不能掉队伍不是。而且，在编程方面也有基础，官方提供了很多Demo，光看源码不实操，心里是很痒的，哈哈。所以一拿到货我就装了Win10的系统，需要提醒的是，如果和我一样，使用的是树莓派3，那么就需要下最新版本的系统了，win10正式版10586是不支持Pi3的，之后的可以。而且现在最新的版本系统（14295）还不支持wifi和蓝牙，我就是冲着Pi3自带wifi和蓝牙才放弃pi2的，感谢网友汪宇杰Edi.Wang的告知。 说一下开发过程中遇到的一个坑，按照官方提供的点亮LED程序，发现没法点亮LED灯，导致我一直以为是我接线出了问题，可是接线实在是太简单了，这都错智商岂不是没救了，后来在VS中自己跑了一遍源码，居然就点亮了，真是我勒个去啊。附上官方地址 这里很多文档可以参考，另外Demo下载地址。 OpenElec这个系统是什么货呢，可能知道它的人不多，说通俗点吧，它是多媒体终端系统，可以用作电视盒子，以前叫XBMC现在叫Kodi,装了这个系统，树莓派瞬间就变成了电视盒子了，系统安装过程和装Ubuntu Mate是一样的，装好了如何配置就稍微复杂一些，主要是在更换中文语言的地方一个坑，还有就是想看国内视频网站或电视直播，需要下载中文插件库，好在网上有很多教程，按照教程走问题都不大的，附上教程地址 总结树莓派的可玩性是很强的，可以用它来做一些很有趣的事情，但是怎么有趣就要自己去发掘了。另外，记得我上文提到我买了一堆的传感器吧，接下来，我就要尝试在win10 iot下和这些传感器玩耍了，再次感谢这方面的先锋战士Edi.Wang。","categories":[{"name":"树莓派","slug":"树莓派","permalink":"http://www.whoosh.site/categories/树莓派/"}],"tags":[{"name":"树莓派3","slug":"树莓派3","permalink":"http://www.whoosh.site/tags/树莓派3/"}]}]}