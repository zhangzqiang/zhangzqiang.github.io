{"meta":{"title":"WHOOSH","subtitle":"生平有数，学识无涯","description":"张正强、技术分享","author":"Zhengqaing Zhang","url":"http://www.whoosh.site"},"pages":[{"title":"","date":"2018-02-15T07:43:55.192Z","updated":"2016-09-07T10:04:28.000Z","comments":true,"path":"baidu_verify_nvBydHIzNT.html","permalink":"http://www.whoosh.site/baidu_verify_nvBydHIzNT.html","excerpt":"","text":"nvBydHIzNT"},{"title":"","date":"2018-02-15T07:43:55.192Z","updated":"2018-02-10T18:03:24.000Z","comments":true,"path":"categories/index.html","permalink":"http://www.whoosh.site/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-02-15T07:43:55.176Z","updated":"2018-02-10T18:03:24.000Z","comments":true,"path":"about/index.html","permalink":"http://www.whoosh.site/about/index.html","excerpt":"","text":""},{"title":"","date":"2018-02-15T07:43:55.207Z","updated":"2018-02-10T18:03:24.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.whoosh.site/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"项目成本管理","slug":"20180506_项目成本管理","date":"2018-05-06T14:53:58.000Z","updated":"2018-06-18T15:16:19.538Z","comments":true,"path":"2018/05/06/20180506_项目成本管理/","link":"","permalink":"http://www.whoosh.site/2018/05/06/20180506_项目成本管理/","excerpt":"","text":"成本管理 关注完成项目活动所需资源的成本，但同时也应考虑项目决策对项目产品、服务或成果的使用成本、维护成本和支持成本的影响。 采用轻量级估算方法快速生成对项目人力成本的高层级预测，详细的估算适用于采用准时制的短期规划规划成本管理 定义 确定如何估算、预算、管理、监督和控制项目成本的过程 作用 在整个项目期间为如何管理项目成本提供指南和方向 时间点 仅开展一次或在预定义节点开展 备注 在项目规划阶段早期对成本管理进行规划ITTO 输入（I） 项目章程 预先批准的财务资源以及规定的项目审批要求 项目管理计划 进度管理计划,风险管理计划 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 数据分析：备选方案分析 会议 输出（O） 成本管理计划，和进度管理计划内容类似 计量单位 精确度、准确度 组织程序链接 工作分解结构（WBS）为成本管理计划提供了框架，以便据此规范地开展成本估算、预算和控制 控制临界值 偏差临界值，用于监督成本绩效 绩效测量规则 报告格式 其他细节估算成本 定义 对完成项目工作所需资源成本进行近似估算的过程 作用 确定项目所需资金 时间点 整个项目期间开展 备注 成本估算是对完成活动所需资源的可能成本的量化评估 通常以某种货币单位进行成本估算，也可以使用人天数，来消除通货膨胀的影响 粗略量级估算（ROM）区间-25%至75%，确定性估算区间-5%至10%ITTO 输入（I） 项目管理计划 成本管理计划，质量管理计划，范围基准 项目文件 经验教训登记册，项目进度计划，资源需求，风险登记册 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 类比估算 使用以往项目的参数值或属性进行估算 参数估算 利用历史数据之间的统计关系和其他变量进行估算 自下而上估算 对单个工作包或活动的成本进行最具体、细致的估算，然后向上逐层汇总，用于后续报告和跟踪 三点估算 考虑估算中的不确定性和风险，使用最可能成本（Cm）、最乐观成本（Co）、最悲观成本（Cp）来界定活动成本的近似区间 三角分布：Ce=（Cm+Co+Cp）/3 贝塔分布：Ce=（Cm+Co*4+Cp）/6 正负1个西格玛68.5%；正负2个西格玛95.4%；正负3个西格玛99.7% 数据分析 备选方案分析 储备分析–应急储备 用来应对会影响项目的已知-未知风险的部分,随着项目信息越来越明确，可以动用、减少或取消应急储备 小至单个活动，大至整个项目，任何层级都可有其应急储备 质量成本 包括一致性成本和非一致性成本 项目管理信息系统 决策 投票：可以调动团队成员的参与，提高估算的准确性，并提高对估算的责任感 输出（O） 成本估算 可以是汇总的或详细分列的，应覆盖项目所使用的全部资源 如果间接成本也包含在项目估算中，则可在活动层次或更高层次上计列间接成本 估算依据 成本估算所需的支持信息的数量和种类 项目文件更新 假设日志、经验教训登记册、风险登记册制定预算 定义 汇总所有单个活动或工作包的估算成本，建议一个经批准的成本基准的过程 作用 确定可据以监督和控制项目绩效的成本基准 时间点 仅开展一次或在预定义节点开展ITTO 输入（I） 项目管理计划 成本管理计划,资源管理计划,范围基准 项目文件 估算依据,成本估算, 项目进度计划,风险登记册 商业文件 商业文件,效益管理计划 协议：采购协议 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 成本汇总 把成本估算汇总到WBS中的工作包，再由工作包汇总至WBS的更高层次（如控制账户），最终得出整个项目的总成本 数据分析 储备分析–管理储备 针对项目范围中不可预见的工作，用来应对会影响项目的已知-未知风险的部分 管理储备不包括在成本基准中，但属于项目总预算和资金需求的一部分 动用管理储备时，就要把动用的部分增加到成本基准中，从而导致成本基准的变更，走变更控制流程 历史信息审核 有助于参数估算或类比估算 资金限制平衡 如果发现资金限制于计划支出之间的差异，则可能需要调整进度计划，以平衡资金支出水平 融资 输出（O） 成本基准 经过批准的，按时间段分配的项目预算，不包括任何管理储备，只有通过正式的变更控制程序才可变更，用作与实际结果进行比较的依据 项目预算 管理储备 成本基准 控制账户 工作包应急储备 工作包成本估算 活动应急储备 活动成本估算 项目资金需求 包括预计支出和预计债务 项目文件更新 成本估算、项目进度计划、风险登记册控制成本 定义 监督项目状态，以更新项目成本和管理成本基准变更的过程 作用 在整个项目期间保持对成本基准的维护 时间点 整个项目期间开展 备注 重点分析项目资金指出与相应完成工作之间的关系 有效成本控制的关键在于管理经批准的成本基准ITTO 输入（I） 项目管理计划 成本管理计划, 成本基准,绩效测量基准 项目文件 经验教训登记册 项目资金需求 工作绩效数据 组织过程资产 工具与技术（TT） 专家判断 数据分析 挣值分析（EVA） 将实际进度和成本绩效与绩效测量基准进行比较 计划价值（PV） 为计划工作分配的经批准的预算，不包括管理储备 某时间点计划完成（或应该已经完成）的工作的价值 PV的总和为绩效测量基准（PMB） 完工预算(BAC)=项目的总计划价值 挣值（EV） 对已完成工作的测量，用该工作的批准预算来表示 某时间点所有已完成工作的计划价值，与实际成本无关 常用于计算项目完成的百分比，监测EV增量用于判断当前进度状态，也要关注EV的累计值用于判断长期的绩效趋势 EV=已完成工作的计划价值之和 实际成本（AC） 在给定时间段内，因执行项目活动而实际发生的成本 某时间点所有已完成工作的实际成本 偏差分析 成本偏差（CV） 在某个给定时间点，预算亏空或盈余量，表示为挣值与实际成本之差，即CV=EV-AC 大于0：低于计划成本；等于0：按计划成本；小于0：成本超支 成本绩效指数（CPI） 测量预算资源的成本效率的一种指标，表示为挣值与实际成本之比，即CPI=EV/AC 大于1：低于计划成本；等于1：按计划成本；小于1：成本超支 进度偏差（SV） 在某个给定时间点，与计划交付日期相比的亏空或盈余量，表示为挣值于计划价值之差，即SV=EV-PV 大于0：比进度计划提前；等于0：按进度计划进行；小于0：进度滞后 进度绩效指数（SPI） 测量进度效率的一种指标，表示为挣值与计划价值之比。即SPI=EV/PV 大于1：比进度计划提前；等于1：按进度计划进行；小于1：进度滞后 完工偏差（VAC） 对预算亏空量或盈余量的一种预测，是完工预算和完工估算之差，即VAC=BAC-EAC 大于0：低于计划成本；等于0：按计划成本；小于0：成本超支 趋势分析 图表 预测 完工估算（EAC） 完成所有工作所需的预期总成本，等于截至目前的实际成本加上完工尚需估算（ETC） 典型：预期项目剩余部分的CPI不变，则EAC=BAC/CPI 非典型：未来工作将按计划速度（进度/成本）完成，即SPI和CPI都等于1，则EAC=AC+（BAC-EV） 如果进度成本同时作用，则EAC＝AC＋[（BAC-EV）/（CPI*SPI）] 如果最初计划不在有效，则EAC=AC+至下而上的ETC 完工预算（BAC） 为将要执行的工作所建立的全部预算的总和 总计划工作的价值，项目成本的基准 完工尚需估算（ETC） 完成所有剩余项目工作的预计成本 如果未来工作将按计划速度完成，则ETC=BAC-EV 如果最初计划不在有效，则ETC=至下而上的重新估算 储备分析 应急储备 如果已识别的风险没有发生，就可能要从项目预算中扣除未使用的应急储备，为其他项目或运营腾出资源 管理储备 动用管理储备时，就要把动用的部分增加到成本基准中，从而导致成本基准的变更，走变更控制流程 完工尚需绩效指标（TCPI） 为实现特定的管理目标，剩余资源的使用必须达到成本绩效指标，是剩余工作和剩余资金之比 为完成计划必须保持的效率，即TCPI=（BAC-EV）/（BAC-AC） 为完成当前完工估算必须保持的效率，即TCPI=（BAC-EV）/（EAC-AC） 大于1：难以完成；等于1：正好完成；小于1：轻易完成 项目管理信息系统 输出（O） 工作绩效信息 成本预测 变更请求 项目管理计划更新 成本管理计划、成本基准、绩效测量基准 项目文件更新 假设日志、估算依据、成本估算、经验教训登记册、风险登记册","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://www.whoosh.site/categories/读书笔记/"}],"tags":[{"name":"管理类书籍","slug":"管理类书籍","permalink":"http://www.whoosh.site/tags/管理类书籍/"},{"name":"PMP","slug":"PMP","permalink":"http://www.whoosh.site/tags/PMP/"}]},{"title":"项目进度管理","slug":"20180428_项目进度管理","date":"2018-04-28T15:06:28.000Z","updated":"2018-06-18T14:22:22.013Z","comments":true,"path":"2018/04/28/20180428_项目进度管理/","link":"","permalink":"http://www.whoosh.site/2018/04/28/20180428_项目进度管理/","excerpt":"","text":"进度管理 项目进度计划流程： 项目管理团队选择进度计划方法（关键路径法/敏捷法）； 将项目特定数据输入进度编制工具； 创建项目进度模型 具有未完项的迭代型进度计划：基于适应型生命周期的滚动式规划，通常用于向客户交付增量价值，或多个团队并行开发大量内部关联较小的功能 按需进度计划：不依赖于以前为产品或产品增量制定的进度计划，在资源可用时，立即从未完项和工作序列中提取出来，通常用于在运营持续环境中以增量方式研发产品，且任务的规模或范围相对类似规划进度管理 定义 为规划、编制、管理、执行和控制项目进度而制定政策、程序和文档的过程 作用 为如何在整个项目期间管理项目进度提供指南和方向 时间点 仅开展一次或仅在项目的预定义点开展ITTO 输入（I） 项目章程 项目管理计划 范围管理计划 开发方法 有助于定义进度计划方法、估算技术、进度计划编排工具以及用来控制进度的技术 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 数据分析 备选方案分析 会议 输出（O） 进度管理计划 项目进度模型制定 进度计划的发布和迭代长度：指定固定时间的发布时段、阶段和迭代 准确度、计量单位 组织程序链接 WBS为进度管理计划提供了框架 控制临界值 用于监督进度绩效，通常用偏离基准计划中的参数的某个百分数表示 绩效测量规则 确定完成百分比规则 0/100，20/80，50/50等 挣值管理（EVM）技术 基准法、固定公式法、完成百分比法等 进度绩效测量标准 进度偏差（SV）和进度绩效指数（SPI） EVM把范围基准、成本基准和进度基准整合起来，形成绩效测量基准 报告格式定义活动 定义 识别和记录为完成项目可交付成果而须采取的具体行动的过程 作用 将工作包分解为进度活动，作为对项目工作进行进度估算、规划、执行、监督和控制的基础 时间点 整个项目期间开展ITTO 输入（I） 项目管理计划 进度管理计划，范围基准 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 分解 把项目范围和项目可交付成果逐步划分为更小、更便于管理的组成部分 定义活动过程的最终输出是活动而不是可交付成果，可交付成果是指导于管理项目工作过程的输出，范围基准是创建WBS过程的输出。 让团队成员参与分解过程，有助于得到更好、更准确的结果。 滚动式规划 迭代式的规划技术，是一种渐进明细的规划方式 适用于工作包、规划包以及采用敏捷或瀑布式方法的发布规则 详细规划近期要完成的工作、在较高层级粗略规划远期工作 会议 输出（O） 活动清单 项目所需的进度活动，包括每个活动的标识和工作范围详述，对于滚动式或敏捷项目，活动清单要定期更新 活动属性 每项活动所具有的多重属性，用来扩充对活动的描述 里程碑清单 项目中的重要时点或事件，指明每个里程碑是强制性(活动要求)的还是选择性（根据历史信息确定）的 里程碑的持续时间是零，它不是活动 变更请求 项目管理计划更新 进度基准，成本基准排列活动顺序 定义 识别和记录项目活动之间的关系的过程 作用 定义工作之间的逻辑顺序，以便在既定的所有项目制约因素下获得最高的效率 时间点 整个项目期间开展ITTO 输入（I） 项目管理计划 进度管理计划，范围基准 项目文件 活动属性，活动清单，假设日志，里程碑清单 事业环境因素和组织过程资产 工具与技术（TT） 紧前关系绘图法（PDM）：节点法/前导图法/单代号法/AON 用节点表示活动、用一种或多种逻辑关系连接活动，一显示活动的实施顺序 完成到开始（FS）：只有紧前活动完成，紧后活动才能开始 完成到完成（FF）：只有紧前活动完成，紧后活动才能完成 开始到开始（SS）：只有紧前活动开始，紧后活动才能开始 开始到完成（SF）：只有紧前活动开始，紧后活动才能完成，如换班 不建议相同的活动之间存在多种关系，也不建议采用闭环的逻辑关系 确定和整合依赖关系 强制性依赖关系 法律或合同要求的或工作的内在性质决定的依赖关系 往往与客观限制有关 选择性依赖关系 又称首选逻辑关系、优先逻辑关系或软逻辑关系 如果打算快速跟进，则应当审查相应的选择性依赖关系，并考虑是否需要调整或去除 外部依赖关系 项目活动与非项目活动之间的依赖关系，往往不在项目团队的控制范围内 内部依赖关系 项目活动之间的紧前关系，通常在项目团队的控制之中 提前量和滞后量 提前量：相对于紧前活动，紧后活动可以提前的时间量 滞后量：相对于紧前活动，紧后活动必须推迟的时间量 提前量和滞后量的使用不能替代进度逻辑关系，而且持续时间估算中不包括任何提前量或滞后量 项目信息管理系统 输出（O） 项目进度网络图 表示项目活动之间的逻辑关系（依赖关系）的图形 在路径汇聚（多个紧前活动）和路径分支（多个紧后活动）的地方，存在更大的风险 项目文件更新 活动属性，活动清单，假设日志，里程碑清单估算活动时间 定义 根据资源估算的结果，估算完成单项活动所需工作时段数的过程 作用 确定完成每个活动所需花费的时间量 时间点 整个项目期间开展 备注 应该有项目中国最熟悉具体活动的个人或小组提供持续时间估算所需的各种输入 对持续时间的估算应该渐进明细，取决于输入数据的数量和质量 收益递减规律（临界点）、资源数量、技术进步、员工激励（学生综合征和帕金森定律）ITTO 输入（I） 项目管理计划 进度管理计划,范围基准 项目文件 活动属性,活动清单, 假设日志,经验教训登记册,里程碑清单,项目团队派工单,资源分解结构,资源日历，资源需求，风险登记册 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 类比估算 一种使用相似活动或项目的历史数据，来估算当前活动或项目的持续时间或成本的技术，成本较低、耗时较少，但准确性也较低,是至上而下的整体的专家判断 参数估算 一种基于历史数据和项目参数之间的统计关系和其他变量，使用某种算法来计算成本或持续时间的估算技术。准确性取决于参数模型的成熟度和基础数据的可靠性 三点估算 考虑估算中的不确定性和风险，利用最可能时间（Tm），最乐观时间(To)，最悲观时间(Tp)界定活动持续时间的近似区间。 三角分布：t=(Tm+To+Tp)/3 贝塔分布：t=(Tm+To*4+tP)/6 正负1个西格玛68.5%；正负2个西格玛95.4%；正负3个西格玛99.7% 自下而上估算 一种估算项目持续时间或成本的方法，通过自下而上的逐层汇总WBS组成部分的估算而得到项目估算 数据分析 备选方案分析 储备分析 用于确定项目所需的应急储备量和管理储备 应急储备与已知-未知风险相关，用来应对已经主动接受的已识别的风险。随着项目信息越来越明确，可以动用、减少或取消应急储备。 管理储备与未知-未知风险相关，用来应对项目范围中不可预见的工作。使用管理储备可能需要变更进度基准 决策：投票 会议 输出（O） 持续时间估算 对完成某项活动、阶段或项目所需的工作时段数的定量评估，其中不包括任何滞后量，但可指出一定的变动区间 估算依据 持续时间估算所需的支持信息的数量和种类 项目文件更新制定进度计划 定义 分析活动顺序、持续时间、资源需求和进度制约因素，创建进度模型，从而落实项目执行和监控的过程 作用 为完成项目而制定具有计划日期的进度模型 时间点 整个项目期间开展ITTO 输入（I） 项目管理计划 进度管理计划，范围基准 项目文件 活动属性，活动清单，假设日志，估算依据，持续时间估算，经验教训登记册，里程碑清单，项目进度网络图，项目团队派工单，资源日历，资源需求，风险登记册 协议 供应商为项目进度提供在制定如何执行项目工作以履行合同承诺的详细信息 事业环境因素和组织过程资产 工具与技术（TT） 进度网络分析 包含以下技术：关键路径法、资源优化技术、建模技术。 当多个路径在同一时间点汇聚或分叉时，评估汇总进度储备的必要性，以减少出现进度延误的可能性 是一个反复进行的过程，一直持续到创建出可行的进度模型 关键路径法 是项目中时间最长的活动顺序，决定着可能的项目最短工期。最长路径的总浮动时间最少，通常为零 进度活动可以从最早开始日期推迟或拖延的时间，而不至于延误项目完成日期或违反进度制约因素，就是总浮动时间或进度灵活性 总浮动时间可能是正值、负值或零。出现负值说明违反了对最晚日期的制约因素，需要调整活动持续时间（增加资源或缩减范围）、逻辑关系、提前量和滞后量或其他进度制约因素 自由浮动时间是不延误任何紧后活动最早开始日期或不违反进度制约因素的前提下，某进度活动可以推迟的时间量 关键路径法不考虑资源限制，总浮动时间体现进度的灵活性 资源优化 资源平衡 为了在资源需求与资源供给之间取得平衡，根据资源制约因素对开始时间和完成时间进行调整的技术 往往导致初始关键路径改变，用浮动时间平衡资源，避免资源波动范围大的情况 资源平滑 对进度模型中的活动进行调整，从而使项目资源需求不超过预定的资源限制的技术 不会改变项目关键路径，完工日期也不会延迟。活动只在其自由和总浮动时间内延迟，但无法实现所有资源的优化 数据分析 假设情景分析 对各种情景进行评估，预测他们对项目目标的影响 根据分析结果，评估项目进度计划在不同条件下的可行性，以及为应对意外情况的影响而编制进度储备和应对计划 模拟（蒙特卡罗） 把单个项目风险和不确定性的其他来源模型化，以评估他们对项目目标的潜在影响 提前量和滞后量 提前量用于在条件许可的情况下提早开始紧后活动 滞后量是在某些限制条件下，在紧前和紧后活动之间增加一段不需工作或资源的自然时间 进度压缩 在不缩减项目范围前提下，缩短或加快进度工期，以满足进度制约因素、强制日期或其他进度目标 赶工：增加成本，通过增加资源、以最小的成本代价来压缩进度工期的技术 快速跟进： 增加风险，将正常情况下按顺序进行的活动或阶段改为至少部分并行开展 项目管理信息系统 敏捷发布规划 基于项目路线图和产品发展愿景，提供了高度概括的发布进度时间轴，还确定了发布的迭代或冲刺次数 输出（O） 进度基准 经过批准的进度模型，只有通过正式的变更控制程序才能进行变更，用作与实际结果进行对比的依据 项目进度计划 横道图（甘特图） 面向管理层，纵向列表示活动，横向列表示时间，用横条表示活动自开始日期至完成日期的持续时间 里程碑图 面向客户，标出主要可交付成果或关键外部接口的计划开始或完成日期 项目进度网络图 通常用活动节点绘制，没有时间刻度，存粹显示活动及其相互关系，也称纯逻辑图 进度数据 用于描述和控制进度计划的信息集合，至少包括进度里程碑、进度活动、活动属性、以及已知的全部假设条件与制约因素 项目日历 规定可以开展进度活动的可用工作日和工作班次 项目日历是什么时候工作，资源日历是什么时候可用，可用多久 变更请求 修改项目范围或项目进度，可能对范围基准、项目管理计划等提出变更 项目管理计划更新 进度管理计划,成本基准 项目文件更新 活动属性，活动清单，持续时间估算，经验教训登记册，资源需求，风险登记册控制进度 定义 监督项目状态、以更新项目进度和管理进度基准变更的过程 作用 在整个项目期间保持对进度基准的维护 时间点 整个项目期间开展ITTO 输入（I） 项目管理计划 进度管理计划， 进度基准，范围基准，绩效测量基准 项目文件 经验教训登记册，项目日历，项目进度计划，资源日历，进度数据 工作绩效数据 包含关于项目状态的数据 组织过程资产 工具与技术（TT） 数据分析 挣值分析(进度) 进度绩效测量指标用于评价偏离初始进度基准的程度 迭代燃尽图 用于追踪迭代未完成项中尚未完成的工作 绩效审查 根据进度基准，测量、对比和分析进度绩效 趋势分析 检查项目绩效随时间的变化情况，以确定绩效是在改善还是恶化 偏差分析 关注实际开始和完成日期与计划的偏离，实际持续时间与计划的差异，以及浮动时间的偏差 包括确定偏离进度基准的原因和程度，评估这些偏差对未来工作的影响，以及确定是否需要采取纠正措施或预防措施 假设情景分析 关键路径法 项目管理信息系统 资源优化 提前量和滞后量 进度压缩 输出（O） 工作绩效信息 包括与进度基准相比较的项目工作执行情况 进度预测 根据已有的信息和知识，对项目未来的情况和事件进行估算或预计 变更请求 项目管理计划更新 进度管理计划、进度基准、成本基准、绩效测量基准 项目文件更新 假设日志、估算依据、经验教训登记册、项目进度计划、资源日历、风险登记册、进度数据","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://www.whoosh.site/categories/读书笔记/"}],"tags":[{"name":"管理类书籍","slug":"管理类书籍","permalink":"http://www.whoosh.site/tags/管理类书籍/"},{"name":"PMP","slug":"PMP","permalink":"http://www.whoosh.site/tags/PMP/"}]},{"title":"项目范围管理","slug":"20180420_项目范围管理","date":"2018-04-20T03:15:58.000Z","updated":"2018-06-18T10:46:49.672Z","comments":true,"path":"2018/04/20/20180420_项目范围管理/","link":"","permalink":"http://www.whoosh.site/2018/04/20/20180420_项目范围管理/","excerpt":"","text":"范围管理 项目范围管理确保项目做且只做所需的全部工作。 范围包括产品范围（某些产品、服务或成果所具有的特征和功能）和项目范围（为交付具有规定特性与功能的产品、服务或成果而必须完成的工作）。 在适应型或敏捷型生命周期中，每次迭代都会重复开展确认范围和控制范围两个过程。 在预测型生命周期中，经过批准的项目范围说明书、WBS和WBS词典构成范围基准，只有通过正式变更控制程序，才能进行修改。 项目范围的完成情况根据项目管理计划来衡量，产品范围的完成情况根据产品需求来衡量规划范围管理 定义 为了记录如何定义、确认和控制项目范围及产品范围，而创建范围管理计划的过程 作用 在整个项目期间对如何管理范围提供指南和方向 时间点 仅开展一次或仅在预定义节点开展ITTO 输入（I） 项目章程 项目管理计划 质量管理计划 在项目中实施组织的质量政策、方法和标准的方式会影响管理项目和产品范围的方式 项目生命周期描述 定义了项目从开始到完成所经历的一系列阶段 开发方法 定义了项目采用瀑布式、迭代型、适应型、敏捷型还是混合型开发方式 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 数据分析 备选方案分析 用于评估收集需求、描述项目和产品范围、创造产品、确认范围和控制范围的各种方法 会议 输出（O） 范围管理计划 描述将如何定义、制定、监督、控制和确认项目范围 需求管理计划 描述将如何分析、记录和管理项目和产品需求收集需求 定义 为实现目标而确定、记录并管理相关方的需要和需求的过程 作用 为定义产品范围和项目范围奠定基础 时间点 仅开展一次或仅在预定义点开展 备注 需求：根据特定协议或其他强制性规范，产品、服务或成果必须具备的条件或能力。包括发起人、客户和其他相关方的已量化且书面记录的需要和期望ITTO 输入（I） 项目章程 项目管理计划 范围管理计划，需求管理计划，相关方参与计划 项目文件 假设日志，经验教训登记册，相关方登记册 商业文件 商业论证：描述了为满足业务需要应达到的必要、期望及可选标准 协议 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 数据收集 头脑风暴 访谈 焦点小组 召集同职能的相关方和主题专家讨论项目风险、成功标准和其他议题，比访谈有利于交流 问卷调查 适用于受众多样化，需要快速完成调查，受访者地理位置分散，并且适合开展统计分析 标杆对照 将实际或计划的产品，过程和实践，与其他可比组织的实践进行比较，以便识别最佳实践，形成改进意见，并为绩效考核提供依据 可比组织可是内部的，也可以是外部的 数据分析 文件分析：包括审核和评审任何相关的文件信息 决策 投票：原则包括一致同意（德尔菲法）、大多数同意（&gt;50%）、相对多数同意 独裁型决策制订 多标准决策分析 数据表现 亲和图 用来对大量创意进行分组的技术，以便进一步审查和分析 思维导图 把从头脑风暴中获得的创意整合成一张图，反映创意之间的共性和差异，激发新创意 人际关系与团队技能 名义小组技术 向集体提出一个问题或难题 主持人在活动挂图上记录所有人的想法 集体讨论各个想法，直到全体成员达成一个明确的共识 进行多轮投票，个人私下投票决出各种想法的优先排序 观察/交谈 工作跟随，直接观察个人在各自的环境中如何执行工作和实施流程，来体验该流程或程序实施过程，以便挖掘隐藏需求 引导 联合应用设计或开发（JAD） 软件开发行业，把业务主题专家和开发团队集中在一起，以收集需求和改进软件开发过程 质量功能展开（QFD） 制造行业，用于确定新产品的关键特征 用户故事 需求研讨会，对所需的功能的简短文字描述 引导式研讨会用于快速定义跨职能需求并协调相关方的需求差异 系统交互图 对产品范围的可视化描述，显示业务系统及其与人和其他系统之间的交互方式 原型法 使得相关方可以体验最终产品的模型，而不是仅限于讨论抽象的需求描述 原型法有助于减轻返工的风险，其流程：1.创建模型、2.用户体验、3.反馈收集、4.修改原型 输出（O） 需求文件 描述各种单一需求将如何满足项目相关的业务需求，一开始可能只有高层级的需求，然后随着有关需求信息的增加而逐步细化 需求类别：业务需求、相关方需求、解决方案需求（功能需求/非功能需求）、过渡和就绪需求（当前状态到将来状态）、项目需求、质量需求 需求跟踪矩阵 把产品需求从其来源连接到能满足需求的可交付成果的一种表格 提供了在整个项目生命周期中跟踪需求的一种方法，有助于确保需求文件中被批准的每项需求在项目结束的时候都能交付 需求跟踪矩阵还为管理产品范围变更提供了框架。定义范围 定义 制定项目和产品详细的过程 作用 描述产品、服务或成果的边界和验收标准 时间点 经开展一次或在预定义点开展 备注 定义范围从需求文件中选取最终的项目需求，然后制定出关于项目及其产品、服务或成果的详细描述ITTO 输入（I） 项目章程 包含对项目的高层级描述、产品特征和审批要求 项目管理计划 范围管理计划：记录了如何定义、确认和控制范围 项目文件 假设日志 需求文件：识别了应纳入范围的需求 风险登记册 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 数据分析 备选方案分析 决策 多标准决策分析 人际关系与团队技能 引导 产品分析 用于定义产品和服务，把高层级的产品或服务描述转变为有意义的可交付成果 输出（O） 项目范围说明书 对项目范围、主要可交付成果、假设条件和制约因素的描述 包括：产品范围描述（渐进明细），可交付成果，验收标准，项目的除外责任(有助于管理相关方的期望及减少范围蔓延) 项目章程包含高层级的信息，范围说明书则是对范围组成部分的详细描述 项目文件更新 包括：假设日志，需求文件，需求跟踪矩阵，相关方登记册创建WBS 定义 把项目可交付成果和项目工作分解成较小、更易于管理的组件的过程 作用 为所有交付的内容提供架构 时间点 仅开展一次或仅在项目的预定义节点开展 备注 WBS组织并定义了项目的总范围，代表着经批准的当前项目范围说明书所规定的工作 WBS最底层的组成部分是工作包，“工作”是指为活动结果的工作产品或可交付成果，而不是活动本身 规划包：低于控制账户而高于工作包的工作分解结构组件，工作内容已知，但详细的进度活动未知ITTO 输入（I） 项目管理计划 范围管理计划 项目文件 项目范围说明书 需要实施的工作及不包含在项目中的工作 需求文件 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 分解：把项目范围和项目可交付成果逐步划分为更小、更便于管理的组成部分的技术 流程： 识别和分析可交付成果及相关工作 确定WBS的结构和编排方法 自上而下逐层细化分解 为WBS组成部分制定和分配标识编码 核实可交付成果分解的程度是否恰当 不同可交付成果可以分解到不同的层次，可以把主要可交付成果作为分解的第二层,也可以以项目生命周期的各个阶段作为分解的第二层，把产品和项目可交付成果放在第三层 过细的分解或造成管理低效及数据汇总困难，一般按照4~6层，80小时，100%原则和单一责任人或组织原则分解工作包 作为外包工作的一部分，卖方需制定相应的合同WBS 如果采用敏捷方法，可以将长篇故事分解成用户故事（收集需求中提到） 输出（O） 范围基准 经过批准的范围说明书、WBS（控制账户-规划包-工作包）和相应的WBS词典(某个WBS组件的详细范围描述)，只有通过正式的变更控制过程才能进行变更 在控制账户节点，把范围、预算和进度加以整合，并与挣值相比较，以测量绩效 项目文件更新 假设日志, 需求文件确认范围 定义 正式验收已完成的项目可交付成果的过程 作用 使验收过程具有客观性，同时通过每个可交付成果的验收，来提高最终产品、服务或成果获得验收的可能性 时间点 整个项目期间开展 备注 确认范围过程与控制质量过程不同之处在于，前者关注可交付成果的验收，后者关注可交付成果的正确性及是否满足质量要求ITTO 输入（I） 项目管理计划 范围管理计划, 需求管理计划,范围基准 项目文件 经验教训登记册,质量报告,需求文件,需求跟踪矩阵 核实的可交付成果 已经完成、并被控制质量过程检查为正确的可交付成果 工作绩效数据 工具与技术（TT） 检查 开展测量、审查与确认等活动，来判断工作和可交付成果是否符合需求和产品验收标准 决策 投票 输出（O） 验收的可交付成果 由客户或发起人正式签字批准的符合验收标准的可交付成果，最后交给结束项目或阶段过程 工作绩效信息 项目进展信息，即可交付成果的验收情况 变更请求 对已经完成但未通过正式验收的可交付成果及其未通过验收的原因，应该记录在案，之后提交变更请求 项目文件更新 经验教训登记册 需求文件 需求跟踪矩阵 控制范围 定义 监督项目和产品的范围状态，管理范围基准变更的过程 作用 在整个项目期间保持对范围基准的维护 时间点 整个项目期间开展 备注 范围蔓延：未经控制的产品或项目范围的扩大，包括内部的镀金和外部的范围潜变 一旦出现范围蔓延，就必须要走变更控制流程ITTO 输入（I） 项目管理计划 范围管理计划，需求管理计划， 变更管理计划，范围基准 配置管理计划 定义了哪些配置项需要正式变更控制，以及变更控制过程 绩效测量基准 经过整合的项目范围、进度和成本基准 使用挣值分析比较绩效测量基准与实际结果差异，判断是否有必要进行变更、采取纠正措施或预防措施 项目文件 经验教训登记册， 需求文件，需求跟踪矩阵 工作绩效数据 变更请求的收到、接受的数量，核实、确认和完成的可交付成果的数量 组织过程资产 工具与技术（TT） 数据分析 偏差分析 用于将基准与实际结果进行比较，确定偏差是否需要采取纠正或预防措施 趋势分析 审查项目绩效随时间的变化情况，判断绩效是改善还是恶化 输出（O） 工作绩效信息 变更请求 项目管理计划更新 范围管理计划, 范围基准, 进度基准,成本基准,绩效测量基准 项目文件更新 经验教训登记册, 需求文件,需求跟踪矩阵","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://www.whoosh.site/categories/读书笔记/"}],"tags":[{"name":"管理类书籍","slug":"管理类书籍","permalink":"http://www.whoosh.site/tags/管理类书籍/"},{"name":"PMP","slug":"PMP","permalink":"http://www.whoosh.site/tags/PMP/"}]},{"title":"项目整合管理","slug":"20180414_项目整合管理","date":"2018-04-14T13:53:50.000Z","updated":"2018-06-18T10:30:27.572Z","comments":true,"path":"2018/04/14/20180414_项目整合管理/","link":"","permalink":"http://www.whoosh.site/2018/04/14/20180414_项目整合管理/","excerpt":"","text":"整合管理 项目整合管理由项目经理负责，该责任不能被授权或转移，项目经理必须对整个项目承担最终责任。 在整个项目生命周期中积累知识并传达给目标受众，以防止知识流失 项目经理被要求介入启动和结束项目阶段，需要更全面地识别相关方，包括管理项目经理与各职能部门、运营部门和高级管理人员之间的接口。 迭代和敏捷的方法能够促进团队以相关领域专家的身份参与整合管理，项目经理的关注点在于营造一个合作性的决策氛围，并确保团队有能力应对变更。 制定项目章程 定义 编写一份正式批准项目并授权项目经理在项目活动中使用组织资源的文件的过程 作用 明确项目与组织战略之间的直接关系、确立项目的正式地位，并展示组织对项目的承诺 时间点 仅开展一次或仅在项目的预定义点开展 备注 项目章程在项目执行组织（乙方）与需求组织（甲方）之间建立其伙伴关系,通常用正式的合同来达成合作协议 最好在制定项目章程时，最晚也要在规划开始之前就任命项目经理 项目章程一旦被批准，就标志着项目的正式启动 项目由项目以外的机构来启动，如发起人、项目集或项目管理办公室、项目组合治理委员会主席或授权代表 项目启动者或发起人应该具有一定的职权，能为项目获取资金并提供资源 通过编制项目章程，来确认项目符合组织战略和日常运营的需要 ITTO 输入（I） 商业文件：在项目之前制定，但需要定期审核 包含商业需求和成本效益分析，以论证项目的合理性并确定项目边界 商业文件不是项目文件，项目经理不可以对其进行更新或修改，但能提出相关建议 协议 用于定义启动项目的初衷，通常以合同形式出现 事业环境因素和组织过程资产 工具与技术（TT） 专家判断： 具有专业学历、知识、技能、经验或培训经历的任何小组或个人 数据收集 头脑风暴 短时间内获得大量创意，并对创意进行分析，倾向于数量，不注重质量 不质疑、不批判、不反对，可与思维导图结合使用 焦点小组 召集同职能的相关方和主题专家讨论项目风险、成功标准和其他议题，比访谈有利于交流 访谈 通过与相关方直接交谈来了解高层级需求、假设条件、制约因素、审批标准以及其他信息（例如一些机密信息） 人际关系与团队技能 冲突管理 有助于相关方就目标、项目描述、总体里程碑等内容达成一致意见 引导 有效引导团队活动成功以达成决定、解决方案或结论的能力 引导者确保参与者有效参与，相互理解，考虑所有意见，按既定决策流程全力支持得到的结论或结果。 引导式研讨会用于快速定义跨职能需求并协调相关方的需求差异 会议管理 会前：包括准备议程、确保邀请每个关键相关方群体的代表 会中：确保讨论内容切题，避免冲突以及解决冲突 会后：准备和发送会议纪要和行动计划 会议 启动会（initiating meeting）：发布项目章程、任命并授权项目经理，各相关方进行认识、表达决心、调动积极性 输出（O） 项目章程 记录了关于项目和项目预期交付的产品、服务或成果的高层级信息。 包括：项目目的、可测量的项目目标和相关的成功标准、高层级需求、高层级项目描述，边界定义以及主要可交付成果、整体项目风险、总体里程碑进度计划、预先批准的财务资源、关键相关方名单、项目审批要求、项目退出标准、委派的项目经理及其职责和职权等。 假设日志 用于记录整个项目生命周期中所有假设条件和制约因素 高层级的战略和运营假设条件记录在项目章程中 底层级的活动和任务假设条件记录在假设日志中制定项目管理计划 定义 定义、准备和协调项目计划的所有组成部分，并把它们整合为一份综合项目管理计划的过程 作用 生成一份综合文件、用于确定所有项目工作的基础及其执行方式 时间点 仅开展一次或仅在项目的预定义点开展，在规划阶段后期进行整合 备注 项目管理计划应基准化、一旦确定了基准，就只能通过实施整体变更控制过程进行更新 项目管理计划需要通过不断更新来渐进明细，并且这些更新需要得到控制和批准ITTO 输入（I） 项目章程 *初始项目规划的起始点 其他过程的输出 其他规划过程所输出的子计划和基准，以及变更之后对项目管理计划的相应更新 事业环境因素和组织过程资产 工具与技术（TT） 专家诊断 确定项目所需的资源于技能水平 确定哪些项目文件受则于正式的变更控制过程 数据收集 头脑风暴 核对单 指导项目经理制定计划或帮助检查项目管理计划是否包含所需全部信息 焦点小组 访谈 人际关系与团队技能 冲突管理 引导 会议管理 会议 开工会（kick-off meeting）：在规划阶段即将结束时召开，旨在传达项目目标、获得团队对项目的承诺，以及阐明每个相关方的角色和职责 输出（O） 项目管理计划 计划 范围管理计划 需求管理计划 进度管理计划 成本管理计划 资源管理计划 质量管理计划 沟通管理计划 采购管理计划 风险管理计划 相关方管理计划 变更管理计划 在整个项目期间如何正式审批和采纳变更请求。为变更控制过程提供指导，并记录变更控制委员会的角色和职责 配置管理计划 描述项目的配置项、识别应记录和更新的配置项，以保持产品的一致性和有效性 对配置要素（图纸、原型等）的任何变更都应该提出变更请求，并经过正式控制 基准 范围基准 提供项目和产品定义 进度基准 用于评估变更对项目进度的影响 成本基准 用于评估变更对项目成本的影响 绩效测量基准 经过整合的项目范围、进度和成本基准，用作项目执行的比较依据，以测量和管理项目绩效 其他组件 项目生命周期描述 开发方法指导与管理项目工作 定义 为实现项目目标而领导和执行项目管理计划中所确定的工作，并实施已批准的变更的过程 作用 对项目工作和可交付成果开展综合管理，以提高项目成功的可能性 时间点 整个项目期间开展ITTO 输入（I） 项目管理计划的任何组件 项目文件 包括：变更日志、经验教训登记册、里程碑清单、项目沟通记录、需求跟踪矩阵、风险登记册、风险报告 批准的变更请求 实施整体变更控制过程的输出，包括项目经理、变更控制委员会（CCB）审查和批准的变更请求 流程： 作为指导与管理项目工作的输入，输出变更请求 作为实施整体变更控制的输入，输出批准的变更请求 可能继续循环1过程 可能作为控制质量的输入，输出变更请求 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 项目信息管理系统（PMIS） PMIS是事业环境因素的组成部分，系统包括进度计划软件工具、工作授权系统、配置管理系统、信息收集与发布系统，并且自动收集和报告关键绩效指标（KPI）。 会议 输出（O） 可交付成果 是在某一过程、阶段或项目完成时，必须产出的任何独特并可核实的产品、服务或成果。 流程： 指导与管理项目工作输出可交付成果 作为控制质量的输入，输出核实的可交付成果 作为确认范围的输入，输出验收的可交付成果 作为结束项目或阶段的输入，输出最终的产品、服务或成果 工作绩效数据 在执行项目工作的过程中，从每个正在执行的活动中收集到的原始观察结果和测量值，再交由控制过程进一步分析 流程： 指导与管理项目知识输出工作绩效数据 作为除整合外其他子监控过程的输入，输出工作绩效信息 作为整合中的监控项目工作的输入，输出工作绩效报告 用于管理沟通和实施整体变更控制 问题日志 一种记录和跟进所有问题的项目文件，包括类型、提出者、提出时间、描述、优先级、负责人、解决日期、状态等 问题日志可以帮助项目经理有效跟进和管理问题，确保他们得到调查和解决 在整个项目生命周期随同监控活动更新问题日志 变更请求应对措施 纠正措施（纠偏差） 为了使项目工作绩效重新与项目管理计划一致。 预防措施（防风险） 为了确保项目工作的未来绩效符合项目管理计划 缺陷补救（补质量） 为了修正不一致产品或组件的有目的的活动 更新（改基准） 对正式受控的项目文件或计划进行变更 项目管理计划更新 任何变更都要以变更请求的形式提出，且通过组织的变更控制过程进行处理 项目文件更新 包括活动清单，假设日志，经验教训登记册，需求文件，风险登记册，相关方登记册 组织过程资产更新管理项目知识 定义 使用现有知识并生成新知识，以实现项目目标，并帮助组织学习的过程。 作用 利用已有的项目组织知识来创造和改进项目成果，并且使当前项目创造的知识可用于支持组织运营和未来的项目或阶段。 时间点 整个项目期间开展 备注 知识通常分为显性知识和隐性知识ITTO 输入（I） 项目管理计划 项目文件 包括：经验教训登记册,项目团队派工单,资源分解结构,供方选择标准,相关方登记册 可交付成果 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 知识管理 营造一种相互信任的氛围（如：面对面互动），激励人们分享知识或关注他人的知识。 侧重隐性知识，注重合作、分享、集成 信息管理 创造信息并建立人们与信息之间的联系，增加互动要素（如：与我联系） 侧重显性知识 人际关系与团队技能 积极倾听 有助于减少误解并促进沟通和知识分享 引导 有助于指引团队成功地达成决定、解决方案或结论 领导力 有助于沟通愿景并鼓舞项目团队关注合适的知识和知识目标 人际交往 有助于项目相关方之间建立非正式的联系和关系，为显性或隐形的知识分享创造条件 政治意识 有助于项目经理根据项目环境和组织的政治环境规划沟通 输出（O） 经验教训登记册 包括情况的类别、描述、相关影响、建议和行动方案等，还可以记录遇到的挑战、问题、意识到的风险和机会，以及其他适用的内容 项目管理计划更新 组织过程资产监控项目工作 定义 跟踪、审查和报告整体项目进展，以实现项目管理计划中确定的绩效目标的过程 作用 让相关方了解项目的当前状态并认可为处理绩效问题而采取的行动，以及通过成本和进度预测，让相关方了解项目状态 时间点 整个项目期间开展ITTO 输入（I） 项目管理计划 项目文件 包括：假设日志,估算依据,成本预测,问题日志,经验教训登记册,里程碑清单,质量报告,风险登记册,风险报告,进度预测 工作绩效信息 把执行过程中收集的工作绩效数据，交由控制过程做进一步分析，对比项目的实际绩效与项目管理计划的差异 协议 包括采购协议在内的所有协议都要符合项目的特定要求，以及组织的采购政策 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 数据分析 备选方案分析 用于在出现偏差时选择要执行的纠正措施或纠正措施和预防措施组合 成本效益分析 有助于在项目出现偏差时确定最节约成本的纠正措施 挣值分析 对范围、进度和成本进行综合分析 根本原因分析 识别问题的主要原因，以及出现偏差的原因和为达成项目目标需要关注的领域 趋势分析 根据以往结果预测未来绩效，根据分析结果提出必要的预防措施建议 偏差分析 审查目标绩效与实际绩效之间的差异，涉及持续时间估算、成本估算、资源使用、资源费率、技术绩效和其他测量指标 决策 常见投票的形式，原则包括一致同意（德尔菲法）、大多数同意（&gt;50%）、相对多数同意 会议 输出（O） 工作绩效报告 包含挣值图表和信息、趋势线和预测、储备燃尽图、缺陷直方图、合同绩效信息和风险情况概述，可以用实体或者电子形式加以合并、记录和分发。 变更请求 纠正措施、预防措施、缺陷补救 项目管理计划更新 项目文件更新 成本预测,问题日志,经验教训登记册,风险登记册,进度预测实施整体变更控制 定义 审查所有变更请求、批准变更，管理对可交付成果、项目文件和项目管理计划的变更，并对变更处理结果进行沟通的过程 作用 确保对项目中已记录在案的变更做综合评审。即审查对项目文件、可交付成果或项目管理计划的所有变更请求，并确定变更请求的处置方案 时间点 整个项目期间 备注 参与项目的任何相关方都可以提出变更请求，可以口头提出，但所有变更请求都必须以书面形式记录 需要了解变更对进度和成本的影响 每项记录在案的变更请求都必须由一位责任人批准、推迟或拒绝 在基准确定之前，变更无需正式受控与实施整体变更控制过程，一旦确定了项目基准，就必须按照实施整体变更控制过程来处理变更请求ITTO 输入（I） 项目管理计划 变更管理计划 为变更控制过程提供指导，并记录变更控制委员会的角色和职责 配置管理计划 范围基准 进度基准 成本基准 项目文件 估算依据 用于计算变更对时间、预算和资源的影响 需求跟踪矩阵 有助于评估变更对项目范围的影响 风险报告 提供了与变更请求有关的整体和单个项目风险的来源信息 工作绩效报告 资源可用情况、进度和成本数据、挣值报告、燃尽图 变更请求 事业环境因素和组织过程资产 工具与技术（TT） 专家判断 变更控制工具 配置管理活动 识别配置项 记录并报告配置项状态 进行配置项核实和登记 变更管理活动 流程:1记录、2评估、3提交、4更新、5通知 记录：可以口头提出请求，但一定要项目经理书面记录，或要求变更提出者提交书面的变更请求 评估：充分了解变更， 评估变更带来的影响；与相关方沟通评估出的影响。 批准：提交责任人审批；是指项目经理将变更请求和评估的结果提交给CCB。 更新：不管变更通过还是不通过，必须更新变更日志；如果变更通过，更新项目管理计划（文件） 通知：应将变更的结果通知相关方（受影响） 如问变更的依据：则优先选择题目涉及的知识领域对应的管理计划，次选变更管理计划 如问变更的流程：则优先选择实施整体变更流程，次选以上的5步骤 变更请求批准人：优选项目管理计划或组织中指定的责任人，次选CCB，再选PMO、发起人、项目经理 数据分析 备选方案分析 成本效益分析 决策 投票 常见投票的形式，原则包括一致同意、大多数同意（德尔菲法）、相对多数统一 独裁型决策制定 由一个人负责为整个集体制定决策 多标准决策分析 根据一系列定义的准则，用系统分析方法评估变更请求 会议 变更控制会 输出（O） 批准的变更请求 对于批准的变更请求应通过指导与管理项目过程加以实施，对于推迟或否决的变更请求，应通知提出变更请求的个人或小组 项目管理计划更新 对基准的变更，只能基于最新版本的基准且针对将来的情况，而不能变更以往的绩效 项目文件更新 以项目文件更新的形式，在变更日志中记录所有的变更请求和处理情况 结束项目或阶段 定义 终结项目、阶段或合同的所有活动过程 作用 存档项目或阶段信息，完成计划的工作，释放组织团队资源已开展新的工作 时间点 经开展一次或仅在项目预定义点开展 备注 项目正常收尾的流程 获得项目验收 移交可交付成果 客户满意度调查 总结经验教训 更新组织过程资产 文件归档 庆功会 释放资源 如果项目在完工前提前终止 制定程序，调查和记录提前终止的原因 在正式的收尾文件中说明终止的原因 把已完成和未完成的可交付成果移交他人 把历史信息和经验教训信息存入经验教训知识库ITTO 输入（I） 项目章程 项目管理计划 项目文件 确保所有的项目文件和可交付成果都是最新版本 验收的可交付成果 包括批准的产品规范、交货收据和工作绩效文件 商业文件 商业论证，用于确定是否达到了经济可行性研究的预期结果 效益管理计划，用于测量是否达到了计划的效益 协议 采购文档 组织过程资产 工具与技术（TT） 专家判断 数据分析 文件分析 有助于总结经验教训和分享知识，以改进未来的项目和组织资产 回归分析 作用于项目结果的不同项目变量之间的相互关系，以提高未来项目的绩效 趋势分析 用于确认组织所用模式的有效性，以调整未来项目的模式 偏差分析 通过比较最初的计划目标与最终结果来改进组织的测量指标 会议 收尾报告会、客户总结会、经验教训总结会、庆祝会 输出（O） 项目文件更新 经验教训登记册 最终产品、服务或成果移交 把项目交付的最终产品、服务和成果从一个团队转移到另一个团队 最终报告 组织过程资产更新 包括项目文件，运营和支持文件，项目或阶段收尾文件，经验教训知识库 项目或阶段收尾文件表明项目或阶段完工的文件，用来将完成的项目或阶段的可交付成果移交给他人的正式文件","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://www.whoosh.site/categories/读书笔记/"}],"tags":[{"name":"管理类书籍","slug":"管理类书籍","permalink":"http://www.whoosh.site/tags/管理类书籍/"},{"name":"PMP","slug":"PMP","permalink":"http://www.whoosh.site/tags/PMP/"}]},{"title":"项目管理概念","slug":"20180406_项目管理概念","date":"2018-04-06T13:13:58.000Z","updated":"2018-06-18T07:13:19.295Z","comments":true,"path":"2018/04/06/20180406_项目管理概念/","link":"","permalink":"http://www.whoosh.site/2018/04/06/20180406_项目管理概念/","excerpt":"","text":"引论项目 项目是为创造独特的产品、服务或成果而进行的临时性工作。是组织创造价值和效益的主要方式。 12345678910111213独特的产品、服务或成果* 开展项目的目的是为了通过`可交付成果`达成`目标`,* 可交付成果:在某一个过程、阶段或者项目完成时，必须产出的任何独特并`可核实的` 产品、成果或服务能力，可以是有形的，也可以是无形的。* 目标：工作所指向的结果，例如：战略地位、目的、成果、产品或服务等。* 项目的独特性带来不确定性（风险）临时性工作* 项目有明确的起点和终点，并不意味着项目的持续时间短。* 可交付成果可能会在项目终止后依然存在，不具备临时性渐进明细* 项目是一个渐进明细的过程，通过滚动式规划实现 项目驱动组织进行变更 推动组织从一个状态转到另一个状态，从而达成特定目标。 项目创造商业价值 特定项目成果能够为相关方带来收益，收益可以是有形的、无形的或者二者皆有。 项目启动背景 符合法规、法律或社会需求；满足相关方的要求或需求；执行、变更业务或技术战略；创造、改进或修复产品、过程或服务。 项目管理的重要性 项目管理：将知识、技能与技术应用到项目活动中，以满足项目的要求。可以使组织能够有效且高效的开展项目。 项目是组织创造价值和效益的主要方式。 有效和高效的项目管理，使组织能够： 将项目成果与业务目标联系起来； 更有效地展开市场竞争； 支持组织发展； 通过适当调整项目管理计划，以应对商业环境改变给项目带来的影响。 项目、项目集、项目组合 项目的三种模式：独立项目、在项目集内、在项目组合内。 项目集：是一组相互关联且被协调管理的项目、子项目集和项目集活动，以便获得分别管理所无法获得的利益。项目集不是大型项目，注重项目与项目之间、项目与项目集之间的依赖关系。 项目组合：是为实现战略目标而组合在一起管理的项目、项目集、子项目组合和运营工作。项目组合中的项目集或项目不一定彼此依赖或直接相关 项目管理和项目集的重点在于以正确的方式开展项目集和项目。 项目组合管理的重点在于开展正确的项目集和项目。 三者之间的区别： 组织级项目管理（OPM）和战略：为实现战略目标而整合项目组合、项目集和项目管理与组织驱动因素的框架。旨在确保组织开展正确的项目并合适地分配关键资源。 运营管理：关注产品的持续生产和（或）服务的持续运作，是一个持续的、重复的风险几乎为零的过程。 在每个交叉点，可交付成果即知识在项目与运营之间转移，已完成工作交接。 项目往往来自于运营，又服务运营。 项目生命周期 项目生命周期：项目从启动到完成、开始到结束所经历的一些列阶段，通用生命周期包括：开始项目、组织与准备、执行项目工作、结束项目。 成本与人力投入：项目开始时缓慢增加，在执行工作期间达到最高，项目快结束时迅速回落 风险与不确定性、相关方的影响力、变更的数量：项目开始时最大，后续逐步降低；变更的代价、风险的影响：项目开始时较小，后续显著增高。 项目生命周期：预测型或适应型 开发生命周期：预测型、迭代型、增量型、适应型或混合型 生命周期 描述 预测型 在生命周期的早期阶段确定项目范围、时间和成本。对任何范围的变更都要进行仔细管理。预测型生命周期也称为瀑布型生命周期，是计划驱动的。充分了解产品,厚实的行业实践基础,整批一次性交付有利于相关方 迭代型 在生命周期的早期确定，但时间及成本估算将随着项目团队对产品理解的不断深入而定期修改。迭代方法是通过一系列重复的循环活动来开发产品。不断变化目标和范围,需降低项目复杂性(大型复杂),部分交付有利于相关方 增量型 通过在预定的时间区间内渐进增加产品功能的一系列迭代来产出可交付成果。只有在最后一次迭代之后，可交付成果具有了必要和足够的能力，才能被视为完整的。增量方法是渐进地增加产品的功能 适应型 详细范围在迭代开始之前就得到了定义和批准。适应型生命周期也称为敏捷或变更驱动型生命周期。需应对快速变化的环境,需求和范围难以事先确定,较小增量改进有利于相关方 混合型 充分了解或有确定需求的项目要素遵循预测型开发生命周期，而仍在发展中的要素遵循适应型开发生命周期，是预测型生命周期和适应型生命周期的组合。 项目阶段：一组具有逻辑关系的项目活动的集合，项目可以分解为不同的阶段或子组件，包括阶段的准入标准和退出标准 项目关口：设在阶段结束点，也被称为阶段审查、关键决策点和阶段入口或阶段出口、生死点、里程碑等。 项目管理过程：通过合适的项目管理工具和技术将一个或多个输入转化成一个或多个输出。一个过程的输出通常成为另一个过程的输入，也可能成为项目或项目阶段的可交付成果。 过程通常分为三类： 123&gt; 仅开展一次或仅在项目预定义点开展的过程（例如制定项目章程以及结束项目或阶段）&gt; 根据需要定期开展的过程（在需要资源时执行获取资源。在需要采购之前执行实施采购）&gt; 贯穿项目始终执行的过程（从项目开始到项目结束需要持续开展许多监控过程） 五大过程组： 名称 描述 启动过程组 定义一个新项目或现有项目的一个新阶段，授权开始该项目或阶段的一组过程 规划过程组 明确项目范围，优化目标，为实现目标制定行动方案的一组过程 执行过程组 完成项目管理计划中确定的工作，以满足项目要求的一组过程 监控过程组 跟踪、审查和调整项目进展与绩效，识别必要的计划变更并启动相应变更的一组过程 收尾过程组 正式完成或结束项目、阶段或合同所执行的过程 十大知识领域： 名称 描述 整合管理 识别、定义、组合、统一和协调个项目过程组的各个过程和活动而开展的过程与活动 范围管理 确保项目做且只做所需的全部工作，已成功完成项目的各个过程 进度管理 为管理项目按时完成所需的各个过程 成本管理 为项目在批准的预算内完成而对成本进行规划、估算、预算、融资、筹资、管理和控制的各个过程 质量管理 把组织的质量政策应用于规划、管理、控制项目和产品质量要求，以满足相关方的期望的各个过程 资源管理 识别、获取和管理所需资源以成功完成项目的各个过程 沟通管理 为确保项目信息及时且恰当地规划、收集、生成、发布、存储、检索、管理、控制、监督和最终处置所需的各个过程 风险管理 规划风险管理、识别风险、开展风险分析、规划风险应对、实施风险应对和 监督风险的各个过程。 采购管理 从项目团队外部采购或获取所需产品、服务或成功的各个过程 相关方管理 识别影响或受项目影响的人员、团队或组织，分析相关方对项目的期望和影响，制定合适的管理策略来有效调动相关方参与项目决策和执行 五大过程组和十大知识领域 知识领域 启动过程组 规划过程组 执行过程组 监控过程组 收尾过程组 整合管理 制定项目章程 制定项目管理计划 指导与管理项目工作、管理项目知识 监控项目管理工作、实施整体变更控制 结束项目或阶段 范围管理 规划范围管理、收集需求、定义范围、创建WBS 确认范围、控制范围 进度管理 规划进度管理、定义活动、估算活动时间、排列活动顺序、制定项目进度计划 控制进度 成本管理 规划成本管理、估算成本、制定预算 控制成本 质量管理 规划质量管理 管理质量 控制质量 资源管理 规划资源管理、估算活动资源 获取资源、建设团队、管理团队 控制资源 沟通管理 规划沟通管理 管理沟通 监督沟通 风险管理 规划风险管理、识别风险、实施定性风险分析、实施定量风险分析、规划风险应对 实施风险应对 监督风险 采购管理 规划采购管理 管理采购 控制采购 相关方管理 识别相关方 规划相关方管理 管理相关方参与 监督相关方参与 工作绩效数据、工作绩效信息和工作绩效报告 工作绩效数据：在执行过程组收集到的原始观察结果和测量值（反映项目当前情况（范、进、成）的第一手、基础的数据） 工作绩效信息：在各子监控过程中进行整合分析得到的绩效数据（工作绩效数据和基准计划对比后的偏差结果） 工作绩效报告：在整合管理的监控过程中汇编工作绩效信息形成的文件（可真实提交给干系人，能全面反映项目情况的真实文件），用于管理沟通过程。 项目管理商业文件 项目商业论证：文档化的可行性研究报告，列出了项目启动的目标和理由，有助于在项目结束时根据项目目标衡量项目是否成功。 项目效益管理计划：为发起组织和项目预期受益方创造价值的行动、行为、产品、服务或成果的结果。描述了项目实现效益的方式和时间，以及应制定的效益衡量机制。 项目成功标准 完成项目效益管理计划 达到商业论证中记录的已商定的财务测量指标 完成组织从当前状态转到将来状态 达到组织战略、目的和目标 使相关方满意 项目运行环境事业环境因素 事业环境因素是指项目团队不能控制的，将对项目产生影响、限制或指令作用的各种条件，这些条件可能来源于组织内部也可能来源于组织外部。 1234&gt; 组织内部因素：组织文化、结构和治理；设施和资源的地理分布； 基础设施；`信息技术软件(PMIS)`；资源可用性；`员工能力`等。&gt; 组织外部因素：市场条件、社会和文化影响与问题；`法律限制`； `商业数据库`；学术研究；政府或行业标准；财务考虑因素；物理环境要素等。 组织过程资产 组织过程资产是执行组织所特有并使用的计划、过程、政策、程序和知识库，会影响对具体项目的管理。组织过程资产包括过程、政策和程序和组织知识库两大类。 123&gt; 过程、政策和程序：包括但不限于启动和规划、执行和监控、收尾的流程与程序&gt; 组织项目库：包括但不限于配置管理知识库、`财务数据库`、历史信息与经验教训知识库、 问题与缺陷管理数据库、测量指标数据库以及以往项目的项目档案等。 组织系统 组织系统因素包括管理要素、治理框架和组织结构类型。 管理要素：组织内部关键职能部门或一般管理原则的组成部分。 组织治理框架：治理是在组织内部行使职权的框架，包括但不限于规则、政策、程序、规范、关系、系统、过程。会影响到组织目标的设定和实现方式、风险监控和评估方式、绩效优化方式。 组织结构类型：主要是职能型-弱矩阵型-平衡矩阵型-前矩阵型-项目型（权力由小到大，以平衡矩阵型为关注点），另外还有系统型或简单型、多部门、项目导向、虚拟、混合等。 项目管理办公室（PMO）：是对与项目相关的治理过程进行标准化，并促进资源、方法论、工具和技术共享的一个组织结构。主要职能通过各种方式向项目经理提供支持。 支持型：文档支持。是顾问、项目资源库，对项目控制程度很低 控制型：支持+要求服从，对项目控制程度中等 指令型：直接管理和控制，对项目控制程度很高 项目经理的角色项目经理的定义 项目经理–。专注项目目标的达成。由执行组织委派，领导团队实现项目目标的个人。 职能经理–专注某个职能领域或业务部门的管理监督 运营经理–专注业务运营的高效性 项目经理的影响力范围 项目经理的影响力范围：项目、组织、行业、专业学科、跨领域 项目经理的胜任力 PMI人才三角：技术项目管理、领导力、战略和商务管理 技术项目管理：有效运用项目管理知识实现项目集或项目的预期成果的能力 领导力：包括指导、激励和带领团队的能力 战略和商务管理技能：纵览组织概况并有效协商和执行有利于战略调整和创新的决策和行动的能力 权力 权力种类 权力来源 好坏顺序 对谁有效 专家权力 来自于项目经理个人具有的某些技能或技术专长 最好 与本专业相关者 参照权力（潜示权力） 来自于项目经理个人吸引他人并建立起他人对自己的忠诚度的能力 较好 任何人 奖励权力 来自于项目经理职位通过给予他人有价值的物质奖励的能力 较好 下属 正式权力（法定权力） 来自于项目经理职位和职务所拥有的权力 一般 下属 惩罚权力 来自于项目经理职位通过使用或威胁使用惩罚手段来影响他人的能力 不好（慎用） 下属 领导力风格 放任型：无为而治，允许团队自主决策和设定目标 交易性：关注目标、反馈和成就以确定奖励，例外管理 服务型：服务优先于领导，关注他人的成长、学习、发展、人际关系、团体与合作 变更型：通过理想化特质和行为、鼓舞性激励、促进创新和创造，以及个人关怀提高追随者能力 魅力型：精神饱满、热情洋溢、充满自信、说服力强、能够激励他人 交互型：结合了交易型、变更型和魅力型的特点。 执行整合 执行项目整合时，项目经理承担双重角色： 与项目发起人携手合作，既要了解战略目标并确保项目目标和成果与项目组合、项目集以及业务领域保持一致。项目经理以这种方式有助于项目的整合与执行。 在项目层面上，项目经理负责指导团队关注真正重要的事务并协同工作。为此，项目经理需要整合过程、知识和人员。 整合的层面：过程层面、认知层面、背景层面 执行整合 内容 过程层面 项目经理整合相互作用的项目过程，在整个项目期间实施整体变更控制过程是为了整合变更请求。 认知层面 项目经理应尽量掌握所有项目管理知识领域。熟练掌握这些知识领域之后，项目经理可以将经验、见解、领导力、技术以及商业管理技能运用到项目管理中。 背景层面 项目经理需要意识到项目背景和一些新因素（新技术、社交网络、多元文化、新价值观等），然后项目经理可以决定如何在项目中最好地利用这些新环境因素，以获得项目成功。 整合与复杂性：项目的复杂性来源于组织的系统行为、人类行为以及模糊性。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://www.whoosh.site/categories/读书笔记/"}],"tags":[{"name":"管理类书籍","slug":"管理类书籍","permalink":"http://www.whoosh.site/tags/管理类书籍/"},{"name":"PMP","slug":"PMP","permalink":"http://www.whoosh.site/tags/PMP/"}]},{"title":"PDCharts局部放电图谱库","slug":"20180318_PDCharts局部放电图谱库","date":"2018-03-18T13:13:58.000Z","updated":"2018-03-20T14:13:38.383Z","comments":true,"path":"2018/03/18/20180318_PDCharts局部放电图谱库/","link":"","permalink":"http://www.whoosh.site/2018/03/18/20180318_PDCharts局部放电图谱库/","excerpt":"","text":"概述PDCharts是为满足业务需求在Echarts基础上进行二次封装的图谱库。 &emsp;&emsp;ECharts，一个纯 Javascript 的图表库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖轻量级的 Canvas 类库 ZRender，提供直观，生动，可交互，可高度个性化定制的数据可视化图表。 PDcharts目前支持以下图谱： AE：幅值图谱、时域波形图谱、相位图谱、飞行图谱； UHF/HFCT：PRPS二维图谱、PRPS三维图谱、PRPD二维图谱、PRPD三维图谱、周期图谱； 红外：温度矩阵图谱； 铁芯接地：接地电流图谱； 机械特性：电机电流曲线、原始电流曲线、线圈电流曲线、扭矩曲线、振动信号曲线、振动频率信号曲线、行程曲线、开关量曲线 项目地址：https://github.com/zhangzqiang/pdcharts 使用说明由于pdcharts.js依赖于echarts.js，在使用时，需要在HTML页面中引入echarts.js，另外，如果需要用到PRPS三维图谱或者PRPD三维图谱，还需要引入echarts-gl.js\u001c，点击这里下载echarts。 123&lt;script type=\"text/javascript\" src=\"echarts.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"echarts-gl.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"pdcharts.js\"&gt;&lt;/script&gt; PDCharts对外提供图谱类型对象chartType、绘图方法draw(targetEl, opts)和更新图谱配置updateOption(chart, opts)，下面具体介绍使用方法。 &gt; chartType获取pdcharts支持的图谱类型： 1var chartType = pdcharts.chartType; AE：amplitude,wave,phase,fly UHF/HFCT：prps2d,prps3d,prpd2d,prpd3d,cycle,prpsd 铁芯接地：earthcurrent 红外：infrared 机械特性：mech,switches &emsp;&emsp;注:prpsd用于云诊断或报告中的三维PRPS或者PRPD图谱；switches用于开关量图谱，且图谱数据无需进行偏移处理。 &gt; draw(targetEl, opts)draw()是在目标Div中\u001d根据一些配置参数进行图谱绘制的方法，其中engine、type、data为必选配置项，width、height为可选配置项。 engine：当前采用哪种绘图引擎，目前仅支持echarts，后期添加canves，svg type：图谱类型，参见 chartType data：图谱数据，不同图谱类型数据结构不同，具体参见数据结构说明 width：图谱宽度，如果没有配置，则默认为当前浏览器的宽度。 height：图谱高度，如果没有配置，则默认为当前浏览器的高度。 cover：图谱显示方式，false为居中显示，true为平铺显示。默认为false。 12345678910111213141516171819202122232425262728293031323334353637383940var targetEl=document.getElementById('amplitude');var chartBody=&#123; title: \"AE幅值图谱\", axisInfo: &#123; valDesc: \"测量值\", valColor: \"#1BA261\", bgValDesc: \"背景值\", bgColor: \"#DD5044\", unit: \"mV\", frequecy: 50 &#125;, series: [&#123; name: \"有效值\", min: -1, max: 10, dataList: [0.2, 1.2] &#125;, &#123; name: \"周期最大值\", min: 0, max: 20, dataList: [0.4, 7.5] &#125;, &#123; name: \"频率成份1\", min: 0, max: 2, dataList: [0, 0.2] &#125;, &#123; name: \"频率成份2\", min: 0, max: 2, dataList: [0, 0.2] &#125;]&#125;pdcharts.draw(targetEl, &#123; engine: echarts, type: chartType.amplitude, data: chartBody, width: 360, height: 320&#125;); &emsp;&emsp;注:当调整targetEl的宽度或者高度，图谱会进行自适应（prpsd图谱除外）。 &gt; updateOption(chart, opts)考虑到默认的图谱配置项有可能无法满足具体业务需求，提供updateOption()对图谱进行个性化的设计。其中opts需要满足Echarts提供配置项结构。 123456789101112var chart=pdcharts.draw(targetEl, &#123; engine: echarts, type: chartType.amplitude, data: chartBody, width: 360, height: 320&#125;);pdcharts.updateOption(chart,&#123; title:&#123; text:'自定义标头' &#125;,&#125;) &emsp;&emsp;注:prpsd图谱除外。 数据结构说明 幅值(amplitude)图谱数据结构 title：图谱标头 axisInfo：坐标信息 axisInfo.valDesc：测量值描述 axisInfo.valColor：测量值对应颜色，默认值：#1BA261 axisInfo.bgValDesc：背景值描述 axisInfo.bgColor：背景值对应颜色，默认值：#DD5044 axisInfo.unit：单位，默认值：mV axisInfo.frequecy：电网频率，默认值：50 series：系列列表，包括有效值、周期最大值、频率成份1、频率成份2 series.name：系列名称，例如：有效值 series.min：系列最小值 series.max：系列最大值 series.dataList：[背景值,测量值] 12345678910111213141516chartBody: &#123; title: '', axisInfo: &#123; valDesc: '', valColor: '#1BA261', bgValDesc: '', bgColor: '#DD5044', unit: 'mV', frequecy: 50 &#125;, series: [&#123; name: '', min: 0, max: 0, dataList: [0, 0] &#125;,……] 图列： 时域波形(wave)图谱数据结构 title：图谱标头 axisInfo：坐标信息 axisInfo.xDesc：X轴描述，周期 axisInfo.xRangeMax：X轴范围，最大值 axisInfo.xRangeMin：X轴范围，最小值 axisInfo.xUnit：X轴单位，默认值：T axisInfo.yDesc：Y轴描述，幅值 axisInfo.yRangeMax：Y轴范围，最大值 axisInfo.yRangeMin：Y轴范围，最小值 axisInfo.yUnit：Y轴单位，默认值：mV trigger：触发线 trigger.desc：触发值描述 trigger.value：触发值 trigger.color：触发线颜色，默认值：#ff00ff series：系列列表 series.color：波形线颜色，默认值：_#ff0000 series.dataList：[[周期值,幅值],……] 12345678910111213141516171819202122chartBody: &#123; title: '', axisInfo: &#123; xDesc: '', xRangeMax: 0, xRangeMin: 0, xUnit: 'T', yDesc: '', yRangeMax: 0, yRangeMin: 0, yUnit: 'mV', &#125;, trigger: &#123; desc: '', value: 0, color: '#ff00ff' &#125;, series: [&#123; color: '#ff0000', dataList: [[0,0],……], &#125;]&#125; 图列： 相位(phase)图谱数据结构 title：图谱标头 axisInfo：坐标信息 axisInfo.xDesc：X轴描述，相位 axisInfo.xRangeMax：X轴范围，默认值：360 axisInfo.xRangeMin：X轴范围，默认值：0 axisInfo.xUnit：X轴单位，默认值：° axisInfo.yDesc：Y轴描述，幅值 axisInfo.yRangeMax：Y轴范围，最大值 axisInfo.yRangeMin：Y轴范围，最小值 axisInfo.yUnit：Y轴单位，默认值：mV axisInfo.zDesc：Z轴描述，脉冲个数 axisInfo.zRangeMax：Z轴范围，默认值：64 axisInfo.zRangeMin：Z轴范围，默认值：0 axisInfo.zUnit：Y轴单位，默认值：空 trigger：触发线 trigger.desc：触发值描述 trigger.value：触发值 trigger.color：触发线颜色，默认值：#ff00ff series：系列列表 series.color：数据点颜色系，如果不配置或者值为空，数据点颜色则按照数据集合中的颜色显示，默认值：tlb series.dataList：[[相位值,幅值,脉冲个数,数据点颜色],……]，其中数据点颜色可选 1234567891011121314151617181920212223242526chartBody: &#123; title: '', axisInfo: &#123; xDesc: '', xRangeMax: 360, xRangeMin: 0, xUnit: '°', yDesc: '', yRangeMax: 0, yRangeMin: 0, yUnit: 'mV', zDesc: '', zRangeMax: 64, zRangeMin: 0, zUnit: '', &#125;, trigger: &#123; desc: '', value: 0, color: '#ff00ff' &#125;, series: [&#123; colors: 'tlb', dataList: [[0,0,0,'#ff0000'],……], &#125;]&#125; 图列： 飞行(fly)图谱数据结构 title：图谱标头 axisInfo：坐标信息 axisInfo.xDesc：X轴描述，时间间隔 axisInfo.xRangeMax：X轴范围，最大值 axisInfo.xRangeMin：X轴范围，最小值 axisInfo.xUnit：X轴单位，默认值：ms axisInfo.yDesc：Y轴描述，幅值 axisInfo.yRangeMax：Y轴范围，最大值 axisInfo.yRangeMin：Y轴范围，最小值 axisInfo.yUnit：Y轴单位，默认值：mV axisInfo.zDesc：Z轴描述，脉冲个数 axisInfo.zRangeMax：Z轴范围，默认值：64 axisInfo.zRangeMin：Z轴范围，默认值：0 axisInfo.zUnit：Y轴单位，默认值：空 trigger：触发线 trigger.desc：触发值描述 trigger.value：触发值 trigger.color：触发线颜色，默认值：#ff00ff series：系列列表 series.color：数据点颜色系，如果不配置或者值为空，数据点颜色则按照数据集合中的颜色显示，默认值：tlb series.dataList：[[时间间隔,幅值,脉冲个数,数据点颜色],……]，其中数据点颜色可选 1234567891011121314151617181920212223242526chartBody: &#123; title: '', axisInfo: &#123; xDesc: '', xRangeMax: 360, xRangeMin: 0, xUnit: '°', yDesc: '', yRangeMax: 0, yRangeMin: 0, yUnit: 'mV', zDesc: '', zRangeMax: 64, zRangeMin: 0, zUnit: '', &#125;, trigger: &#123; desc: '', value: 0, color: '#ff00ff' &#125;, series: [&#123; colors: 'blaze', dataList: [[0,0,0,'#ff0000'],……], &#125;]&#125; 图列： PRPS图谱数据结构 title：图谱标头 axisInfo：坐标信息 axisInfo.xDesc：X轴描述，相位 axisInfo.xRangeMax：X轴范围，默认值：360 axisInfo.xRangeMin：X轴范围，默认值：0 axisInfo.xUnit：X轴单位，默认值：° axisInfo.yDesc：Y轴描述，周期 axisInfo.yRangeMax：Y轴范围，默认值：50 axisInfo.yRangeMin：Y轴范围，默认值：0 axisInfo.yUnit：Y轴单位，默认值：T axisInfo.zDesc：Z轴描述，幅值 axisInfo.zRangeMax：Z轴范围，最大值 axisInfo.zRangeMin：Z轴范围，最小值 axisInfo.zUnit：Y轴单位，默认值：mV axisInfo.phaseShift：相位偏移值，默认值：xRangeMin axisInfo.zRange：Z轴显示范围，默认值：[zRangeMin, zRangeMax] series：系列列表 series.color：数据点颜色系，如果不配置或者值为空，数据点颜色则按照数据集合中的颜色显示，默认值：blaze series.dataList：[[时间间隔,幅值,脉冲个数,数据点颜色],……]，其中数据点颜色可选 1234567891011121314151617181920212223chartBody: &#123; title: '', axisInfo: &#123; xDesc: '', xRangeMax: 360, xRangeMin: 0, xUnit: '°', yDesc: '', yRangeMax: 50, yRangeMin: 0, yUnit: 'T', zDesc: '', zRangeMax: 64, zRangeMin: 0, zUnit: 'mV', phaseShift: 0, zRange: [0, 64] &#125;, series: [&#123; colors: 'blaze', dataList: [[0,0,0],……], &#125;]&#125; 图列： PRPSD图谱适用浏览器无法展示展示三维图谱时替代，即可用于PRPS三维图也可用于PRPD三维图。 PRPD图谱数据结构 title：图谱标头 axisInfo：坐标信息 axisInfo.xDesc：X轴描述，相位 axisInfo.xRangeMax：X轴范围，默认值：360 axisInfo.xRangeMin：X轴范围，默认值：0 axisInfo.xUnit：X轴单位，默认值：° axisInfo.yDesc：Y轴描述，幅值 axisInfo.yRangeMax：Y轴范围，最大值 axisInfo.yRangeMin：Y轴范围，最小值 axisInfo.yUnit：Y轴单位，默认值：mV axisInfo.zDesc：Z轴描述，脉冲个数 axisInfo.zRangeMax：Z轴范围，默认值：100 axisInfo.zRangeMin：Z轴范围，默认值：0 axisInfo.zUnit：Y轴单位，默认值：空 series：系列列表 series.color：数据点颜色系，如果不配置或者值为空，数据点颜色则按照数据集合中的颜色显示，默认值：blaze series.dataList：[[时间间隔,幅值,脉冲个数,数据点颜色],……]，其中数据点颜色可选 123456789101112131415161718192021chartBody: &#123; title: '', axisInfo: &#123; xDesc: '', xRangeMax: 0, xRangeMin: 0, xUnit: '°', yDesc: '', yRangeMax: 0, yRangeMin: 0, yUnit: 'mV', zDesc: '', zRangeMax: 100, zRangeMin: 0, zUnit: '', &#125;, series: [&#123; colors: 'blaze', dataList: [[0,0,0],……], &#125;]&#125; 图列： 铁芯接地电流(earthcurrent)图谱数据结构 title：图谱标头 axisInfo：坐标信息 axisInfo.desc：描述，电流值 axisInfo.rangeMax：电流值最大值 axisInfo.rangeMin：电流值最小值 axisInfo.unit：单位，默认值：mA axisInfo.nomalMax：正常值，默认值：100 axisInfo.nomalColor：正常颜色，默认值：#1BA261 axisInfo.warningMax：预警值，默认值：300 axisInfo.warningColor：预警颜色，默认值：#FCAB53 axisInfo.alarmMax：报警值，默认值：500 axisInfo.alarmColor：报警颜色，默认值：#DD5044 axisInfo.value：测量值 12345678910111213141516chartBody: &#123; title: '', axisInfo: &#123; desc: '', rangeMax: 500, rangeMin: 0, unit: 'mA', nomalMax: 100, nomalColor: '#1BA261', warningMax: 300, warningColor: '#FCAB53', alarmMax: 500, alarmColor: '#DD5044', value:0 &#125;&#125; 图列： 红外温度矩阵(infrared)图谱数据结构 title：图谱标头 axisInfo：坐标信息 axisInfo.desc：描述，温度值 axisInfo.widht：图像宽度，默认值：360 axisInfo.height：图像高度，默认值：256 axisInfo.rangeMax：温度最大值 axisInfo.rangeMin：温度最小值 axisInfo.unit：温度单位，默认值：℃ series：系列列表 series.color：点/线颜色，默认值：iron series.dataList：[[高度坐标,宽度坐标,温度值],……] 123456789101112131415chartBody: &#123; title: '', axisInfo: &#123; desc: '', widht: 360, height: 256, rangeMax: 0, rangeMin: 0, unit: '℃', &#125;, series: [&#123; colors: 'iron', dataList: [[0,0,0],……], &#125;]&#125; 图列： 机械特性(mech)图谱数据结构 适用电机电流曲线、原始电流曲线、线圈电流曲线、扭矩曲线、振动信号曲线、振动频率信号曲线、行程曲线 title：图谱标头 axisInfo：坐标信息 axisInfo.xDesc：X轴描述，不同曲线不同 axisInfo.xRangeMax：X轴最大值 axisInfo.xRangeMin：X轴最小值 axisInfo.xUnit：单位 axisInfo.yDesc：Y轴描述 axisInfo.yUnit：Y轴单位 axisInfo.pointNum：数据点数 series：系列列表 series.name：系列名称，例如：A相、X轴等 series.color：点/线颜色，默认值：#1BA261 series.dataList：[对应曲线值,……] 1234567891011121314151617chartBody: &#123; title: '', axisInfo: &#123; xDesc: '', xRangeMax: 0, xRangeMin: 0, xUnit: 's', yDesc: '', yUnit: 'A', pointNum: 0, &#125;, series: [&#123; name: 'A', color: '#1BA261', dataList: [0,……] &#125;,……],&#125; 图列： 开关量(switches)曲线数据结构 title：图谱标头 axisInfo：坐标信息 axisInfo.xDesc：X轴描述，时间 axisInfo.xRangeMax：X轴最大值 axisInfo.xRangeMin：X轴最小值 axisInfo.xUnit：单位 axisInfo.yDesc：Y轴描述 axisInfo.yUnit：Y轴单位 axisInfo.pointNum：数据点数 axisInfo.valDesc：开关状态 axisInfo.valDesc.on：开状态描述 axisInfo.valDesc.off：关状态描述 series：系列列表 series.name：系列名称，例如：A相等 series.color：点/线颜色，默认值：#1BA261 series.dataList：[开关状态量,……] 123456789101112131415161718192021chartBody: &#123; title: '', axisInfo: &#123; xDesc: '', xRangeMax: 0, xRangeMin: 0, xUnit: 'ms', yDesc: '', yUnit: '', pointNum: 0, valDesc: &#123; on: '', off: '' &#125; &#125;, series: [&#123; name: 'A', color: '#1BA261', dataList: [0,……] &#125;,……],&#125; 图列： 周期图谱(cycle)数据结构 title：图谱标头 axisInfo：坐标信息 axisInfo.xDesc：X轴描述，相位 axisInfo.xRangeMax：X轴最大值 axisInfo.xRangeMin：X轴最小值 axisInfo.xUnit：X轴单位 axisInfo.yDesc：Y轴描述，幅值 axisInfo.yRangeMax：Y轴最大值 axisInfo.yRangeMin：Y轴最小值 axisInfo.yUnit：Y轴单位 trigger：触发线 trigger.desc：触发值描述 trigger.value：触发值，对应状态的最大值 trigger.color：触发线颜色，默认值：#ff00ff series：系列列表 series.name：系列名称，例如：正常 series.color：点/线颜色，默认值：#008000 series.dataList：[[相位值,幅值],……] 12345678910111213141516171819202122232425let init = &#123; title: '', axisInfo: &#123; xDesc: '', xRangeMax: 0, xRangeMin: 0, xUnit: '°', yDesc: '', yRangeMax: 0, yRangeMin: 0, yUnit: 'dB', yMaxValue: 0, yMaxColor: '#ff00ff' &#125;, trigger: [&#123; desc: '', value: 0, color: '#008000' &#125;], series: [&#123; name:'', color:'' dataList: [[0, 0],……], &#125;]&#125;; 图列：","categories":[{"name":"业务相关","slug":"业务相关","permalink":"http://www.whoosh.site/categories/业务相关/"}],"tags":[{"name":"PDCharts","slug":"PDCharts","permalink":"http://www.whoosh.site/tags/PDCharts/"},{"name":"ECharts","slug":"ECharts","permalink":"http://www.whoosh.site/tags/ECharts/"}]},{"title":"高效能人士的七个习惯","slug":"20180315_高效能人士的七个习惯","date":"2018-03-15T13:13:58.000Z","updated":"2018-03-16T14:36:45.531Z","comments":true,"path":"2018/03/15/20180315_高效能人士的七个习惯/","link":"","permalink":"http://www.whoosh.site/2018/03/15/20180315_高效能人士的七个习惯/","excerpt":"","text":"前言 2018-01-13 我就是我生命的创造力 要完成最渴望的目标，战胜最艰巨的挑战，必须发掘并应用一些原则或自然法则（套路）。任何努力的成功，都离不开恰到好处并游刃有余地应用这些原则。 人类面临最普遍的集中挑战：恐惧感和不安全感、我现在就想得到、谴责和抱怨、绝望无助、缺乏人生平衡、我的定位在哪儿、渴望被理解、冲突和分歧、个人的停滞不前 犬儒主义：源于古希腊犬儒学派学者主张的哲学思潮(创始人：安提斯泰尼，集大成者：第欧根尼)，该派的本意是指人不应被一切世俗的事物，包括宗教、礼节、惯常的衣食住行方面等习俗束缚，提倡对道德的无限追求，同时过着极简朴而非物质的生活。现代的犬儒主义演变成了虚无主义、愤世嫉俗、玩世不恭。 重新探索自我 皮格马利翁效应（Pygmalion Effect, 又称比马龙效应）指人们基于对某种情境的知觉而形成的期望或预言，会使该情境产生适应这一期望或预言的效应。 个人领域的成功：从依赖到独立1. 积极主动：个人愿景2. 以终为始：自我领导3. 要事第一：自我管理公众领域的成功：从独立到互赖4. 双赢思维：人际领导5. 知己解彼：移情沟通6. 统合综效：创造性合作自我提升和改善7. 不断更新：平衡的自我更新","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://www.whoosh.site/categories/读书笔记/"}],"tags":[{"name":"管理类书籍","slug":"管理类书籍","permalink":"http://www.whoosh.site/tags/管理类书籍/"}]},{"title":"普吉蜜月旅行","slug":"20180311_普吉蜜月旅行","date":"2018-03-11T13:13:58.000Z","updated":"2018-03-11T15:16:20.046Z","comments":true,"path":"2018/03/11/20180311_普吉蜜月旅行/","link":"","permalink":"http://www.whoosh.site/2018/03/11/20180311_普吉蜜月旅行/","excerpt":"","text":"出发前准备蜜月旅行之所以选择去泰国，主要考虑到这是一次意义非凡的旅行，不想把婚假白白浪费在国内，还有就是安全因素了，毕竟第一次出国，没有经验，就选了个近的，而且跟了团（胆子小嘛）。 虽说跟团出行，但是出发前还是要准备一些东西的： 护照：出国必备品，在公安局出入境大厅办理，携带身份证、户口本原件，2寸照即可办理，工本费200。 签证：也是必备品，可以自己去大使馆办理、找旅行社办理、也可以落地签（看目的地是否可以），我们本来想自己办理，结果需要提供一堆的证明，懒得弄就选择了落地签了。 泰铢：泰国要求游客每人必须携带20000泰铢或等值人民币，可以去银行换一些小额的泰铢，例如20、50、100，因为泰国是一个小费国家，经常要用到。 电话卡：专为游客设计的happy卡，在泰国激活后可用8天，2.5G高速流量，100分钟通话时长，但是打电话必须要在号码前要加0040086，基本上这些足够用了，反正我的没有用完。 夏装：普吉岛没有最热只有更热，一定要带上夏装过去，例如拖鞋、大裤衩、防晒品之类的，当然这些在本地也能买到，价格嘛肯定要贵点的。 泰国是一个非常适合养老的地方，不仅当地人生活节奏非常慢，猫狗也都非常的慵懒，见到它们肥嘟嘟的躺在地上晒太阳，相当的闲适了，可惜没有留下照片。 欢乐时光 总结这是一次非常开心的旅行，见识到不一样的世界，遇到不一样的人。生活在不停的忙碌后需要一段时间来调节下，然后继续追逐着梦想，不禁感慨，活着真好。","categories":[{"name":"游记","slug":"游记","permalink":"http://www.whoosh.site/categories/游记/"}],"tags":[{"name":"旅行","slug":"旅行","permalink":"http://www.whoosh.site/tags/旅行/"}]},{"title":"Canvas的基本用法","slug":"20170702_Canvas的基本用法","date":"2017-07-02T14:13:58.000Z","updated":"2018-03-20T14:38:33.564Z","comments":true,"path":"2017/07/02/20170702_Canvas的基本用法/","link":"","permalink":"http://www.whoosh.site/2017/07/02/20170702_Canvas的基本用法/","excerpt":"","text":"浏览器支持表格中的数字表示支持 &lt;canvas&gt; 元素的第一个浏览器版本号。 元素 &lt;canvas&gt; 4.0 9.0 2.0 3.1 9.0 属性和方法 属性 名称 描述 颜色 fillStyle 设置或返回用于填充绘画的颜色、渐变或模式 strokeStyle 设置或返回用于笔触的颜色、渐变或模式 阴影 shadowColor 设置或返回用于阴影的颜色 shadowBlur 设置或返回用于阴影的模糊级别 shadowOffsetX 设置或返回阴影距形状的水平距离 shadowOffsetY 设置或返回阴影距形状的垂直距离 线条样式 lineCap 设置或返回线条的结束端点样式 lineJoin 设置或返回两条线相交时，所创建的拐角类型 lineWidth 设置或返回当前的线条宽度 miterLimit 设置或返回最大斜接长度 文本 font 设置或返回文本内容的当前字体属性 textAlign 设置或返回文本内容的当前对齐方式 textBaseline 设置或返回在绘制文本时使用的当前文本基线 像素 width 返回 ImageData 对象的宽度 height 返回 ImageData 对象的高度 data 返回一个对象，其包含指定的 ImageData 对象的图像数据 图像合成 globalAlpha 设置或返回绘图的当前 alpha 或透明值 globalCompositeOperation 设置或返回新图像如何绘制到已有的图像上 方法 名称 描述 样式 createLinearGradient() 创建线性渐变（用在画布内容上） createPattern() 在指定的方向上重复指定的元素 createRadialGradient() 创建放射状/环形的渐变（用在画布内容上） addColorStop() 规定渐变对象中的颜色和停止位置 矩形 rect() 创建矩形 fillRect() 绘制“被填充”的矩形 strokeRect() 绘制矩形（无填充） clearRect() 在给定的矩形内清除指定的像素 路径 fill() 填充当前绘图（路径） stroke() 绘制已定义的路径 beginPath() 起始一条路径，或重置当前路径 closePath() 创建从当前点回到起始点的路径 moveTo() 把路径移动到画布中的指定点，不创建线条 lineTo() 添加一个新点，然后在画布中创建从该点到最后指定点的线条 clip() 从原始画布剪切任意形状和尺寸的区域 quadraticCurveTo() 创建二次贝塞尔曲线 bezierCurveTo() 创建三次方贝塞尔曲线 arc() 创建弧/曲线（用于创建圆形或部分圆） arcTo() 创建两切线之间的弧/曲线 isPointInPath() 如果指定的点位于当前路径中，则返回 true，否则返回 false 转换 scale() 缩放当前绘图至更大或更小 rotate() 旋转当前绘图 translate() 重新映射画布上的 (0,0) 位置 transform() 替换绘图的当前转换矩阵 setTransform() 将当前转换重置为单位矩阵。然后运行 transform() 文本 fillText() 在画布上绘制“被填充的”文本 strokeText() 在画布上绘制文本（无填充） measureText() 返回包含指定文本宽度的对象 像素 createImageData() 创建新的、空白的 ImageData 对象 getImageData() 返回 ImageData 对象，该对象为画布上指定的矩形复制像素数据 putImageData() 把图像数据（从指定的 ImageData 对象）放回画布上 图像绘制 drawImage() 向画布上绘制图像、画布或视频 其他 save() 保存当前环境的状态 restore() 返回之前保存过的路径状态和属性 getContext() 返回一个用于在画布上绘图的环境 toDataURL() 获取画布的Base64字符串 toBlob() 获取画布的二进制数据 fillStylecontext.fillStyle=color|gradient|pattern; color 指示绘图填充色的 CSS 颜色值。默认值是 #000000。 gradient 用于填充绘图的渐变对象（线性或放射性） pattern 用于填充绘图的 pattern 对象 实例11234var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.fillStyle=\"#0000ff\";ctx.fillRect(20,20,150,100); 实例21234567var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");var my_gradient=ctx.createLinearGradient(0,0,0,170);my_gradient.addColorStop(0,\"black\");my_gradient.addColorStop(1,\"white\");ctx.fillStyle=my_gradient;ctx.fillRect(20,20,150,100); 实例3123456789var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.clearRect(0,0,c.width,c.height); var img=document.getElementById(\"lamp\")//direction=repeat|repeat-x|repeat-y|no-repeatvar pat=ctx.createPattern(img,'repeat');ctx.rect(0,0,300,150);ctx.fillStyle=pat;ctx.fill(); strokeStylecontext.strokeStyle=color|gradient|pattern; color 指示绘图笔触颜色的 CSS 颜色值。默认值是 #000000。 gradient 用于填充绘图的渐变对象（线性或放射性） pattern 用于创建 pattern 笔触的 pattern 对象 实例11234var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.strokeStyle=\"#0000ff\";ctx.strokeRect(20,20,150,100); 实例212345678910var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");var gradient=ctx.createLinearGradient(0,0,170,0);gradient.addColorStop(\"0\",\"magenta\");gradient.addColorStop(\"0.5\",\"blue\");gradient.addColorStop(\"1.0\",\"red\");// 用渐变进行填充ctx.strokeStyle=gradient;ctx.lineWidth=5;ctx.strokeRect(20,20,150,100); shadowColorcontext.shadowColor=color; color 用于阴影的 CSS 颜色值。默认值是 #000000。 实例1123456var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.shadowBlur=20;ctx.shadowColor=\"black\";ctx.fillStyle=\"blue\";ctx.fillRect(20,20,100,80); shadowBlurcontext.shadowBlur=number; number 阴影的模糊级数 实例1123456var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.shadowBlur=200;ctx.shadowColor=\"red\";ctx.fillStyle=\"blue\";ctx.fillRect(20,20,100,80); shadowOffsetXcontext.shadowOffsetX=number; number 正值（右侧）或负值（左侧），定义阴影与形状的水平距离。 实例11234567var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.shadowBlur=10;ctx.shadowOffsetX=20;ctx.shadowColor=\"black\";ctx.fillStyle=\"blue\";ctx.fillRect(20,20,100,80); shadowOffsetYcontext.shadowOffsetY=number; number 正值（右侧）或负值（左侧），定义阴影与形状的垂直距离。 实例11234567var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.shadowBlur=10;ctx.shadowOffsetY=20;ctx.shadowColor=\"black\";ctx.fillStyle=\"blue\";ctx.fillRect(20,20,100,80); lineCapcontext.lineCap=”butt|round|square”; butt 默认。向线条的每个末端添加平直的边缘。 round 向线条的每个末端添加圆形线帽。 square 向线条的每个末端添加正方形线帽。 实例11234567var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.beginPath();ctx.lineCap=\"round\";ctx.moveTo(20,20);ctx.lineTo(20,200);ctx.stroke(); lineJoincontext.lineJoin=”bevel|round|miter”; bevel 创建斜角。 round 创建圆角。 miter 创建尖角。默认值。 实例112345678var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.beginPath();ctx.lineJoin=\"round\";ctx.moveTo(20,20);ctx.lineTo(100,50);ctx.lineTo(20,100);ctx.stroke(); lineWidthcontext.lineWidth=number; number 当前线条的宽度，以像素计，默认值1。 实例11234var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.lineWidth=10;ctx.strokeRect(20,20,80,100); miterLimitcontext.miterLimit=number; number 正数。规定最大斜接长度。只有当 lineJoin 属性为 “miter” 时，miterLimit 才有效。如果斜接长度超过 miterLimit 的值，边角会以 lineJoin 的 “bevel” 类型来显示。 实例1123456789var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.lineWidth=10;ctx.lineJoin=\"miter\";ctx.miterLimit=5;ctx.moveTo(20,20);ctx.lineTo(50,27);ctx.lineTo(20,34);ctx.stroke(); fontcontext.font=”italic small-caps bold 12px arial”; font-style 规定字体样式。可能的值：normal、italic、oblique。 font-variant 规定字体变体。可能的值：normal、small-caps。 font-weight 规定字体的粗细。可能的值：normal、bold、bolder、lighter、100、200、300、400、500、600、700、800、900。 font-size 规定字号，以像素计。 line-height 规定行高，以像素计。 font-family 规定字体系列。 caption 使用标题控件的字体（比如按钮、下拉列表等）。 icon 使用用于标记图标的字体。 menu 使用用于菜单中的字体（下拉列表和菜单列表）。 message-box 使用用于对话框中的字体。 small-caption 使用用于标记小型控件的字体。 status-bar 使用用于窗口状态栏中的字体。 实例11234var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.font=\"40px Arial\";ctx.fillText(\"Hello World\",10,50); textAligncontext.textAlign=”center|end|left|right|start”; start 默认。文本在指定的位置开始。 end 文本在指定的位置结束。 center 文本的中心被放置在指定的位置。 left 文本左对齐。 right 文本右对齐。 实例112345678910111213141516171819202122var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");// 在位置 150 创建蓝线ctx.strokeStyle=\"blue\";ctx.moveTo(150,20);ctx.lineTo(150,170);ctx.stroke();ctx.font=\"15px Arial\";// 显示不同的 textAlign 值ctx.textAlign=\"start\";ctx.fillText(\"textAlign=start\",150,60);ctx.textAlign=\"end\";ctx.fillText(\"textAlign=end\",150,80);ctx.textAlign=\"left\";ctx.fillText(\"textAlign=left\",150,100);ctx.textAlign=\"center\";ctx.fillText(\"textAlign=center\",150,120);ctx.textAlign=\"right\";ctx.fillText(\"textAlign=right\",150,140); textBaselinecontext.textBaseline=”alphabetic|top|hanging|middle|ideographic|bottom”; alphabetic 默认。文本基线是普通的字母基线。 top 文本基线是 em 方框的顶端。。 hanging 文本基线是悬挂基线。 middle 文本基线是 em 方框的正中。 ideographic 文本基线是表意基线。 bottom 文本基线是 em 方框的底端。 实例112345678910111213141516171819202122var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");//在位置 y=100 绘制蓝色线条ctx.strokeStyle=\"blue\";ctx.moveTo(5,100);ctx.lineTo(395,100);ctx.stroke();ctx.font=\"20px Arial\"//在 y=200 以不同的 textBaseline 值放置每个单词ctx.textBaseline=\"top\";ctx.fillText(\"Top\",5,100);ctx.textBaseline=\"bottom\";ctx.fillText(\"Bottom\",50,100);ctx.textBaseline=\"middle\";ctx.fillText(\"Middle\",120,100);ctx.textBaseline=\"alphabetic\";ctx.fillText(\"Alphabetic\",190,100);ctx.textBaseline=\"hanging\";ctx.fillText(\"Hanging\",290,100); widthimgData.width; width 属性返回 ImageData 对象的宽度，以像素计。 实例11alert(\"Width of imgData is: \" + imgData.width); heightimgData.height; height 属性返回 ImageData 对象的高度，以像素计。 实例11alert(\"Width of imgData is: \" + imgData.height); dataimageData.data; 对于 ImageData 对象中的每个像素，都存在着四方面的信息，即 RGBA 值：R - 红色 (0-255)G - 绿色 (0-255)B - 蓝色 (0-255)A - alpha 通道 (0-255; 0 是透明的，255 是完全可见的)color/alpha 以数组形式存在，并存储于 ImageData 对象的 data 属性中。 实例11234567891011var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");var imgData=ctx.createImageData(100,100);for (var i=0;i&lt;imgData.data.length;i+=4) &#123; imgData.data[i+0]=255; imgData.data[i+1]=0; imgData.data[i+2]=0; imgData.data[i+3]=255; &#125;ctx.putImageData(imgData,10,10); globalAlphacontext.globalAlpha=number; number 透明值。必须介于 0.0（完全透明） 与 1.0（不透明） 之间。 实例112345678910var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.fillStyle=\"red\";ctx.fillRect(20,20,75,50);// 调节透明度ctx.globalAlpha=0.2;ctx.fillStyle=\"blue\";ctx.fillRect(50,50,75,50);ctx.fillStyle=\"green\";ctx.fillRect(80,80,75,50); globalCompositeOperationcontext.globalCompositeOperation=”source-over”; source-over 默认。在目标图像上显示源图像。 source-atop 在目标图像顶部显示源图像。源图像位于目标图像之外的部分是不可见的。 source-in 在目标图像中显示源图像。只有目标图像内的源图像部分会显示，目标图像是透明的。 source-out 在目标图像之外显示源图像。只会显示目标图像之外源图像部分，目标图像是透明的。 destination-over 在源图像上方显示目标图像。 destination-atop 在源图像顶部显示目标图像。源图像之外的目标图像部分不会被显示。 destination-in 在源图像中显示目标图像。只有源图像内的目标图像部分会被显示，源图像是透明的。 destination-out 在源图像外显示目标图像。只有源图像外的目标图像部分会被显示，源图像是透明的。 lighter 显示源图像 + 目标图像。 copy 显示源图像。忽略目标图像。 xor 使用异或操作对源图像与目标图像进行组合。 实例11234567891011121314var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.fillStyle=\"red\";ctx.fillRect(20,20,75,50);ctx.globalCompositeOperation=\"source-over\";ctx.fillStyle=\"blue\";ctx.fillRect(50,50,75,50);ctx.fillStyle=\"red\";ctx.fillRect(150,20,75,50);ctx.globalCompositeOperation=\"destination-over\";ctx.fillStyle=\"blue\";ctx.fillRect(180,50,75,50); createLinearGradient()context.createLinearGradient(x0,y0,x1,y1); x0 渐变开始点的 x 坐标 y0 渐变开始点的 y 坐标 x1 渐变结束点的 x 坐标 y1 渐变结束点的 y 坐标 实例1123456789var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");var grd=ctx.createLinearGradient(0,0,170,0);grd.addColorStop(0,\"black\");grd.addColorStop(1,\"white\");ctx.fillStyle=grd;ctx.fillRect(20,20,150,100); createPattern()context.createPattern(image,”repeat|repeat-x|repeat-y|no-repeat”); image 规定要使用的图片、画布或视频元素。 repeat 默认。该模式在水平和垂直方向重复。 repeat-x 该模式只在水平方向重复。 repeat-y 该模式只在垂直方向重复。 no-repeat 该模式只显示一次（不重复）。 实例112345678var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.clearRect(0,0,c.width,c.height); var img=document.getElementById(\"lamp\")var pat=ctx.createPattern(img,'repeat');ctx.rect(0,0,300,150);ctx.fillStyle=pat;ctx.fill(); createRadialGradient()context.createRadialGradient(x0,y0,r0,x1,y1,r1); x0 渐变的开始圆的 x 坐标 y0 渐变的开始圆的 y 坐标 r0 开始圆的半径 x1 渐变的结束圆的 x 坐标 y1 渐变的结束圆的 y 坐标 r1 结束圆的半径 实例112345678910var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");var grd=ctx.createRadialGradient(75,50,5,90,60,100);grd.addColorStop(0,\"red\");grd.addColorStop(1,\"white\");// Fill with gradientctx.fillStyle=grd;ctx.fillRect(10,10,150,100); addColorStop()gradient.addColorStop(stop,color); stop 介于 0.0 与 1.0 之间的值，表示渐变中开始与结束之间的位置。 color 在结束位置显示的 CSS 颜色值 实例112345678910111213var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");var grd=ctx.createLinearGradient(0,0,170,0);grd.addColorStop(0,\"black\");grd.addColorStop(\"0.3\",\"magenta\");grd.addColorStop(\"0.5\",\"blue\");grd.addColorStop(\"0.6\",\"green\");grd.addColorStop(\"0.8\",\"yellow\");grd.addColorStop(1,\"red\");ctx.fillStyle=grd;ctx.fillRect(20,20,150,100); rect()context.rect(x,y,width,height); x 矩形左上角的 x 坐标 y 矩形左上角的 y 坐标 width 矩形的宽度，以像素计 height 矩形的高度，以像素计 实例11234567891011121314151617181920212223var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");// 红色矩形ctx.beginPath();ctx.lineWidth=\"6\";ctx.strokeStyle=\"red\";ctx.rect(5,5,290,140);ctx.stroke();// 绿色矩形ctx.beginPath();ctx.lineWidth=\"4\";ctx.strokeStyle=\"green\";ctx.rect(30,30,50,50);ctx.stroke();// 蓝色矩形ctx.beginPath();ctx.lineWidth=\"10\";ctx.strokeStyle=\"blue\";ctx.rect(50,50,150,80);ctx.stroke(); fillRect()context.fillRect(x,y,width,height); x 矩形左上角的 x 坐标 y 矩形左上角的 y 坐标 width 矩形的宽度，以像素计 height 矩形的高度，以像素计 实例1123var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.fillRect(20,20,150,100); strokeRect()context.strokeRect(x,y,width,height); x 矩形左上角的 x 坐标 y 矩形左上角的 y 坐标 width 矩形的宽度，以像素计 height 矩形的高度，以像素计 实例1123var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.strokeRect(20,20,150,100); clearRect()context.clearRect(x,y,width,height); x 要清除的矩形左上角的 x 坐标 y 要清除的矩形左上角的 y 坐标 width 要清除的矩形的宽度，以像素计 height 要清除的矩形的高度，以像素计 实例112345var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.fillStyle=\"red\";ctx.fillRect(0,0,300,150);ctx.clearRect(20,20,100,50); fill()context.fill(); 如果路径未关闭，那么 fill() 方法会从路径结束点到开始点之间添加一条线，以关闭该路径，然后填充该路径 实例112345var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.rect(20,20,150,100);ctx.fillStyle=\"green\";ctx.fill(); stroke()context.stroke(); 会实际地绘制出通过 moveTo() 和 lineTo() 方法定义的路径。默认颜色是黑色 实例112345678var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.beginPath();ctx.moveTo(20,20);ctx.lineTo(20,100);ctx.lineTo(70,100);ctx.strokeStyle=\"green\";ctx.stroke(); beginPath()context.beginPath(); 开始一条路径，或重置当前的路径 实例1123456789101112131415var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.beginPath();ctx.lineWidth=\"5\";ctx.strokeStyle=\"red\"; // 红色路径ctx.moveTo(0,75);ctx.lineTo(250,75);ctx.stroke(); // 进行绘制ctx.beginPath();ctx.strokeStyle=\"blue\"; // 蓝色路径ctx.moveTo(50,0);ctx.lineTo(150,130);ctx.stroke(); // 进行绘制 closePath()context.closePath(); 创建从当前点到开始点的路径 实例112345678910var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.beginPath();ctx.moveTo(20,20);ctx.lineTo(20,100);ctx.lineTo(70,100);ctx.closePath();ctx.stroke();ctx.fillStyle=\"green\";ctx.fill(); moveTo()context.moveTo(x,y); x 路径的目标位置的 x 坐标 y 路径的目标位置的 y 坐标 实例1123456var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.beginPath();ctx.moveTo(0,0);ctx.lineTo(300,150);ctx.stroke(); lineTo()context.lineTo(x,y); x 路径的目标位置的 x 坐标 y 路径的目标位置的 y 坐标 实例11234567var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.beginPath();ctx.moveTo(20,20);ctx.lineTo(20,100);ctx.lineTo(70,100);ctx.stroke(); clip()context.clip(); 从原始画布中剪切任意形状和尺寸。一旦剪切了某个区域，则所有之后的绘图都会被限制在被剪切的区域内（不能访问画布上的其他区域）。您也可以在使用 clip() 方法前通过使用 save() 方法对当前画布区域进行保存，并在以后的任意时间对其进行恢复（通过 restore() 方法）。 实例1123456789var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");// 剪切矩形区域ctx.rect(50,20,200,120);ctx.stroke();ctx.clip();// 在 clip() 之后绘制绿色矩形ctx.fillStyle=\"green\";ctx.fillRect(0,0,150,100); quadraticCurveTo()context.quadraticCurveTo(cpx,cpy,x,y); cpx 贝塞尔控制点的 x 坐标 cpy 贝塞尔控制点的 y 坐标 x 结束点的 x 坐标 y 结束点的 y 坐标 实例1123456var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.beginPath();ctx.moveTo(20,20);ctx.quadraticCurveTo(20,100,200,20);ctx.stroke(); bezierCurveTo()context.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y); cp1x 第一个贝塞尔控制点的 x 坐标 cp1y 第一个贝塞尔控制点的 y 坐标 cp2x 第二个贝塞尔控制点的 x 坐标 cp2y 第二个贝塞尔控制点的 y 坐标 x 结束点的 x 坐标 y 结束点的 y 坐标 实例1123456var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.beginPath();ctx.moveTo(20,20);ctx.bezierCurveTo(20,100,200,100,200,20);ctx.stroke(); arc()context.arc(x,y,r,sAngle,eAngle,counterclockwise); x 圆的中心的 x 坐标。 y 圆的中心的 y 坐标。 r 圆的半径。 sAngle 起始角，以弧度计。（弧的圆形的三点钟位置是 0 度）。 eAngle 结束角，以弧度计。 counterclockwise 可选。规定应该逆时针还是顺时针绘图。False = 顺时针，true = 逆时针。 实例112345var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.beginPath();ctx.arc(100,75,50,0,2*Math.PI);ctx.stroke(); arcTo()context.fillRect(x1,y1,x2,y2,r); x1 弧的起点的 x 坐标 y1 弧的起点的 y 坐标 x2 弧的终点的 x 坐标 y2 弧的终点的 y 坐标 r 弧的半径 实例1123456789var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.beginPath();ctx.beginPath();ctx.moveTo(20,20); // 创建开始点ctx.lineTo(100,20); // 创建水平线ctx.arcTo(150,20,150,70,50); // 创建弧ctx.lineTo(150,120); // 创建垂直线ctx.stroke(); // 进行绘制 isPointInPath()context.isPointInPath(x,y); x 测试的 x 坐标 y 测试的 y 坐标 实例11234567var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.rect(20,20,150,100);if (ctx.isPointInPath(20,50))&#123; ctx.stroke();&#125;; scale()context.scale(scalewidth,scaleheight); scalewidth 缩放当前绘图的宽度 (1=100%, 0.5=50%, 2=200%, 依次类推) scaleheight 缩放当前绘图的高度 (1=100%, 0.5=50%, 2=200%, etc.) 如果您对绘图进行缩放，所有之后的绘图也会被缩放。定位也会被缩放。 实例1123456789var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.strokeRect(5,5,25,15);ctx.scale(2,2);ctx.strokeRect(5,5,25,15);ctx.scale(2,2);ctx.strokeRect(5,5,25,15);ctx.scale(2,2);ctx.strokeRect(5,5,25,15); rotate()context.rotate(angle); angle 旋转角度，以弧度计。如需将角度转换为弧度，请使用 degrees*Math.PI/180 公式进行计算。 实例11234var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.rotate(20*Math.PI/180);ctx.fillRect(50,20,100,50); translate()context.translate(x,y); x 添加到水平坐标（x）上的值 y 添加到垂直坐标（y）上的值 实例112345var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.fillRect(10,10,100,50);ctx.translate(70,70);ctx.fillRect(10,10,100,50); transform()context.transform(a,b,c,d,e,f); a 水平缩放绘图 b 水平倾斜绘图 c 垂直倾斜绘图 d 垂直缩放绘图 e 水平移动绘图 f 垂直移动绘图 每当您调用 transform() 时，它都会在前一个变换矩阵上构建 实例112345678910111213var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.fillStyle=\"yellow\";ctx.fillRect(0,0,250,100)ctx.transform(1,0.5,-0.5,1,30,10);ctx.fillStyle=\"red\";ctx.fillRect(0,0,250,100);ctx.transform(1,0.5,-0.5,1,30,10);ctx.fillStyle=\"blue\";ctx.fillRect(0,0,250,100); setTransform()context.setTransform(a,b,c,d,e,f); a 水平旋转绘图 b 水平倾斜绘图 c 垂直倾斜绘图 d 垂直缩放绘图 e 水平移动绘图 f 垂直移动绘图 把当前的变换矩阵重置为单位矩阵，然后以相同的参数运行 transform() 实例112345678910111213var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.fillStyle=\"yellow\";ctx.fillRect(0,0,250,100)ctx.setTransform(1,0.5,-0.5,1,30,10);ctx.fillStyle=\"red\";ctx.fillRect(0,0,250,100);ctx.setTransform(1,0.5,-0.5,1,30,10);ctx.fillStyle=\"blue\";ctx.fillRect(0,0,250,100); drawImage()context.drawImage(img,x,y);context.drawImage(img,x,y,width,height);context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height); img 规定要使用的图像、画布或视频。 sx 可选。开始剪切的 x 坐标位置。 sy 可选。开始剪切的 y 坐标位置。 swidth 可选。被剪切图像的宽度。 sheight 可选。被剪切图像的高度。 x 在画布上放置图像的 x 坐标位置。 y 在画布上放置图像的 y 坐标位置。 width 可选。要使用的图像的宽度。（伸展或缩小图像） height 可选。要使用的图像的高度。（伸展或缩小图像） 实例11234var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");var img=document.getElementById(\"tulip\");ctx.drawImage(img,10,10,240,160); 实例21234var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");var img=document.getElementById(\"scream\");ctx.drawImage(img,90,130,90,80,20,20,90,80); 实例312345678910111213var v=document.getElementById(\"video1\");var c=document.getElementById(\"myCanvas\");ctx=c.getContext('2d');v.addEventListener('play',function() &#123; var i=window.setInterval(function() &#123; ctx.drawImage(v,0,0,270,135)&#125;,20); &#125;,false);v.addEventListener('pause',function() &#123; window.clearInterval(i); &#125;,false);v.addEventListener('ended',function() &#123; clearInterval(i); &#125;,false); fillText()context.fillText(text,x,y,maxWidth); text 规定在画布上输出的文本。 x 开始绘制文本的 x 坐标位置（相对于画布）。 y 开始绘制文本的 y 坐标位置（相对于画布）。 maxWidth 可选。允许的最大文本宽度，以像素计。 实例1123456789101112131415var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.font=\"20px Georgia\";ctx.fillText(\"Hello World!\",10,50);ctx.font=\"30px Verdana\";// Create gradientvar gradient=ctx.createLinearGradient(0,0,c.width,0);gradient.addColorStop(\"0\",\"magenta\");gradient.addColorStop(\"0.5\",\"blue\");gradient.addColorStop(\"1.0\",\"red\");// Fill with gradientctx.fillStyle=gradient;ctx.fillText(\"www.whoosh.site\",10,90); strokeText()context.strokeText(text,x,y,maxWidth); text 规定在画布上输出的文本。 x 开始绘制文本的 x 坐标位置（相对于画布）。 y 开始绘制文本的 y 坐标位置（相对于画布）。 maxWidth 可选。允许的最大文本宽度，以像素计。 实例1123456789101112131415var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.font=\"20px Georgia\";ctx.strokeText(\"Hello World!\",10,50);ctx.font=\"30px Verdana\";// Create gradientvar gradient=ctx.createLinearGradient(0,0,c.width,0);gradient.addColorStop(\"0\",\"magenta\");gradient.addColorStop(\"0.5\",\"blue\");gradient.addColorStop(\"1.0\",\"red\");// Fill with gradientctx.strokeStyle=gradient;ctx.strokeText(\"www.whoosh.site\",10,90); measureText()context.measureText(text).width; text 要测量的文本。 实例1123456var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.font=\"30px Arial\";var txt=\"Hello World\"ctx.fillText(\"width:\" + ctx.measureText(txt).width,10,50)ctx.fillText(txt,10,100); createImageData()context.createImageData(imageData);context.createImageData(width,height); width ImageData 对象的宽度，以像素计。 height ImageData 对象的高度，以像素计。 imageData 另一个 ImageData 对象。 实例11234567891011var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");var imgData=ctx.createImageData(100,100);for (var i=0;i&lt;imgData.data.length;i+=4) &#123; imgData.data[i+0]=255; imgData.data[i+1]=0; imgData.data[i+2]=0; imgData.data[i+3]=255; &#125;ctx.putImageData(imgData,10,10); getImageData()context.getImageData(x,y,width,height); x 开始复制的左上角位置的 x 坐标。 y 开始复制的左上角位置的 y 坐标。 width 将要复制的矩形区域的宽度。 height 将要复制的矩形区域的高度。 实例11234567891011var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.fillStyle=\"green\";ctx.fillRect(10,10,50,50);var imgData=ctx.getImageData(30,30,50,50);red=imgData.data[0];green=imgData.data[1];blue=imgData.data[2];alpha=imgData.data[3];alert(red + \" \" + green + \" \" + blue + \" \" + alpha); putImageData()context.putImageData(imgData,x,y,dirtyX,dirtyY,dirtyWidth,dirtyHeight); imgData 规定要放回画布的 ImageData 对象。 x ImageData 对象左上角的 x 坐标，以像素计。 y ImageData 对象左上角的 y 坐标，以像素计。 dirtyX 可选。水平值（x），以像素计，在画布上放置图像的位置。 dirtyY 可选。水平值（y），以像素计，在画布上放置图像的位置。 dirtyWidth 可选。在画布上绘制图像所使用的宽度。 dirtyHeight 可选。在画布上绘制图像所使用的高度。 实例112345678910var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.fillStyle=\"green\";ctx.fillRect(10,10,50,50);function copy()&#123; var imgData=ctx.getImageData(10,10,50,50); ctx.putImageData(imgData,10,70);&#125; save()context.save(); 保存当前环境的状态 实例112345678const ctx = wx.createCanvasContext('canvas')ctx.save() ctx.setFillStyle('red') ctx.scale(2, 2)ctx.fillRect(10, 10, 150, 100) // 红色矩形一ctx.restore()ctx.fillRect(50, 50, 150, 100) // 黑色矩形二ctx.draw() restore()context.restore(); 获取上一次save保存的状态 实例112345678const ctx = wx.createCanvasContext('canvas')ctx.save() ctx.setFillStyle('red') ctx.scale(2, 2)ctx.fillRect(10, 10, 150, 100) // 红色矩形一ctx.restore()ctx.fillRect(50, 50, 150, 100) // 黑色矩形二ctx.draw() getContext()Canvas.getContext(contextID) contextID 当前唯一合法值2d，未来会支持3d 实例112var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\"); toDataURL()canvas.toDataURL(type) type image/jpeg，image/png 实例112345var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.fillRect(10, 10, 150, 100); dataURL=c.toDataURL('image/jpeg'); //转换图片为dataURL//data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAMCAgICAgMCAgIDAwMDBAYEBAQEBAgGBgUGCQgKCgkICQkKDA8MCgsOCwkJDRENDg8QEBEQCgwSExIQEw8QEBD/2wBDAQMDAwQDBAgEBAgQCwkLEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBD/wAARCACWASwDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAn/xAAUEAEAAAAAAAAAAAAAAAAAAAAA/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/AJVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//9k= toBlob()canvas.toBlob(callback, type, encoderOptions); callback 回调函数，可获得一个单独的Blob对象参数。 type 可选，DOMString类型，指定图片格式，默认格式为image/png。 encoderOptions 可选，Number类型，值在0与1之间，当请求图片格式为image/jpeg或者image/webp时用来指定图片展示质量。如果这个参数的值不在指定类型与范围之内，则使用默认值，其余参数将被忽略。 实例112345678var c=document.getElementById(\"myCanvas\");var ctx=c.getContext(\"2d\");ctx.fillRect(10, 10, 150, 100); c.toBlob(function(b)&#123; //图片的二进制数据 console.log(b)&#125;,'image/png',1);","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://www.whoosh.site/categories/前端技术/"}],"tags":[{"name":"Canvas","slug":"Canvas","permalink":"http://www.whoosh.site/tags/Canvas/"}]},{"title":"Svg的基本用法","slug":"20170503_Svg的基本用法","date":"2017-05-03T14:13:58.000Z","updated":"2018-03-29T15:38:26.411Z","comments":true,"path":"2017/05/03/20170503_Svg的基本用法/","link":"","permalink":"http://www.whoosh.site/2017/05/03/20170503_Svg的基本用法/","excerpt":"","text":"浏览器支持表格中的数字表示支持Svg的第一个浏览器版本号。 元素 &lt;svg&gt; 12.0 6.0(部分)/9.0 5.1 3.2 10.6 形状SVG 预定义的形状元素：矩形 &lt;rect&gt;、圆形 &lt;circle&gt;、椭圆 &lt;ellipse&gt;、线 &lt;line&gt;、折线 &lt;polyline&gt;、多边形 &lt;polygon&gt;、路径 &lt;path&gt;。 矩形12345&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; &lt;rect width=\"250\" height=\"100\" x=\"20\" y=\"20\" rx=\"20\" ry=\"20\" style=\"fill:red;stroke-width:5;stroke:black;fill-opacity:0.1; stroke-opacity:0.9;opacity:0.5\"/&gt;&lt;/svg&gt; 查看样例 width 属性定义矩形的宽度 height 属性定义矩形的高度 x 属性定义矩形的左侧位置（例如，x=”0” 定义矩形到浏览器窗口左侧的距离是 0px） y 属性定义矩形的顶端位置（例如，y=”0” 定义矩形到浏览器窗口顶端的距离是 0px） rx 属性可使矩形产生圆角。 ry 属性可使矩形产生圆角。 style 属性用来定义 CSS 属性 CSS 的 fill 属性定义矩形的填充颜色（rgb 值、颜色名或者十六进制值） CSS 的 stroke-width 属性定义矩形边框的宽度 CSS 的 stroke 属性定义矩形边框的颜色 CSS 的 fill-opacity 属性定义填充颜色透明度（合法的范围是：0 - 1） CSS 的 stroke-opacity 属性定义笔触颜色的透明度（合法的范围是：0 - 1） CSS 的 opacity 属性定义整个元素的透明值（合法的范围是：0 - 1） 圆形1234&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; &lt;circle cx=\"100\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"2\" fill=\"red\"/&gt;&lt;/svg&gt; 查看样例 cx和cy属性定义圆点的x和y坐标。如果省略cx和cy，圆的中心会被设置为(0, 0) r属性定义圆的半径 椭圆1234&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; &lt;ellipse cx=\"300\" cy=\"150\" rx=\"200\" ry=\"80\" style=\"fill:rgb(200,100,50);stroke:rgb(0,0,100);stroke-width:2\"/&gt;&lt;/svg&gt; 查看样例 cx 属性定义圆点的 x 坐标 cy 属性定义圆点的 y 坐标 rx 属性定义水平半径 ry 属性定义垂直半径 直线1234&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; &lt;line x1=\"0\" y1=\"0\" x2=\"300\" y2=\"300\" style=\"stroke:rgb(99,99,99);stroke-width:2\"/&gt;&lt;/svg&gt; 查看样例 x1 属性在 x 轴定义线条的开始 y1 属性在 y 轴定义线条的开始 x2 属性在 x 轴定义线条的结束 y2 属性在 y 轴定义线条的结束 多边形1234&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; &lt;polygon points=\"220,100 300,210 170,250 123,234\" style=\"fill:#cccccc;stroke:#000000;stroke-width:1\"/&gt;&lt;/svg&gt; 查看样例 points 属性定义多边形每个角的 x 和 y 坐标,中间用空格分隔 折线1234&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; &lt;polyline points=\"0,0 0,20 20,20 20,40 40,40 40,60\" style=\"fill:white;stroke:red;stroke-width:2\"/&gt;&lt;/svg&gt; 查看样例 points 属性定义多边形每个角的 x 和 y 坐标,中间用空格分隔 路径1234&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; &lt;path d=\"M250 150 L150 350 L350 350 Z\" style=\"fill:white;stroke:red;stroke-width:2\"/&gt;&lt;/svg&gt; 查看样例 path 属性定义了一条路径，它开始于位置 250 150，到达位置 150 350，然后从那里开始到 350 350，最后在 250 150 关闭路径M = movetoL = linetoH = horizontal linetoV = vertical linetoC = curvetoS = smooth curvetoQ = quadratic Belzier curveT = smooth quadratic Belzier curvetoA = elliptical ArcZ = closepath 文本1234567891011&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt; &lt;defs&gt; &lt;path id=\"path1\" d=\"M75,20 a1,1 0 0,0 100,0\" /&gt; &lt;/defs&gt; &lt;text x=\"10\" y=\"100\" fill=\"red\" transform=\"rotate(30 20,40)\" style=\"fill:red;\"&gt; &lt;textPath xlink:href=\"#path1\"&gt;I love SVG In Text Path&lt;/textPath&gt; &lt;a xlink:href=\"http://www.whoosh.site/\" target=\"_blank\"&gt; &lt;tspan x=\"10\" y=\"45\"&gt; I love SVG&lt;/tspan&gt; &lt;/a&gt; &lt;/text&gt;&lt;/svg&gt; 查看样例 x 属性定义文本的左侧位置 y 属性定义文本的顶端位置 transform 属性定义空间转换，位移translate, 旋转rotate, 缩放scale, 斜切skew 样式Stroke12345678&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; &lt;g fill=\"none\" stroke=\"black\" stroke-width=\"4\"&gt; &lt;path stroke=\"red\" d=\"M5 20 l215 0\" /&gt; &lt;path stroke-width=\"4\" d=\"M5 40 l215 0\" /&gt; &lt;path stroke-linecap=\"round\" d=\"M5 60 l215 0\" /&gt; &lt;path stroke-dasharray=\"20,10,5,5,5,10\" d=\"M5 80 l215 0\" /&gt; &lt;/g&gt;&lt;/svg&gt; 查看样例 stroke：定义一条线，文本或元素轮廓颜色 stroke-width：定义了一条线，文本或元素轮廓厚度 stroke-linecap：定义不同类型的开放路径的终结 stroke-dasharray：定义用于创建虚线 滤镜在 SVG 中，可用的滤镜有： feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feFlood feGaussianBlur feImage feMerge feMorphology feOffset feSpecularLighting feTile feTurbulence feDistantLight fePointLight feSpotLight模糊效果 123456789&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt; &lt;defs&gt; &lt;filter id=\"Gaussian_Blur\"&gt; &lt;feGaussianBlur in=\"SourceGraphic\" stdDeviation=\"3\" /&gt; &lt;/filter&gt; &lt;/defs&gt; &lt;ellipse cx=\"200\" cy=\"150\" rx=\"70\" ry=\"40\" style=\"fill:#ff0000;stroke:#000000;stroke-width:2;filter:url(#Gaussian_Blur)\"/&gt;&lt;/svg&gt; 查看样例 &lt;filter&gt; 标签的 id 属性可为滤镜定义一个唯一的名称（同一滤镜可被文档中的多个元素使用） filter:url 属性用来把元素链接到滤镜。当链接滤镜 id 时，必须使用 # 字符 滤镜效果是通过 &lt;feGaussianBlur&gt; 标签进行定义的。fe 后缀可用于所有的滤镜 &lt;feGaussianBlur&gt; 标签的 stdDeviation 属性可定义模糊的程度 in=&quot;SourceGraphic&quot; 这个部分定义了由整个图像创建效果 阴影12345678910111213&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; &lt;defs&gt; &lt;filter id=\"f1\" x=\"0\" y=\"0\" width=\"200%\" height=\"200%\"&gt; &lt;feOffset result=\"offOut\" in=\"SourceGraphic\" dx=\"20\" dy=\"20\" /&gt; &lt;feColorMatrix result=\"matrixOut\" in=\"offOut\" type=\"matrix\" values=\"0.2 0 0 0 0 0 0.2 0 0 0 0 0 0.2 0 0 0 0 0 1 0\" /&gt; &lt;feGaussianBlur result=\"blurOut\" in=\"matrixOut\" stdDeviation=\"10\" /&gt; &lt;feBlend in=\"SourceGraphic\" in2=\"blurOut\" mode=\"normal\" /&gt; &lt;/filter&gt; &lt;/defs&gt; &lt;rect width=\"90\" height=\"90\" stroke=\"green\" stroke-width=\"3\" fill=\"yellow\" filter=\"url(#f1)\" /&gt;&lt;/svg&gt; 查看样例 &lt;filter&gt;元素id属性定义一个滤镜的唯一名称 &lt;rect&gt;元素的滤镜属性用来把元素链接到”f1”滤镜 &lt;feOffset&gt;偏移一个矩形（带） &lt;feBlend&gt;混合偏移图像顶部 &lt;feColorMatrix&gt;过滤器是用来转换偏移的图像使之更接近黑色的颜色。 ‘0.2’矩阵的三个值都获取乘以红色，绿色和蓝色通道。降低其值带来的颜色至黑色（黑色为0） &lt;feGaussianBlur&gt;元素的stdDeviation属性定义了模糊量 渐变1234567891011121314151617&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; &lt;defs&gt; &lt;linearGradient id=\"orange_red\" x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"0%\"&gt; &lt;stop offset=\"0%\" style=\"stop-color:rgb(255,255,0);stop-opacity:1\"/&gt; &lt;stop offset=\"100%\" style=\"stop-color:rgb(255,0,0);stop-opacity:1\"/&gt; &lt;/linearGradient&gt; &lt;/defs&gt; &lt;ellipse cx=\"200\" cy=\"190\" rx=\"85\" ry=\"55\" style=\"fill:url(#orange_red)\"/&gt; &lt;defs&gt; &lt;radialGradient id=\"grey_blue\" cx=\"50%\" cy=\"50%\" r=\"50%\" fx=\"50%\" fy=\"50%\"&gt; &lt;stop offset=\"0%\" style=\"stop-color:rgb(200,200,200);stop-opacity:0\"/&gt; &lt;stop offset=\"100%\" style=\"stop-color:rgb(0,0,255);stop-opacity:1\"/&gt; &lt;/radialGradient&gt; &lt;/defs&gt; &lt;ellipse cx=\"230\" cy=\"200\" rx=\"110\" ry=\"100\" style=\"fill:url(#grey_blue)\"/&gt;&lt;/svg&gt; 查看样例 &lt;linearGradient&gt; 标签的 id 属性可为渐变定义一个唯一的名称 fill:url(#orange_red) 属性把 ellipse 元素链接到此渐变 &lt;linearGradient&gt; 标签的 x1、x2、y1、y2 属性可定义渐变的开始和结束位置 渐变的颜色范围可由两种或多种颜色组成。每种颜色通过一个 标签来规定。offset 属性用来定义渐变的开始和结束位置 &lt;radialGradient&gt; 标签的 id 属性可为渐变定义一个唯一的名称，fill:url(#grey_blue) 属性把 ellipse 元素链接到此渐变，cx、cy 和 r 属性定义外圈，而 fx 和 fy 定义内圈 渐变的颜色范围可由两种或多种颜色组成。每种颜色通过一个 标签来规定。offset 属性用来定义渐变的开始和结束位置。 参考网站菜鸟教程W3CSchoolSVG模板","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://www.whoosh.site/categories/前端技术/"}],"tags":[{"name":"Svg","slug":"Svg","permalink":"http://www.whoosh.site/tags/Svg/"}]},{"title":"使用PhantomJS实现服务端截屏","slug":"20170303_使用PhantomJS实现服务端截屏","date":"2017-03-03T03:13:58.000Z","updated":"2018-03-18T02:41:47.798Z","comments":true,"path":"2017/03/03/20170303_使用PhantomJS实现服务端截屏/","link":"","permalink":"http://www.whoosh.site/2017/03/03/20170303_使用PhantomJS实现服务端截屏/","excerpt":"","text":"简介在一些前端项目中，有时会需要对页面或者某个div进行截屏，常见的方式是使用html2canvas来实现，这个方式的好处是显而易见的。但是，有时候也会出现以外，例如笔者碰到将复杂的svg截屏之后，发现图片与页面展示不一致，为了解决这个问题，查阅了很多资料。最后，通过PhantomJS实现了这个功能。 PhantomJS介绍PhantomJS是一个服务器端的JavaScriptAPI的WebKit。它使用QtWebKit作为它核心浏览器的功能，作为隐形的浏览器，提供了诸如CSS选择器、支持Web标准、DOM操作、JSON、HTML5、Canvas、SVG等（WebGL、Flash、Video、Audio、CSS 3D是不支持的），同时也提供了处理文件I/O的操作，从而使你可以向操作系统读写文件等。PhantomJS的用处非常广泛，诸如网络监测、网页截屏、无需浏览器的 Web 测试、页面访问自动化等。 PhantomJS使用目前官方支持windows\\Mac OS\\Linux三大主流的环境的运行包，你可以根据你的运行环境选择要下载的包。下载地址：http://phantomjs.org/download.html 笔者的运行环境是win10，下载完成后解压文件，将bin目录下的phantomjs.exe和examples目录下的hello.js放到一个文件目录下，然后在cmd下运行phantomjs.exe，结果如下图。 phantomjs的命令格式如下： 1phantomjs [options] somescript.js [arg1 [arg2 [...]]] 详细介绍参见Command Line Interface 接下来介绍如何实现服务端截屏功能，编写screenshot.js文件，先介绍下webpage、system、fs。 webpage:主要是提供了一套可以访问和操作web文档的核心方法，包括操作DOM、事件捕获、用户事件模拟等等。 system:该模块提供了一些与操作系统相关的接口，例如访问操作系统信息、访问系统环境变量、接受命令行参数等等与程序执行相关的系统信息。 fs:即FileSystem（类似NodeJS）。fs提供了执行文件I/O操作的标准接口，如读写文件、删除文件等。它使得你持久化一些文件（如logfile等）变得非常容易。 12345678910111213141516171819202122232425262728293031323334353637383940414243\"use strict\";/** * phantomjs screenshot.js \"http://192.168.14.180/index.html\" \"image/456.png\" * phantomjs screenshot.js \"wwwroot/index.html\" \"image/456.png\"*/var page = require('webpage').create();var system = require('system');var address, output;if (system.args.length &lt; 3 || system.args.length &gt; 5) &#123; phantom.exit(1);&#125; else &#123; address = system.args[1]; output = system.args[2]; //定义宽高 page.viewportSize = &#123; width: 1000, height: 800 &#125;; page.open(address, function (status) &#123; if (status == 'success') &#123; var bb = page.evaluate(function () &#123; return document.getElementsByTagName('html')[0].getBoundingClientRect(); &#125;); page.clipRect = &#123; top: bb.top, left: bb.left, width: bb.width, height: bb.height &#125;; window.setTimeout(function () &#123; //保存图片或者pdf，根据文件后缀名自动判断 page.render(output); page.close(); console.log('渲染成功...'); phantom.exit(); &#125;, 1000); &#125; else &#123; page.close(); phantom.exit(); &#125; &#125;);&#125; 在服务端定义一个方法，该方法创建一个cmd进程，让这个进程调用phantomjs命令格式即可。 12345678910111213141516171819202122232425262728/// &lt;summary&gt;/// 进行截图/// &lt;/summary&gt;/// &lt;param name=\"webPageUrl\"&gt;截图网页链接&lt;/param&gt;/// &lt;param name=\"imagePath\"&gt;截图生成的文件存放的路径及其文件名&lt;/param&gt;/// &lt;param name=\"serverPath\"&gt;phantomjs.exe与screenshot.js所在目录的路径&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool GetImg(string webPageUrl, string imagePath, string serverPath)&#123; try &#123; //实例化进程 //phantomjs.exe screenshot.js \"wwwroot/index.html\" \"image/456.png\" Process p = new Process(); p.StartInfo.FileName = serverPath + @\"\\phantomjs.exe\"; p.StartInfo.WorkingDirectory = serverPath + @\"\\\"; p.StartInfo.Arguments = string.Format(serverPath + @\"\\screenshot.js \" + webPageUrl + \" \" + imagePath); p.StartInfo.CreateNoWindow = true; p.StartInfo.WindowStyle = ProcessWindowStyle.Hidden; p.Start(); return true; &#125; catch (Exception ex) &#123; Console.WriteLine(ex.Message); return false; &#125;&#125; 无浏览器图形界面项目 软件名 介绍 支持语言 Awesomium 基于Chromium无图形界面浏览器引擎。 C++,.NET benv Benv是node.js开发的无界面浏览器测试环境，用于测试客户端代码。 JavaScript browser-launcher Browser-Launcher可以检测系统上的所有浏览器版本，并在一个独立的配置文件中启动它们，用于自动测试。 JavaScript browser.rb 无界面Ruby浏览器。 Ruby Browserjet 无界面webkit浏览器，采用node.js接口。 JavaScript BrowserKit 可模拟浏览器的行为。 PHP CasperJS CasperJS是一个开源的导航脚本和测试工具，使用JavaScript基于 PhantomJS 编写，用于测试Web应用功能，PhantomJS是一个服务器端的JavaScriptAPI的WebKit。其支持各种Web标准：DOM处理,CSS选择器,JSON,Canvas,和SVG。 JavaScript DalekJS DalekJS 是一个基于JavaScript（或Node.js）的免费和开源的自动化测试接口。它能够同时运行测试一组流行的浏览器（Chrome，IE，Firefox和WebKit）。 JavaScript Erik Erik是一款基于WebKit的无界面浏览器，可用于功能函数的测试，使用JavaScript对网页进行操作访问。 Swift Geb Geb是浏览器自动化（browserautomation）测试解決方案。 Groovy ghost ghost.py是一个Python的Webkit的Web客户端。 Python Ghostbuster Ghostbuster是一款自动化浏览器测试工具，基于phantomjs，意味着你得到一个仿真浏览器，一个真正的DOM，仿真测试环境。 JavaScript grope Grope是无ＧUI浏览器环境，使用WebKitFramework+RubyCocoa。 Ruby Guillotine Guillotine是一款采用C#开发的.NET无界面浏览器。 .NET Headless Headless是一款无界面浏览器，支持快速网络接受测试，采用.Net环境。 .NET headless_browser Headless-Browser是一款采用C++开发的基于WebKit无界面浏览器。 C++ HeadlessBrowser HeadlessBrowser是一款轻量级无图形界面浏览器，用于DOM测试。 JavaScript HtmlUnit HtmlUnit是一个isa”Java程序GUI-Less浏览器”。 Java Jabba-Webkit Jabba-Webkit是一款无图形化WebKit浏览器，主要用来抓取Ajax网页。 Python Jasmine-Headless-Webkit Jasmine-Headless-Webkit是一款基于jasmine的无图形化web工具。 Python,JavaScript,Ruby Jaunt JavaWeb网页抓取&amp;自动化API Java jBrowserDriver jBrowserDriver是一款采用纯Java编写的无图形化浏览器，基于WebKit，和Selenium兼容。 Java jedi-crawler Jedi-Crawler是一款轻量级 Node/PhantomJS爬虫，可以动态的抓取网页内容。 JavaScript Lotte Lotte是一款自动化无图形化浏览器测试工具，采用phantomJs。 JavaScript MechanicalSoup MechanicalSoup是一个与网站自动交互Python库。 Python mechanize 状态编程的Web浏览。 Python Nightmare 高层次浏览器自动化库，构建于PhantomJS。 JavaScript PhantomJS PhantomJS是一个服务器端的JavaScriptAPI的WebKit JavaScript,Python,Ruby,Java,C#,Haskell,Objective-C,Perl,PHP,R(via Selenium) phantompy Phantompy是一款headlessWebKit引擎，构建于强大的 Qt5WebkitAPI之上。 Python Python-Webkit Python-Webkit是一个Webkitpython扩展，可完整的访问网页的DOM。 Python RoboBrowser RoboBrowser是一款简单的浏览网页的Pythonic库，无需依赖独立的浏览器。 Python Selenium 跨平台自动化web浏览器。 JavaScript,Python,Ruby,Java,C#,Haskell,Objective-C,Perl,PHP,R SimpleBrowser SimpleBrowser是专门为自动化任务而设计的一个灵活而直观的浏览器引擎，内置.Net4framework。 .NET SlimerJS SlimerJS是一个提供给 Web 开发人员，可通过脚本编程控制的浏览器。 JavaScript Splash Splash是一款HTTPAPI轻量级浏览器，采用Python和ＱT开发。 Any Splinter Splinter是一个用Python编写的Web应用程序进行验收测试的工具。 Python Spynner Spynner是一个可编程Web浏览器Python模块。支持AJAX。 Python SST SST(selenium-simple-test)是一个Web测试框架，使用Python来生成基于浏览器的功能测试。 Python stanislaw Stanislaw一款Pythonheadless浏览器测试工具。 Python trifleJS 一个headlessIE浏览器。采用.NETWebBrowser类，拥有JavascriptAPI，运行在V8引擎。 JavaScript twill Twill是一种简单的语言，允许用户通过一个命令行界面浏览网页。 Python WatiN Watin是一个面向.net的Web自动化测试开源项目，对应Web元素提供了丰富的类库，而且使用起来非常简单。 .NET Watir-WebDriver Watir的实现基于WebDriver的Ruby绑定。 Ruby WKZombie WKZombie是针对iOS/OSX的不需要用户界面或API就能进行网站导航和数据收集的一个Swift框架，也被称为无界面浏览器。 Swift Zombie.js 一个轻量级的框架，用于在一个模拟的环境中测试客户端的JavaScript代码。Zombie.js使用Node.js实现快速的headlessfull-stack测试平台。 JavaScript","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://www.whoosh.site/categories/浏览器/"}],"tags":[{"name":"PhantomJS","slug":"PhantomJS","permalink":"http://www.whoosh.site/tags/PhantomJS/"}]},{"title":"ReactNative自学04-Props和State","slug":"20161127_ReactNative自学04_Props和State","date":"2016-11-27T14:37:58.000Z","updated":"2018-04-07T14:37:43.639Z","comments":true,"path":"2016/11/27/20161127_ReactNative自学04_Props和State/","link":"","permalink":"http://www.whoosh.site/2016/11/27/20161127_ReactNative自学04_Props和State/","excerpt":"","text":"概述我们使用两种数据来控制一个组件：props和state。 无状态组件 — 只有 props, 没有 state。 除去render() 函数和所有围绕props的逻辑之外，没有什么要关心的地方。这使他们易于理解且易于测试 有状态组件 — 既有 props 又有 state。也被称作状态管理者 。他们负责客户端-服务器通信(通过XHR, web sockets, 等)，数据处理和给用户行为反馈。 Propsprops是一个组件的配置选项。是由上到下指定且不可改变的。一个组件不能改变自身的props, 但要负责设置子组件的 props。例如，在Greeting组件中将name作为一个属性来定制，这样可以复用这一组件来制作各种不同的“问候语”。1234567891011121314151617181920import React, &#123; Component &#125; from 'react';import &#123; Text, View &#125; from 'react-native';class Greeting extends Component &#123; render() &#123; return ( &lt;Text&gt;Hello &#123;this.props.name&#125;!&lt;/Text&gt; ); &#125;&#125;export default class LotsOfGreetings extends Component &#123; render() &#123; return ( &lt;View style=&#123;&#123;alignItems: 'center'&#125;&#125;&gt; &lt;Greeting name='React Native' /&gt; &lt;/View&gt; ); &#125;&#125; State对于需要改变的数据，我们需要使用state（状态）。在ES6中，我们在constructor中初始化state。在ES5中，使用的是getInitialState方法来初始化state（这一做法会逐渐被淘汰）。 123456789101112131415import React, &#123; Component &#125; from 'react';class Test extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; showText: true &#125;; // 每1000毫秒对showText状态做一次取反操作 setInterval(() =&gt; &#123; this.setState(previousState =&gt; &#123; return &#123; showText: !previousState.showText &#125;; &#125;); &#125;, 1000); &#125;&#125; Props和State对比 操作 Props State 能否在组件内部设置默认值 Yes Yes 能否在组件内部修改 No Yes 能否从父组件获取初始值 Yes No 能否由父组件修改 Yes No 能否设置子组件初始值 Yes No 能否修改子组件的值 Yes No 相同点 props和state改变，都会引发render的重新渲染。 都能由自身组件的相应初始化函数设定初始值。 不同点 初始值来源：props来自于父组件或者自身getDefaultProps，state的初始值来自于自身的getInitalState（constructor）函数。 修改方式：props只能由父组件修改，不能在自身组件修改，state只能在自身组件中setState修改，不能由父组件修改。 对子组件：props是一个父组件传递给子组件的数据流，这个数据流可以一直传递到子孙组件，state代表的是一个组件内部自身的状态，只能在自身组件中存在。 Tips 尝试把尽可能多的组件无状态化。 state应该包括那些可能被组件的事件处理器改变并触发用户界面更新的数据。 尽可能使用 props 来作为组件外部数据来源。","categories":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://www.whoosh.site/categories/ReactNative/"}],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://www.whoosh.site/tags/ReactNative/"}]},{"title":"ReactNative自学03-组件的生命周期","slug":"20161115_ReactNative自学03_组件的生命周期","date":"2016-11-15T12:30:58.000Z","updated":"2018-04-07T14:05:56.650Z","comments":true,"path":"2016/11/15/20161115_ReactNative自学03_组件的生命周期/","link":"","permalink":"http://www.whoosh.site/2016/11/15/20161115_ReactNative自学03_组件的生命周期/","excerpt":"","text":"组件的生命周期概述一般说到组件的生命周期，基本上都会遵循创建、运行、销毁三个过程，RN组件的生命周期也如此。下面是在网上转载的RN生命周期流程图。 创建按照构造函数-&gt;componentWillMount-&gt;render-&gt;componentDidMount顺序依次执行，这个过程在组件的生命周期中只执行一次。等componentDidMount执行完毕之后，组件就进入了运行状态。 void getDefaultProps() 调用：组件创建前调用，多个实例间共享引用。仅调用一次。 目的：获取父组件传递过来的Props，如果Props和该函数中定义的Props的key一样，将会被覆盖。 void getInitState() 调用：组件创建前调用。仅调用一次。 目的：初始化组件内部的状态值，ES6中时在constructor中初始化state，ES5中使用的是getInitialState方法来初始化state（这一做法会逐渐被淘汰），建议初始化state的时候尽可能给每一个可能用到的值都赋一个初始值，避免在使用中出现空值。 void componentWillMount() 调用：组件挂载前触发。仅调用一次。 目的：常用于改变state的操作。 void render() 调用：渲染组件时。至少调用一次(在运行过程中也可能会调用)。 目的：渲染函数，返回一个Virtual DOM。在函数内部尽量保持纯净，只渲染组件，不修改状态，不执行副操作（如计时器、网络操作等）。 void componetDidMount() 调用：组件挂载结束触发。仅调用一次。 目的：在该函数中修改状态、执行网络请求、定时器开启等相关操作。 运行运行过程实际上就是监测props和state是否发生改变，当props发生改变后，会先回调componentWillReceiveProps并传入新的props。然后会执行更新界面相关的一系列回调方法。 当state发生改变后，会执行更新相关的回调方法。 void componentWillReceiveProps(nextProps) 调用：组件接收到新的props时被调用。 目的：新的props将会作为参数传递进来，老的props可以根据this.props来获取。另外，可以在该函数中对state作一些处理。且在该函数中更新state不会引起二次渲染。 bool shouldComponentUpdate(nextProps, nextState) 调用：组件接收到新的props和state时被调用。 目的：该函数主要对传递过来的nextProps和nextState作判断。如果返回true则重新渲染，如果返回false则不重新渲染。 void componentWillUpdate(prevProps, prevState) 调用：props或者state改变，且shouldComponentUpdate方法返回true时 目的：和初始化中的componentWillMount函数功能类似。可以在这个函数中为即将发生的重新渲染做一些准备，但不能在这个函数中通过this.setState再次改变状态机变量的值组件。 void render() 调用：组件重新渲染时调用。 目的：和初始化中的render函数功能类似。重新渲染组件，返回一个新的Virtual DOM。 void componentDidUpdate(prevProps, prevState) 调用：组件重新渲染完成后调用。 目的：和初始化中的componentDidMount函数功能类似。在该函数中修改状态、执行网络请求、定时器开启等相关操作 销毁当组件将要被卸载时，会先调用componentWillUnmount函数。 void componentWillUnmount() 调用：组件卸载和销毁之前调用。仅调用一次。 目的：进行定时器，监听等操作的销毁工作。","categories":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://www.whoosh.site/categories/ReactNative/"}],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://www.whoosh.site/tags/ReactNative/"}]},{"title":"ReactNative自学02-ES6语法","slug":"20161031_ReactNative自学02-ES6语法","date":"2016-10-31T11:34:58.000Z","updated":"2018-03-11T13:37:07.273Z","comments":true,"path":"2016/10/31/20161031_ReactNative自学02-ES6语法/","link":"","permalink":"http://www.whoosh.site/2016/10/31/20161031_ReactNative自学02-ES6语法/","excerpt":"","text":"简介ECMAScript 6.0（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 JavaScript的创造者Netscape公司，之后将JavaScript提交给国际标准化组织ECMA，希望这种语言能够成为国际标准，ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现， 之所以不叫JavaScript，主要是由于以下两个原因： 商标，Java是Sun公司的商标，根据授权协议，只有Netscape公司可以合法地使用JavaScript这个名字，且JavaScript本身也已经被Netscape公司注册为商标。 想体现这门语言的制定者是ECMA，不是Netscape，这样有利于保证这门语言的开放性和中立性。 变量在线将ES6代码转为ES5代码Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。这意味着，你可以用ES6的方式编写程序，又不用担心现有环境是否支持。 变量声明ES5只有2种声明变量的方法：var、function ES6共有6种声明变量的方法：var、function、let、const、import(require)、class。 1.var命令123456789101112131415161718var a = 10;var b = 20;var c = 30;var a = 10,b = 20,c = 30;var arr = [1,2,3,4,5];var a = arr[0];var b = arr[1];var c = arr[3];var obj = &#123; name: 'gary', age: 20&#125;var a = obj.name;var b = obj.age; 没有用var关键字，使用直接赋值方式声明的是全局变量，例如：1a = 10; 全局对象是最顶层的对象，在浏览器环境指的是window对象，在Node.js指的是global对象。ES5之中，全局对象的属性与全局变量是等价的。1234window.a = 1;a // 1a = 2;window.a // 2 2.function命令var 方式定义的函数，不能先调用函数，后声明，只能先声明函数，然后调用。function方式定义函数可以先调用，后声明。1234567891011aaa();//这样调用就会出错 var aaa = function()&#123; alert(\"aaa\"); &#125; aaa();//这样就不会出错 //先调用后声明 bbb(); function bbb()&#123; alert(\"bbb\"); &#125; 3.let命令 块级有效 ES5只有全局作用域和函数作用域，没有块级作用域，在ES6中，let实际上为JavaScript新增了块级作用域。 用来声明变量，用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; for循环的计数器，就很合适使用let命令。例如：1234567891011121314151617var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[5](); //10a[6](); // 10var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[5](); //5a[6](); // 6 变量提升 let不像var那样会发生“”现象1234console.log(foo); // 输出undefinedconsole.log(bar); // 报错ReferenceErrorvar foo = 2;let bar = 2; 实测结果两个都是undefined，应该是网上资料错误，可以通过Babel来了解底层原理 暂时性死区 只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。12345678910var tmp='dev';if (true) &#123; console.log(tmp); let tmp; console.log(tmp); tmp = 123; console.log(tmp);&#125; 在let命令声明变量tmp之前，都属于变量tmp的“死区”。 不允许重复声明 let不允许在相同作用域内，重复声明同一个变量。12345678910// 报错function test() &#123; let a = 10; var a = 1;&#125;// 报错function test() &#123; let a = 10; let a = 1;&#125; 因此，不能在函数内部重新声明参数。12345678function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; 4.const命令const声明一个只读的常量。一旦声明，就必须立即初始化，不能留到以后赋值。也不能改变。123const PI = 3.1415;console.log(PI); // 3.1415PI = 3;// TypeError: Assignment to constant variable. const的作用域与let命令相同：只在声明所在的块级作用域内有效，声明的常量，也与let一样不可重复声明。 const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。1234const foo = &#123;&#125;;foo.prop = 123;console.log(foo.prop);// 123foo = &#123;&#125;; // TypeError: \"foo\" is read-only var命令和function命令声明的全局变量，依旧是全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。也就是说，从ES6开始，全局变量将逐步与全局对象的属性脱钩。123456var a = 1;// 如果在Node的REPL环境，可以写成global.a// 或者采用通用方法，写成this.awindow.a // 1let b = 1;window.b // undefined 5.import命令(模块)模块的功能主要由 export 和 import 组成.每一个模块都有自己单独的作用域，模块之间的相互调用关系是通过 export 来规定模块对外暴露的接口，通过import来引用其它模块提供的接口。同时还为模块创造了命名空间，防止函数的命名冲突。 ES6将一个文件视为一个模块，通过export 向外输出了一个变量。一个模块也可以同时往外面输出多个变量。1234//test.jsvar name = 'Rainbow';var age = '24';export &#123;name, age&#125;; 定义好模块的输出以后就可以在另外一个模块通过import引用。1import &#123;name, age&#125; from './test.js' 整体输入，module指令1234567//test.jsexport function getName() &#123; return name;&#125;export function getAge()&#123; return age;&#125; 通过 import * as 就完成了模块整体的导入。1import * as test form './test.js'; 通过指令 module 也可以达到整体的输入。12module test from 'test.js';test.getName(); 不用关心模块输出了什么，通过 export default 指令就能加载到默认模块，不需要通过 花括号来指定输出的模块,一个模块只能使用 export default 一次123456789101112// default 导出export default function getAge() &#123;&#125; // 或者写成function getAge() &#123;&#125;export default getAge;// 导入的时候不需要花括号import test from './test.js';// 一条import 语句可以同时导入默认方法和其它变量.import defaultMethod, &#123; otherMethod &#125; from 'xxx.js'; 7.class命令如果你用过纯面向对象语言，那么你会对class的语法非常熟悉。1234567891011class People &#123; constructor(name) &#123; //构造函数 this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;var p = new People(\"Tom\");p.sayName(); 上面定义了一个People类，他有一个属性 name 和一个方法 sayName()，还有一个构造函数。 就像函数有函数声明和函数表达式两种定义方式，类也可以通过类表达式来定义： 1234567891011121314151617181920212223let People = class &#123; constructor(name) &#123; //构造函数 this.name = name; &#125; sayName() &#123; console.log(this.name); &#125; &#125;``` 你可能以为类声明和类表达式的区别在于变量提升的不同。但是事实是无论是类声明还是类表达式的方式来定义，都不会有变量提升。通过关键字 extends 来继承一个类，并且，可以通过 super 关键字来引用父类。```jsclass Student extends People &#123; constructor(name, grade) &#123; //构造函数 super(name); //通过 super 调用父类的构造函数的。 this.grade = grade; &#125; sayGrade() &#123; console.log(this.grade); &#125;&#125; 上面的例子中我们定义了一个 Student ，他是 People 的子类。下面我们给 name 属性定义 getter 和 setter123456789101112131415161718class People &#123; constructor(name) &#123; //构造函数 this.name = name; &#125; get name() &#123; return this._name.toUpperCase(); &#125; set name(name) &#123; this._name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;var p = new People(\"tom\");console.log(p.name); //TOMconsole.log(p._name); //tomp.sayName(); //TOM 仔细看上面的例子，搞清楚最后三行分别会输出什么，就明白getter 和 setter该怎么用了。 主要是要区分 this._name 和 this.name 的区别。因为我们定义了 name 的读写器，而没有定义 _name 的读写器，所以访问这两个属性的结果是不同的。 但是要注意一点，不要这样写：123set name(name) &#123; this.name = name;&#125; 因为给 this.name 赋值的时候会调用 set name ，这样会导致无限递归直到栈溢出。 通过 static 关键字定义静态方法：123456789101112class People &#123; constructor(name) &#123; //构造函数 this.name = name; &#125; sayName() &#123; console.log(this.name); &#125; static formatName(name) &#123; return name[0].toUpperCase() + name.sustr(1).toLowerCase(); &#125;&#125;console.log(People.formatName(\"tom\")); 解构赋值ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 模式匹配只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。 如果解构不成功，变量的值就等于undefined。12345678910111213141516171819202122232425let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [x, , y] = [1, 2, 3];//不完全解构x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // \"a\"y // undefinedz // []//解构赋值允许指定默认值。var [foo = true] = [];foo // true[x, y = 'b'] = ['a']; // x='a', y='b'[x, y = 'b'] = ['a', undefined]; // x='a', y='b' 注意，ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError 解构赋值不仅适用于var命令，也适用于let和const命令。123var [v1, v2, ..., vN ] = array;let [v1, v2, ..., vN ] = array;const [v1, v2, ..., vN ] = array; 对于Set结构，也可以使用数组的解构赋值。12let [x, y, z] = new Set([\"a\", \"b\", \"c\"]);x // \"a\" 对象的解构赋值解构不仅可以用于数组，还可以用于对象。123var &#123; foo, bar &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;foo // \"aaa\"bar // \"bbb\" 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。123456var &#123; bar, foo &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;foo // \"aaa\"bar // \"bbb\"var &#123; baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;baz // undefined 如果变量名与属性名不一致，必须写成下面这样。123456var &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;baz // \"aaa\"let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world' 这实际上说明，对象的解构赋值是下面形式的简写。1var &#123; foo: foo, bar: bar &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;; 也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。123var &#123; foo: baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;baz // \"aaa\"foo // error: foo is not defined 变量的解构赋值变量的声明和赋值是一体的。对于let和const来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。1234let foo;let &#123;foo&#125; = &#123;foo: 1&#125;; // SyntaxError: Duplicate declaration \"foo\"let baz;let &#123;bar: baz&#125; = &#123;bar: 1&#125;; // SyntaxError: Duplicate declaration \"baz\" 上面代码中，解构赋值的变量都会重新声明，所以报错了。不过，因为var命令允许重新声明，所以这个错误只会在使用let和const命令时出现。如果没有第二个let命令，上面的代码就不会报错。 如果要将一个已经声明的变量用于解构赋值，必须非常小心。1234// 错误的写法var x;&#123;x&#125; = &#123;x: 1&#125;;// SyntaxError: syntax error 上面代码的写法会报错，因为JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。12// 正确的写法(&#123;x&#125; = &#123;x: 1&#125;); 数组的解构赋值由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。1234var arr = [1, 2, 3];var &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3 结构的解构赋值和数组一样，解构也可以用于嵌套结构的对象。123456789var obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;var &#123; p: [x, &#123; y &#125;] &#125; = obj;x // \"Hello\"y // \"World\" 注意，这时p是模式，不是变量，因此不会被赋值。123456789101112var node = &#123; loc: &#123; start: &#123; line: 1, column: 5 &#125; &#125;&#125;;var &#123; loc: &#123; start: &#123; line &#125;&#125; &#125; = node;line // 1loc // error: loc is undefinedstart // error: start is undefined 默认值生效的条件是，对象的属性值严格等于undefined。 字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。123456const [a, b, c, d, e] = 'hello';a // \"h\"b // \"e\"c // \"l\"d // \"l\"e // \"o\" 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。12let &#123;length : len&#125; = 'hello';len // 5 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。1234let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。 函数参数的解构解构赋值的规则是，只要等号右边的值不是对象，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。12let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 函数参数的解构也可以使用默认值。1234567function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。1234567function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0] 函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。 事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。12345678910function* fibs() &#123; var a = 0; var b = 1; while (true) &#123; yield a; [a, b] = [b, a + b]; &#125;&#125;var [first, second, third, fourth, fifth, sixth] = fibs();sixth // 5 解构赋值用途 交换变量的值1[x, y] = [y, x]; 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。 从函数返回多个值函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。 12345678910111213// 返回一个数组function example() &#123; return [1, 2, 3];&#125;var [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;var &#123; foo, bar &#125; = example(); 函数参数的定义 解构赋值可以方便地将一组参数与变量名对应起来。123456// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 提取JSON数据 解构赋值对提取JSON对象中的数据，尤其有用。12345678var jsonData = &#123; id: 42, status: \"OK\", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, \"OK\", [867, 5309] 上面代码可以快速提取JSON数据的值。 函数参数的默认值1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;; 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || &#39;default foo&#39;;这样的语句。 遍历Map结构任何部署了Iterator接口的对象，都可以用for…of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。12345678var map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + \" is \" + value);&#125;// first is hello// second is world 如果只想获取键名，或者只想获取键值，可以写成下面这样。12345678// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; 输入模块的指定方法 加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。1const &#123; SourceMapConsumer, SourceNode &#125; = require(\"source-map\"); 编程风格采用严格模式：use strict主要有以下限制： 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀0表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global* [prop] eval不会在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface） let取代var在块级作用域下，let完全可以取代var，因为两者语义相同，而且let没有副作用。 在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。所有的函数都应该设置为常量。这符合函数式编程思想，有利于将来的分布式运算。const声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。 长远来看，JavaScript可能会有多线程的实现（比如Intel的River Trail那一类的项目），这时let表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。 字符串静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。 解构赋值使用数组成员对变量赋值时，优先使用解构赋值。 函数的参数如果是对象的成员，优先使用解构赋值。 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。 对象单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。 另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。 数组使用扩展运算符（…）拷贝数组。 使用Array.from方法，将类似数组的对象转为数组。 函数立即执行函数可以写成箭头函数的形式。 那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了this。 简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。 不要在函数体内使用arguments变量，使用rest运算符（…）代替。因为rest运算符显式表明你想要获取参数，而且arguments是一个类似数组的对象，而rest运算符可以提供一个真正的数组。 Map结构注意区分Object和Map，只有模拟现实世界的实体对象时，才使用Object。如果只是需要key: value的数据结构，使用Map结构。因为Map有内建的遍历机制。 Class总是用Class，取代需要prototype的操作。因为Class的写法更简洁，更易于理解。 使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。 模块首先，Module语法是JavaScript模块的标准写法，坚持使用这种写法。使用import取代require。 如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，不要export default与普通的export同时使用。 不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。 如果模块默认输出一个对象，对象名的首字母应该大写。 网络资源http://www.w3school.com.cn/js/index.asp http://es6.ruanyifeng.com/ http://babeljs.io/","categories":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://www.whoosh.site/categories/ReactNative/"}],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://www.whoosh.site/tags/ReactNative/"},{"name":"ES6","slug":"ES6","permalink":"http://www.whoosh.site/tags/ES6/"}]},{"title":"ReactNative自学01-基础篇","slug":"20160925_ReactNative自学01-基础篇","date":"2016-09-25T10:59:58.000Z","updated":"2018-03-11T13:37:07.249Z","comments":true,"path":"2016/09/25/20160925_ReactNative自学01-基础篇/","link":"","permalink":"http://www.whoosh.site/2016/09/25/20160925_ReactNative自学01-基础篇/","excerpt":"","text":"React-Native技术背景目前跨平台移动开发主要分一下4个主要流派为：Web流，代码转换流，编译流，和虚拟机流。 Web 流：也被称为 Hybrid 技术，它基于 Web 相关技术来实现界面及功能 代码转换流：将某个语言转成 Objective-C、Java 或 C#，然后使用不同平台下的官方工具来开发 编译流：将某个语言编译为二进制文件，生成动态库或打包成 apk/ipa/xap 文件 虚拟机流：通过将某个语言的虚拟机移植到不同平台上来运行 facebook之前投入了大量精力在html5，虽然取得很大进展，但始终不如人意，后来就转向native开发，性能和体验都近乎完美，但无法摆脱苹果的束缚，在版本更新和维护上非常的麻烦，同时，一些公司采用混合开发模式（Hybrid）即：native+web,但是webview的性能在移动断是受限的，所以也不是一种特别好的模式。 之后，facebook在react框架基础上推出react-native(react.js用于开发网页)，在性能上仅次于native，但比Hybrid和html5优越很多。同时，RN不仅可以使用前端开发的模式开发应用，还可以调用原生应用的UI和组件 现在除了Facebook，很多大公司都在尝试这一技术来降低开发和维护成本，如：淘宝部分功能、qq空间、携程部分产品等，而且微软未来在UWP应用上也会支持RN技术。 搭建开发环境 安装node.js，会自动安装包管理器npm，查看安装结果node -v, npm -v 安装java开发环境，java sdk、java jdk，并配置java环境变量，查看环境变量echo %path% 配置环境变量,在系统环境中添加JAVA_HOME,在Path中添%JAVA_HOME%/bin 安装android开发环境，并配置android环境变量 在系统环境中添加ANDROID_HOME,在Path中添加 %ANDROID_HOME%\\tools %ANDROID_HOME%\\platform_tools 在系统环境中添加CLASSPATH,值：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar 下载Android SDK, Tools:Android SDK Tools、Android SDK Platform-tools、Android SDK Build tools（必须是版本23.0.1） Android 6.0(API23):SDK Platform、Google APIs、Soucre for Android SDK（如果装虚拟机：Google APIs Intel x86 Atom_64 System Image） Extras:Android Support Repository、Android Support Libarary（Obsolete）、Google USB Driver（如果虚拟机：Inter x86 Emulator Accelerate[HAXM install]） 安装代码编辑环境，我使用的是vscode,可以很方便的调试程序，也可以使用WebStorm。首先，安装react native tools插件，安装Bable ES6/Es7插件 安装代码版本工具，git，方便项目管理，和clone开源资源（可选） 第一个RN项目切换npm镜像12npm config set registry https://registry.npm.taobao.orgnpm config set disturl https://npm.taobao.org/dist 安装react-native-cli1npm install react-native-cli -g //全局安装cli 初始化实例1react-native init Mytest NPM加载开源包123npm install //安装project.json中的资源包npm install 包名 -save //最新版本npm install 包名@2.1.1 -save //指定版本 运行RN项目12react-native run-androidreact-native run-ios 其他常用命令1234567adb devices //查看当前连接设备adb reverse tcp:8081 tcp:8081 //重新链接设备adb shell input keyevent 82 //调出开发者菜单npm cache clean //清理npm本地缓存npm kill-server //结束npmnpm start-server //开启npmreact-native upgrade //更新react-native版本 相关资源 RN官网： http://facebook.github.io/react-native/docs/getting-started.html RN中文官网： http://reactnative.cn/ ES语法： http://es6.ruanyifeng.com/ Android资源：http://www.android-studio.org/ npm淘宝镜像：http://npm.taobao.org/ 所用软件：百度网盘 密码：oo3t","categories":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://www.whoosh.site/categories/ReactNative/"}],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://www.whoosh.site/tags/ReactNative/"}]},{"title":"Markdown语法简介","slug":"20160901_Markdown语法简介","date":"2016-09-01T12:30:58.000Z","updated":"2018-03-16T15:20:56.985Z","comments":true,"path":"2016/09/01/20160901_Markdown语法简介/","link":"","permalink":"http://www.whoosh.site/2016/09/01/20160901_Markdown语法简介/","excerpt":"","text":"概述Markdown 是一个 Web 上使用的文本到HTML的转换工具，可以通过简单、易读易写的文本格式生成结构化的HTML文档。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。 Markdown 并非要取代 HTML，而是以一种简单的书写格式，实现一种更加友好的页面呈现，并且，如果所需的标签不在 Markdown 涵盖范围之内，可以直接在文档里面用 HTML 撰写。但要制约的只有一些 HTML 区块元素――比如 &lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt; 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。 另外 Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 &lt;p&gt; 标签，且书写时一定要在 Markdown 标签和内容之间加上空格，例如：# 标题 基本标签段落一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。 如图所示： 换行Markdown 允许段落内的强迫换行，例如直接插入换行符&lt;br/&gt;，如果你确实想要依赖 Markdown 的格式来换行的话，可以在插入处先按入两个以上的空格或者至少一个 Tab 键，然后回车即可。 如图所示： 缩进普通段落不该用空格或制表符来缩进，因为用了也无效，可以通过在段落前添加需要的空格编码，已达到显示效果。 半角空格 &amp;ensp; 或 &amp;#8194; 全角空格 &amp;emsp; 或 &amp;#8195; 不断行空格 &amp;nbsp; 或 &amp;#160; 如图所示： 标题Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。 类 Setext 形式是用底线的形式，利用任意数量的 = （一级标题）和 - （二级标题） 类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 一级 到 六级 如图所示： 列表Markdown 支持有序列表和无序列表。 无序列表使用星号、加号或是减号作为列表标记 有序列表则使用数字接着一个英文句点，如果排序错乱，Markdown 仍会以第一个数字进行排序，所以，第一个项目最好还是从 1. 开始 区块引用Markdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式。 可以自己先将内容断好行，然后在每行的最前面加上在每一行加上 &gt; ，如区块引用1 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ，如区块引用2 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ，如区块引用2，3 如图所示： 代码 如果要标记一小段行内代码，你可以用反引号把它包起来，如： `代码` 如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段 代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号 在代码区段内，&amp; 和方括号都会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易 如图所示： 代码区块在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以 如图所示： 超链接超链接允许两种样式： 行内式和参考式。 行内式的形式为： 方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字 接着一个冒号 接着一个以上的空格或制表符 接着链接的网址 选择性地接着 title 内容，可以用单引号、双引号或是括弧包着，最好使用双引号 参考式的形式为： 在链接文字的括号后面再接上另一个方括号 而在第二个方括号里面要填入用以辨识链接的标记 如图所示： 图片Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。 其形式为： 一个惊叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 title 文字。 如图所示： 表格Markdown 的表格格式虽然简单，但制作起来是很不容易的。 如图所示： 强调Markdown 使用星号 * 和底线 _ 作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 &lt;em&gt; 标签包围，用两个 或 _ 包起来的话，则会被转成 &lt;strong&gt;。但是，如果你的 `或_` 两边都有空白的话，它们就只会被当成普通的符号。 如图所示： 分隔线Markdown 允许在一行中用三个以上的星号、减号、底线来建立一个分隔线，也可以在星号或是减号中间插入空格，但行内不能有其他东西。 如图所示： 其他反斜杠Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \\ 反斜线` 反引号* 星号_ 底线{} 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 自动链接Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接&lt;http://baidu.com/&gt; 如图所示： 特殊字符在 HTML 文件中，有两个字符需要特殊处理： &lt; 和 &amp; 。 &lt; 符号用于起始标签，&amp; 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式 &amp;lt; 和 &amp;amp;。但是 code 范围内，不论是行内还是区块， &lt; 和 &amp; 两个符号都一定会被转换成 HTML 实体 推荐MarkDown 中文 VSCode 代码编辑器","categories":[{"name":"Development Language","slug":"Development-Language","permalink":"http://www.whoosh.site/categories/Development-Language/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://www.whoosh.site/tags/Markdown/"}]},{"title":"树莓派3 声音传感器(Win10 IoT)","slug":"20160425_树莓派3 声音传感器-Win10","date":"2016-04-24T16:35:58.000Z","updated":"2018-03-18T13:47:03.265Z","comments":true,"path":"2016/04/25/20160425_树莓派3 声音传感器-Win10/","link":"","permalink":"http://www.whoosh.site/2016/04/25/20160425_树莓派3 声音传感器-Win10/","excerpt":"","text":"序这段时间太忙了，项目收尾一直没有时间继续捣鼓树莓派，正好趁这个双休抽点时间来和我的小伙伴玩耍一把。上篇文章提到我想用Win10 Iot Core和买来的一堆传感器摩擦出一些火花，虽然，已经有很多前辈做过，但是我没有做过啊，没做过又怎么能体会到实践的乐趣呢。先来一张传感器全家福吧！ 声音传感器这么一大堆传感器，要先玩那个呢，啊！纠结症又犯了，挑挑拣拣了好久，最后决定先搞一个简单点的—声音检测传感器。 那么，接下来就是看资料了，还好店家提供相关技术文档，这里为避嫌，就不提供店家地址。其实原理很简单，电路图如下： 以下是我摘录的： 模块描述 可以检测周围环境的声音强度 ,使用注意：此传感器只能识别声音的有无（根据震动原理）不能识别声音的大小或者特定频率的声音 灵敏度可调（图中蓝色数字电位器调节） 工作电压3.3V-5V 输出形式数字开关量输出（0和1高低电平）模块接口说明 VCC外接3.3V-5V电压（可以直接与 5v 单片机和3.3v单片机相连） GND外接GND DO小板数字量输出接口（0和 1）使用说明 声音模块对环境声音强度最敏感，一般用来检测周围环境的声音强度。 模块在环境声音强度达不到设定阈值时，DO口输出高电平，当外界环境声音强度超过设定阈值时，模块 D0输出低电平 小板数字量输出 D0可以与单片机直接相连，通过单片机来检测高低电平，由此来检测环境的声音 检查传感器了解了声音传感器基本结构后，我们要做的就是检查声音传感器是否正常：在相对安静的环境中，将模块的VCC接到树莓派的3.3V PWR电源正极上，将模块的GND接到树莓派的GND上（我选了39），此时，模块的电源指示灯会亮，说明你的传感器OK。如果开关提示也亮了，说明传感器对当前环境声音太灵敏了，可以调节蓝色数字电位器，使之灵敏度降低。附上测试接线图和树莓派GPIO引脚位置图： 如何接线我使用了6根杜邦线（3根公对母，3根公对公），具体接线步骤： 将第一根公对母杜邦线母端接到树莓派3.3V PWR电源引脚上，公端接到面包 板的正极上（红线） 将第二根公对母杜邦线母端接到树莓派GND负极引脚上，公端接到面包板负极上（棕线） 将第三根公对母杜邦线母端接到树莓派GPIO 5引脚上，公端接到LED灯长脚上（灰线） 将第一根公对公杜邦线的一端接到面包板电源正极上，另一端接到传感器VCC上（红线） 将第二根公对公杜邦线的一端接到面包板电源负极上，另一端接到传感器GND上（棕线） 将最后一根公对公杜邦线的一端接到传感器的OutPut(DO)上，另一端接到LED等的短脚上（紫线）。 最后接线如图所示： 代码实现见证奇迹的时刻到了，新建一个UWP空白应用（通用Windows），将以下代码粘到MainPage中，然后部署到树莓派中的Win10中即可。至于怎么安装系统、部署应用和web远程控制，待我下次整理出一个文档，当然，你也可以自己在网上搜。另外：源码来源于网友汪宇杰Edi.Wang。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public sealed partial class MainPage : Page &#123; //LED灯引脚 public GpioPin LedPin &#123; get; set; &#125; //声音传感器引脚 public GpioPin SoundPin &#123; get; set; &#125; //保存LED灯的开关状态 public bool IsLightOn &#123; get; set; &#125; public MainPage() &#123; this.InitializeComponent(); Loaded += OnLoaded; &#125; /// &lt;summary&gt; /// Loaded事件 /// &lt;/summary&gt; /// &lt;param name=\"sender\"&gt;&lt;/param&gt; /// &lt;param name=\"routedEventArgs\"&gt;&lt;/param&gt; private void OnLoaded(object sender, RoutedEventArgs routedEventArgs) &#123; //初始化GPIO控制器 var controller = GpioController.GetDefault(); if (null != controller) &#123; //LED是高电平输出表示开，所以第一次启动的时候要关灯，输出低电平 LedPin = controller.OpenPin(5); LedPin.SetDriveMode(GpioPinDriveMode.Output); LedPin.Write(GpioPinValue.Low); //FC-04的GPIO 06端口是接受信号的，所以是输入 SoundPin = controller.OpenPin(6); SoundPin.SetDriveMode(GpioPinDriveMode.Input); //监测声音传感器引脚值得变化 SoundPin.ValueChanged += (pin, args) =&gt; &#123; //读取引脚值（FC-04传感器只有两个值0、1） var pinValue = SoundPin.Read(); //FC-04检测到声音时候会在DO输出低电平 if (pinValue == GpioPinValue.Low) &#123; Debug.WriteLine(\"Sound Detected!\"); //开关灯操作（设置LED引脚值） LedPin.Write(IsLightOn ? GpioPinValue.Low : GpioPinValue.High); IsLightOn = !IsLightOn; &#125; &#125;; &#125; &#125; &#125; 总结在实践过程中遇到了不少问题，毕竟是小白，有很多不懂不会的地方，但是，还是那句话，只要思想不倒退，办法总比困难多。最后，来看一下效果图吧！","categories":[{"name":"树莓派","slug":"树莓派","permalink":"http://www.whoosh.site/categories/树莓派/"}],"tags":[{"name":"树莓派3","slug":"树莓派3","permalink":"http://www.whoosh.site/tags/树莓派3/"},{"name":"传感器","slug":"传感器","permalink":"http://www.whoosh.site/tags/传感器/"},{"name":"Win10 IoT","slug":"Win10-IoT","permalink":"http://www.whoosh.site/tags/Win10-IoT/"}]},{"title":"树莓派3 使用体验","slug":"20160410_树莓派3 使用体会","date":"2016-04-10T15:35:00.000Z","updated":"2018-03-16T15:23:47.629Z","comments":true,"path":"2016/04/10/20160410_树莓派3 使用体会/","link":"","permalink":"http://www.whoosh.site/2016/04/10/20160410_树莓派3 使用体会/","excerpt":"","text":"序以前听说过树莓派，那时候感觉这玩意离自己很遥远，都是一些极客才会玩的东西。但是，随着微软针对Raspberry Pi推出的Win10 Iot Core版本，便勾起了我的兴趣了，没办法，谁叫我是一个资深软粉呢！虽说有兴趣，但真要买一个玩玩，还是下了很大决心的，主要原因并不是浪费钱（板子不贵，240左右天朝币），而是根据微软这么多年的尿性，怕学了也没什么卵用。当年搞WP开发就被坑了，好在也学到了不少东西，嗯，就这样安慰自己吧。 树莓派3一出来，我就坐不住了，上一周在X宝上攒了一套，包括主板，还有一堆的配件（各种传感器、面包板、杜邦线、小零件），要吐槽一下快递，这种东西店家一般都要收快递费，所以要买的话，一次性买齐。而且不巧的是，当时正赶上深圳的禁摩限电，搞了一周才到货。 还要说一下杜邦线，我拿到货就傻眼了，40根全是母对母的，本以为是公对母的呢，最后想了个办法，把缝衣针折断来替代，也是醉了。说了这么多废话，接下来进入正题。 先来一张定妆照： 使用体验那么这几天我都用这货干了些什么呢，先来看一下有哪些系统可以跑在树莓派上呢，Raspberry Pi官网给出了如下图系统，这些系统下载地址都可以在这个页面中找到，我就尝试了下图中箭头所指的4个系统，那么就逐个来说说体验过程中遇到的问题吧。 RaspBian官方支持的操作系统，Noobs是一个比RaspBian更容易安装的版本，其实都很简单的，网上有这方面的教程，就是通过win32diskimager-v0.9-binary，将img镜像写入到SD卡中，然后把SD卡插到主板上，通电就OK了。我就不在赘述了点击下载 需要强调的是，如果你没有显示器，可以使用替代方法，例如：远程访问，根据上面地址文章中的步骤，进入到RaspBian系统后，安装Linux下远程桌面xrdp即可在window下通过远程桌面访问到桌面版的RaspBian了。 安装远程访问xrdp命令 1sudo apt-get install xrdp Ubuntu Mate使用这个系统的时候，我也想着像上一个步骤那样，通过远程访问来搞定，但现实是残酷滴，我无法知道Ubuntu系统的用户名和密码，就没法登陆进去，这可难倒我了，最终还是办法总是多于困难的，现在的电视机一半都自带VGA或者HDMI接口，这个时候，就可以通过HDMI线或者HDMI转VGA接头连接到电视上，要说明的是，网上说HDMI转接头最好需要带外部电源的，可是我用了个无源的转接头也是Ok的，前提是主板电源输出不要太低，官方说是2.5A，实际上我用的是2.0A。 另外，如果用HDMI直链电视的话，国内的电视显示器分辨率很杂，我家里的就是，接上去也通电了，但就是黑屏，于是各种查啊。这里就需要修改系统分区下config.txt文件，建议使用notepad++打开文档，添加或修改配置项hdmi_ignore_edid=0xa5000080，具体步骤请移步。 Win10 IoT话说我就是因为Win10才买树莓派的，物联网要火了，不能掉队伍不是。而且，在编程方面也有基础，官方提供了很多Demo，光看源码不实操，心里是很痒的，哈哈。所以一拿到货我就装了Win10的系统，需要提醒的是，如果和我一样，使用的是树莓派3，那么就需要下最新版本的系统了，win10正式版10586是不支持Pi3的，之后的可以。而且现在最新的版本系统（14295）还不支持wifi和蓝牙，我就是冲着Pi3自带wifi和蓝牙才放弃pi2的，感谢网友汪宇杰Edi.Wang的告知。 说一下开发过程中遇到的一个坑，按照官方提供的点亮LED程序，发现没法点亮LED灯，导致我一直以为是我接线出了问题，可是接线实在是太简单了，这都错智商岂不是没救了，后来在VS中自己跑了一遍源码，居然就点亮了，真是我勒个去啊。附上官方地址 这里很多文档可以参考，另外Demo下载地址。 OpenElec这个系统是什么货呢，可能知道它的人不多，说通俗点吧，它是多媒体终端系统，可以用作电视盒子，以前叫XBMC现在叫Kodi,装了这个系统，树莓派瞬间就变成了电视盒子了，系统安装过程和装Ubuntu Mate是一样的，装好了如何配置就稍微复杂一些，主要是在更换中文语言的地方一个坑，还有就是想看国内视频网站或电视直播，需要下载中文插件库，好在网上有很多教程，按照教程走问题都不大的，附上教程地址 总结树莓派的可玩性是很强的，可以用它来做一些很有趣的事情，但是怎么有趣就要自己去发掘了。另外，记得我上文提到我买了一堆的传感器吧，接下来，我就要尝试在win10 iot下和这些传感器玩耍了，再次感谢这方面的先锋战士Edi.Wang。","categories":[{"name":"树莓派","slug":"树莓派","permalink":"http://www.whoosh.site/categories/树莓派/"}],"tags":[{"name":"树莓派3","slug":"树莓派3","permalink":"http://www.whoosh.site/tags/树莓派3/"}]}]}