{"meta":{"title":"WHOOSH","subtitle":"生平有数，学识无涯","description":"张正强、技术分享","author":"Zhengqaing Zhang","url":"http://www.whoosh.site"},"pages":[{"title":"","date":"2018-02-15T07:43:55.192Z","updated":"2016-09-07T10:04:28.000Z","comments":true,"path":"baidu_verify_nvBydHIzNT.html","permalink":"http://www.whoosh.site/baidu_verify_nvBydHIzNT.html","excerpt":"","text":"nvBydHIzNT"},{"title":"","date":"2018-02-15T07:43:55.176Z","updated":"2018-02-10T18:03:24.000Z","comments":true,"path":"about/index.html","permalink":"http://www.whoosh.site/about/index.html","excerpt":"","text":""},{"title":"","date":"2018-02-15T07:43:55.192Z","updated":"2018-02-10T18:03:24.000Z","comments":true,"path":"categories/index.html","permalink":"http://www.whoosh.site/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-02-15T07:43:55.207Z","updated":"2018-02-10T18:03:24.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.whoosh.site/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"PDCharts局部放电图谱库","slug":"20180318_PDCharts局部放电图谱库","date":"2018-03-18T13:13:58.000Z","updated":"2018-03-16T15:46:49.060Z","comments":true,"path":"2018/03/18/20180318_PDCharts局部放电图谱库/","link":"","permalink":"http://www.whoosh.site/2018/03/18/20180318_PDCharts局部放电图谱库/","excerpt":"","text":"概述PDCharts是为满足业务需求在Echarts基础上进行二次封装的图谱库。 &emsp;&emsp;ECharts，一个纯 Javascript 的图表库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖轻量级的 Canvas 类库 ZRender，提供直观，生动，可交互，可高度个性化定制的数据可视化图表。 PDcharts目前支持以下图谱： AE：幅值图谱、时域波形图谱、相位图谱、飞行图谱； UHF/HFCT：PRPS二维图谱、PRPS三维图谱、PRPD二维图谱、PRPD三维图谱、周期图谱； 红外：温度矩阵图谱； 铁芯接地：接地电流图谱； 机械特性：电机电流曲线、原始电流曲线、线圈电流曲线、扭矩曲线、振动信号曲线、振动频率信号曲线、行程曲线、开关量曲线 项目地址：https://github.com/zhangzqiang/pdcharts 使用说明由于pdcharts.js依赖于echarts.js，在使用时，需要在HTML页面中引入echarts.js，另外，如果需要用到PRPS三维图谱或者PRPD三维图谱，还需要引入echarts-gl.js\u001c，点击这里下载echarts。 123&lt;script type=\"text/javascript\" src=\"echarts.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"echarts-gl.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"pdcharts.js\"&gt;&lt;/script&gt; PDCharts对外提供图谱类型对象chartType、绘图方法draw(targetEl, opts)和更新图谱配置updateOption(chart, opts)，下面具体介绍使用方法。 &gt; chartType获取pdcharts支持的图谱类型： 1var chartType = pdcharts.chartType; AE：amplitude,wave,phase,fly UHF/HFCT：prps2d,prps3d,prpd2d,prpd3d,cycle,prpsd 铁芯接地：earthcurrent 红外：infrared 机械特性：mech,switches &emsp;&emsp;注:prpsd用于云诊断或报告中的三维PRPS或者PRPD图谱；switches用于开关量图谱，且图谱数据无需进行偏移处理。 &gt; draw(targetEl, opts)draw()是在目标Div中\u001d根据一些配置参数进行图谱绘制的方法，其中engine、type、data为必选配置项，width、height为可选配置项。 engine：当前采用哪种绘图引擎，目前仅支持echarts，后期添加canves，svg type：图谱类型，参见 chartType data：图谱数据，不同图谱类型数据结构不同，具体参见数据结构说明 width：图谱宽度，如果没有配置，则默认为当前浏览器的宽度。 height：图谱高度，如果没有配置，则默认为当前浏览器的高度。 cover：图谱显示方式，false为居中显示，true为平铺显示。默认为false。 12345678910111213141516171819202122232425262728293031323334353637383940var targetEl=document.getElementById('amplitude');var chartBody=&#123; title: \"AE幅值图谱\", axisInfo: &#123; valDesc: \"测量值\", valColor: \"#1BA261\", bgValDesc: \"背景值\", bgColor: \"#DD5044\", unit: \"mV\", frequecy: 50 &#125;, series: [&#123; name: \"有效值\", min: -1, max: 10, dataList: [0.2, 1.2] &#125;, &#123; name: \"周期最大值\", min: 0, max: 20, dataList: [0.4, 7.5] &#125;, &#123; name: \"频率成份1\", min: 0, max: 2, dataList: [0, 0.2] &#125;, &#123; name: \"频率成份2\", min: 0, max: 2, dataList: [0, 0.2] &#125;]&#125;pdcharts.draw(targetEl, &#123; engine: echarts, type: chartType.amplitude, data: chartBody, width: 360, height: 320&#125;); &emsp;&emsp;注:当调整targetEl的宽度或者高度，图谱会进行自适应（prpsd图谱除外）。 &gt; updateOption(chart, opts)考虑到默认的图谱配置项有可能无法满足具体业务需求，提供updateOption()对图谱进行个性化的设计。其中opts需要满足Echarts提供配置项结构。 123456789101112var chart=pdcharts.draw(targetEl, &#123; engine: echarts, type: chartType.amplitude, data: chartBody, width: 360, height: 320&#125;);pdcharts.updateOption(chart,&#123; title:&#123; text:'自定义标头' &#125;,&#125;) &emsp;&emsp;注:prpsd图谱除外。 数据结构说明 幅值(amplitude)图谱数据结构 title：图谱标头 axisInfo：坐标信息 axisInfo.valDesc：测量值描述 axisInfo.valColor：测量值对应颜色，默认值：#1BA261 axisInfo.bgValDesc：背景值描述 axisInfo.bgColor：背景值对应颜色，默认值：#DD5044 axisInfo.unit：单位，默认值：mV axisInfo.frequecy：电网频率，默认值：50 series：系列列表，包括有效值、周期最大值、频率成份1、频率成份2 series.name：系列名称，例如：有效值 series.min：系列最小值 series.max：系列最大值 series.dataList：[背景值,测量值] 12345678910111213141516chartBody: &#123; title: '', axisInfo: &#123; valDesc: '', valColor: '#1BA261', bgValDesc: '', bgColor: '#DD5044', unit: 'mV', frequecy: 50 &#125;, series: [&#123; name: '', min: 0, max: 0, dataList: [0, 0] &#125;,……] 图列： 时域波形(wave)图谱数据结构 title：图谱标头 axisInfo：坐标信息 axisInfo.xDesc：X轴描述，周期 axisInfo.xRangeMax：X轴范围，最大值 axisInfo.xRangeMin：X轴范围，最小值 axisInfo.xUnit：X轴单位，默认值：T axisInfo.yDesc：Y轴描述，幅值 axisInfo.yRangeMax：Y轴范围，最大值 axisInfo.yRangeMin：Y轴范围，最小值 axisInfo.yUnit：Y轴单位，默认值：mV trigger：触发线 trigger.desc：触发值描述 trigger.value：触发值 trigger.color：触发线颜色，默认值：#ff00ff series：系列列表 series.color：波形线颜色，默认值：_#ff0000 series.dataList：[[周期值,幅值],……] 12345678910111213141516171819202122chartBody: &#123; title: '', axisInfo: &#123; xDesc: '', xRangeMax: 0, xRangeMin: 0, xUnit: 'T', yDesc: '', yRangeMax: 0, yRangeMin: 0, yUnit: 'mV', &#125;, trigger: &#123; desc: '', value: 0, color: '#ff00ff' &#125;, series: [&#123; color: '#ff0000', dataList: [[0,0],……], &#125;]&#125; 图列： 相位(phase)图谱数据结构 title：图谱标头 axisInfo：坐标信息 axisInfo.xDesc：X轴描述，相位 axisInfo.xRangeMax：X轴范围，默认值：360 axisInfo.xRangeMin：X轴范围，默认值：0 axisInfo.xUnit：X轴单位，默认值：° axisInfo.yDesc：Y轴描述，幅值 axisInfo.yRangeMax：Y轴范围，最大值 axisInfo.yRangeMin：Y轴范围，最小值 axisInfo.yUnit：Y轴单位，默认值：mV axisInfo.zDesc：Z轴描述，脉冲个数 axisInfo.zRangeMax：Z轴范围，默认值：64 axisInfo.zRangeMin：Z轴范围，默认值：0 axisInfo.zUnit：Y轴单位，默认值：空 trigger：触发线 trigger.desc：触发值描述 trigger.value：触发值 trigger.color：触发线颜色，默认值：#ff00ff series：系列列表 series.color：数据点颜色系，如果不配置或者值为空，数据点颜色则按照数据集合中的颜色显示，默认值：tlb series.dataList：[[相位值,幅值,脉冲个数,数据点颜色],……]，其中数据点颜色可选 1234567891011121314151617181920212223242526chartBody: &#123; title: '', axisInfo: &#123; xDesc: '', xRangeMax: 360, xRangeMin: 0, xUnit: '°', yDesc: '', yRangeMax: 0, yRangeMin: 0, yUnit: 'mV', zDesc: '', zRangeMax: 64, zRangeMin: 0, zUnit: '', &#125;, trigger: &#123; desc: '', value: 0, color: '#ff00ff' &#125;, series: [&#123; colors: 'tlb', dataList: [[0,0,0,'#ff0000'],……], &#125;]&#125; 图列： 飞行(fly)图谱数据结构 title：图谱标头 axisInfo：坐标信息 axisInfo.xDesc：X轴描述，时间间隔 axisInfo.xRangeMax：X轴范围，最大值 axisInfo.xRangeMin：X轴范围，最小值 axisInfo.xUnit：X轴单位，默认值：ms axisInfo.yDesc：Y轴描述，幅值 axisInfo.yRangeMax：Y轴范围，最大值 axisInfo.yRangeMin：Y轴范围，最小值 axisInfo.yUnit：Y轴单位，默认值：mV axisInfo.zDesc：Z轴描述，脉冲个数 axisInfo.zRangeMax：Z轴范围，默认值：64 axisInfo.zRangeMin：Z轴范围，默认值：0 axisInfo.zUnit：Y轴单位，默认值：空 trigger：触发线 trigger.desc：触发值描述 trigger.value：触发值 trigger.color：触发线颜色，默认值：#ff00ff series：系列列表 series.color：数据点颜色系，如果不配置或者值为空，数据点颜色则按照数据集合中的颜色显示，默认值：tlb series.dataList：[[时间间隔,幅值,脉冲个数,数据点颜色],……]，其中数据点颜色可选 1234567891011121314151617181920212223242526chartBody: &#123; title: '', axisInfo: &#123; xDesc: '', xRangeMax: 360, xRangeMin: 0, xUnit: '°', yDesc: '', yRangeMax: 0, yRangeMin: 0, yUnit: 'mV', zDesc: '', zRangeMax: 64, zRangeMin: 0, zUnit: '', &#125;, trigger: &#123; desc: '', value: 0, color: '#ff00ff' &#125;, series: [&#123; colors: 'blaze', dataList: [[0,0,0,'#ff0000'],……], &#125;]&#125; 图列： PRPS图谱数据结构 title：图谱标头 axisInfo：坐标信息 axisInfo.xDesc：X轴描述，相位 axisInfo.xRangeMax：X轴范围，默认值：360 axisInfo.xRangeMin：X轴范围，默认值：0 axisInfo.xUnit：X轴单位，默认值：° axisInfo.yDesc：Y轴描述，周期 axisInfo.yRangeMax：Y轴范围，默认值：50 axisInfo.yRangeMin：Y轴范围，默认值：0 axisInfo.yUnit：Y轴单位，默认值：T axisInfo.zDesc：Z轴描述，幅值 axisInfo.zRangeMax：Z轴范围，最大值 axisInfo.zRangeMin：Z轴范围，最小值 axisInfo.zUnit：Y轴单位，默认值：mV axisInfo.phaseShift：相位偏移值，默认值：xRangeMin axisInfo.zRange：Z轴显示范围，默认值：[zRangeMin, zRangeMax] series：系列列表 series.color：数据点颜色系，如果不配置或者值为空，数据点颜色则按照数据集合中的颜色显示，默认值：blaze series.dataList：[[时间间隔,幅值,脉冲个数,数据点颜色],……]，其中数据点颜色可选 1234567891011121314151617181920212223chartBody: &#123; title: '', axisInfo: &#123; xDesc: '', xRangeMax: 360, xRangeMin: 0, xUnit: '°', yDesc: '', yRangeMax: 50, yRangeMin: 0, yUnit: 'T', zDesc: '', zRangeMax: 64, zRangeMin: 0, zUnit: 'mV', phaseShift: 0, zRange: [0, 64] &#125;, series: [&#123; colors: 'blaze', dataList: [[0,0,0],……], &#125;]&#125; 图列： PRPSD图谱适用浏览器无法展示展示三维图谱时替代，即可用于PRPS三维图也可用于PRPD三维图。 PRPD图谱数据结构 title：图谱标头 axisInfo：坐标信息 axisInfo.xDesc：X轴描述，相位 axisInfo.xRangeMax：X轴范围，默认值：360 axisInfo.xRangeMin：X轴范围，默认值：0 axisInfo.xUnit：X轴单位，默认值：° axisInfo.yDesc：Y轴描述，幅值 axisInfo.yRangeMax：Y轴范围，最大值 axisInfo.yRangeMin：Y轴范围，最小值 axisInfo.yUnit：Y轴单位，默认值：mV axisInfo.zDesc：Z轴描述，脉冲个数 axisInfo.zRangeMax：Z轴范围，默认值：100 axisInfo.zRangeMin：Z轴范围，默认值：0 axisInfo.zUnit：Y轴单位，默认值：空 series：系列列表 series.color：数据点颜色系，如果不配置或者值为空，数据点颜色则按照数据集合中的颜色显示，默认值：blaze series.dataList：[[时间间隔,幅值,脉冲个数,数据点颜色],……]，其中数据点颜色可选 123456789101112131415161718192021chartBody: &#123; title: '', axisInfo: &#123; xDesc: '', xRangeMax: 0, xRangeMin: 0, xUnit: '°', yDesc: '', yRangeMax: 0, yRangeMin: 0, yUnit: 'mV', zDesc: '', zRangeMax: 100, zRangeMin: 0, zUnit: '', &#125;, series: [&#123; colors: 'blaze', dataList: [[0,0,0],……], &#125;]&#125; 图列： 铁芯接地电流(earthcurrent)图谱数据结构 title：图谱标头 axisInfo：坐标信息 axisInfo.desc：描述，电流值 axisInfo.rangeMax：电流值最大值 axisInfo.rangeMin：电流值最小值 axisInfo.unit：单位，默认值：mA axisInfo.nomalMax：正常值，默认值：100 axisInfo.nomalColor：正常颜色，默认值：#1BA261 axisInfo.warningMax：预警值，默认值：300 axisInfo.warningColor：预警颜色，默认值：#FCAB53 axisInfo.alarmMax：报警值，默认值：500 axisInfo.alarmColor：报警颜色，默认值：#DD5044 axisInfo.value：测量值 12345678910111213141516chartBody: &#123; title: '', axisInfo: &#123; desc: '', rangeMax: 500, rangeMin: 0, unit: 'mA', nomalMax: 100, nomalColor: '#1BA261', warningMax: 300, warningColor: '#FCAB53', alarmMax: 500, alarmColor: '#DD5044', value:0 &#125;&#125; 图列： 红外温度矩阵(infrared)图谱数据结构 title：图谱标头 axisInfo：坐标信息 axisInfo.desc：描述，温度值 axisInfo.widht：图像宽度，默认值：360 axisInfo.height：图像高度，默认值：256 axisInfo.rangeMax：温度最大值 axisInfo.rangeMin：温度最小值 axisInfo.unit：温度单位，默认值：℃ series：系列列表 series.color：点/线颜色，默认值：iron series.dataList：[[高度坐标,宽度坐标,温度值],……] 123456789101112131415chartBody: &#123; title: '', axisInfo: &#123; desc: '', widht: 360, height: 256, rangeMax: 0, rangeMin: 0, unit: '℃', &#125;, series: [&#123; colors: 'iron', dataList: [[0,0,0],……], &#125;]&#125; 图列： 机械特性(mech)图谱数据结构 适用电机电流曲线、原始电流曲线、线圈电流曲线、扭矩曲线、振动信号曲线、振动频率信号曲线、行程曲线 title：图谱标头 axisInfo：坐标信息 axisInfo.xDesc：X轴描述，不同曲线不同 axisInfo.xRangeMax：X轴最大值 axisInfo.xRangeMin：X轴最小值 axisInfo.xUnit：单位 axisInfo.yDesc：Y轴描述 axisInfo.yUnit：Y轴单位 axisInfo.pointNum：数据点数 series：系列列表 series.name：系列名称，例如：A相、X轴等 series.color：点/线颜色，默认值：#1BA261 series.dataList：[对应曲线值,……] 1234567891011121314151617chartBody: &#123; title: '', axisInfo: &#123; xDesc: '', xRangeMax: 0, xRangeMin: 0, xUnit: 's', yDesc: '', yUnit: 'A', pointNum: 0, &#125;, series: [&#123; name: 'A', color: '#1BA261', dataList: [0,……] &#125;,……],&#125; 图列： 开关量(switches)曲线数据结构 title：图谱标头 axisInfo：坐标信息 axisInfo.xDesc：X轴描述，时间 axisInfo.xRangeMax：X轴最大值 axisInfo.xRangeMin：X轴最小值 axisInfo.xUnit：单位 axisInfo.yDesc：Y轴描述 axisInfo.yUnit：Y轴单位 axisInfo.pointNum：数据点数 axisInfo.valDesc：开关状态 axisInfo.valDesc.on：开状态描述 axisInfo.valDesc.off：关状态描述 series：系列列表 series.name：系列名称，例如：A相等 series.color：点/线颜色，默认值：#1BA261 series.dataList：[开关状态量,……] 123456789101112131415161718192021chartBody: &#123; title: '', axisInfo: &#123; xDesc: '', xRangeMax: 0, xRangeMin: 0, xUnit: 'ms', yDesc: '', yUnit: '', pointNum: 0, valDesc: &#123; on: '', off: '' &#125; &#125;, series: [&#123; name: 'A', color: '#1BA261', dataList: [0,……] &#125;,……],&#125; 图列： 周期图谱(cycle)数据结构 title：图谱标头 axisInfo：坐标信息 axisInfo.xDesc：X轴描述，相位 axisInfo.xRangeMax：X轴最大值 axisInfo.xRangeMin：X轴最小值 axisInfo.xUnit：X轴单位 axisInfo.yDesc：Y轴描述，幅值 axisInfo.yRangeMax：Y轴最大值 axisInfo.yRangeMin：Y轴最小值 axisInfo.yUnit：Y轴单位 trigger：触发线 trigger.desc：触发值描述 trigger.value：触发值，对应状态的最大值 trigger.color：触发线颜色，默认值：#ff00ff series：系列列表 series.name：系列名称，例如：正常 series.color：点/线颜色，默认值：#008000 series.dataList：[[相位值,幅值],……] 12345678910111213141516171819202122232425let init = &#123; title: '', axisInfo: &#123; xDesc: '', xRangeMax: 0, xRangeMin: 0, xUnit: '°', yDesc: '', yRangeMax: 0, yRangeMin: 0, yUnit: 'dB', yMaxValue: 0, yMaxColor: '#ff00ff' &#125;, trigger: [&#123; desc: '', value: 0, color: '#008000' &#125;], series: [&#123; name:'', color:'' dataList: [[0, 0],……], &#125;]&#125;; 图列：","categories":[{"name":"华乘电气","slug":"华乘电气","permalink":"http://www.whoosh.site/categories/华乘电气/"}],"tags":[{"name":"PDCharts","slug":"PDCharts","permalink":"http://www.whoosh.site/tags/PDCharts/"},{"name":"ECharts","slug":"ECharts","permalink":"http://www.whoosh.site/tags/ECharts/"}]},{"title":"高效能人士的七个习惯","slug":"20180315_高效能人士的七个习惯","date":"2018-03-15T13:13:58.000Z","updated":"2018-03-16T14:36:45.531Z","comments":true,"path":"2018/03/15/20180315_高效能人士的七个习惯/","link":"","permalink":"http://www.whoosh.site/2018/03/15/20180315_高效能人士的七个习惯/","excerpt":"","text":"前言 2018-01-13 我就是我生命的创造力 要完成最渴望的目标，战胜最艰巨的挑战，必须发掘并应用一些原则或自然法则（套路）。任何努力的成功，都离不开恰到好处并游刃有余地应用这些原则。 人类面临最普遍的集中挑战：恐惧感和不安全感、我现在就想得到、谴责和抱怨、绝望无助、缺乏人生平衡、我的定位在哪儿、渴望被理解、冲突和分歧、个人的停滞不前 犬儒主义：源于古希腊犬儒学派学者主张的哲学思潮(创始人：安提斯泰尼，集大成者：第欧根尼)，该派的本意是指人不应被一切世俗的事物，包括宗教、礼节、惯常的衣食住行方面等习俗束缚，提倡对道德的无限追求，同时过着极简朴而非物质的生活。现代的犬儒主义演变成了虚无主义、愤世嫉俗、玩世不恭。 重新探索自我 皮格马利翁效应（Pygmalion Effect, 又称比马龙效应）指人们基于对某种情境的知觉而形成的期望或预言，会使该情境产生适应这一期望或预言的效应。 个人领域的成功：从依赖到独立1. 积极主动：个人愿景2. 以终为始：自我领导3. 要事第一：自我管理公众领域的成功：从独立到互赖4. 双赢思维：人际领导5. 知己解彼：移情沟通6. 统合综效：创造性合作自我提升和改善7. 不断更新：平衡的自我更新","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://www.whoosh.site/categories/读书笔记/"}],"tags":[{"name":"管理类书籍","slug":"管理类书籍","permalink":"http://www.whoosh.site/tags/管理类书籍/"}]},{"title":"普吉蜜月旅行","slug":"20180311_普吉蜜月旅行","date":"2018-03-11T13:13:58.000Z","updated":"2018-03-11T15:16:20.046Z","comments":true,"path":"2018/03/11/20180311_普吉蜜月旅行/","link":"","permalink":"http://www.whoosh.site/2018/03/11/20180311_普吉蜜月旅行/","excerpt":"","text":"出发前准备蜜月旅行之所以选择去泰国，主要考虑到这是一次意义非凡的旅行，不想把婚假白白浪费在国内，还有就是安全因素了，毕竟第一次出国，没有经验，就选了个近的，而且跟了团（胆子小嘛）。 虽说跟团出行，但是出发前还是要准备一些东西的： 护照：出国必备品，在公安局出入境大厅办理，携带身份证、户口本原件，2寸照即可办理，工本费200。 签证：也是必备品，可以自己去大使馆办理、找旅行社办理、也可以落地签（看目的地是否可以），我们本来想自己办理，结果需要提供一堆的证明，懒得弄就选择了落地签了。 泰铢：泰国要求游客每人必须携带20000泰铢或等值人民币，可以去银行换一些小额的泰铢，例如20、50、100，因为泰国是一个小费国家，经常要用到。 电话卡：专为游客设计的happy卡，在泰国激活后可用8天，2.5G高速流量，100分钟通话时长，但是打电话必须要在号码前要加0040086，基本上这些足够用了，反正我的没有用完。 夏装：普吉岛没有最热只有更热，一定要带上夏装过去，例如拖鞋、大裤衩、防晒品之类的，当然这些在本地也能买到，价格嘛肯定要贵点的。 泰国是一个非常适合养老的地方，不仅当地人生活节奏非常慢，猫狗也都非常的慵懒，见到它们肥嘟嘟的躺在地上晒太阳，相当的闲适了，可惜没有留下照片。 欢乐时光 总结这是一次非常开心的旅行，见识到不一样的世界，遇到不一样的人。生活在不停的忙碌后需要一段时间来调节下，然后继续追逐着梦想，不禁感慨，活着真好。","categories":[{"name":"游记","slug":"游记","permalink":"http://www.whoosh.site/categories/游记/"}],"tags":[{"name":"旅行","slug":"旅行","permalink":"http://www.whoosh.site/tags/旅行/"}]},{"title":"Canvas的基本用法","slug":"20170702_Canvas的基本用法","date":"2017-07-02T14:13:58.000Z","updated":"2018-03-17T01:32:30.657Z","comments":true,"path":"2017/07/02/20170702_Canvas的基本用法/","link":"","permalink":"http://www.whoosh.site/2017/07/02/20170702_Canvas的基本用法/","excerpt":"","text":"","categories":[{"name":"前端技术","slug":"前端技术","permalink":"http://www.whoosh.site/categories/前端技术/"}],"tags":[{"name":"Canvas","slug":"Canvas","permalink":"http://www.whoosh.site/tags/Canvas/"}]},{"title":"使用PhantomJS实现服务端截屏","slug":"20170303_使用PhantomJS实现服务端截屏","date":"2017-03-03T03:13:58.000Z","updated":"2018-03-16T15:19:37.999Z","comments":true,"path":"2017/03/03/20170303_使用PhantomJS实现服务端截屏/","link":"","permalink":"http://www.whoosh.site/2017/03/03/20170303_使用PhantomJS实现服务端截屏/","excerpt":"","text":"简介在一些前端项目中，有时会需要对页面或者某个div进行截屏，常见的方式是使用html2canvas来实现，这个方式的好处是显而易见的。但是，有时候也会出现以外，例如笔者碰到将复杂的svg截屏之后，发现图片与页面展示不一致，为了解决这个问题，查阅了很多资料。最后，通过PhantomJS实现了这个功能。 PhantomJS介绍PhantomJS是一个服务器端的JavaScriptAPI的WebKit。它使用QtWebKit作为它核心浏览器的功能，作为隐形的浏览器，提供了诸如CSS选择器、支持Web标准、DOM操作、JSON、HTML5、Canvas、SVG等（WebGL、Flash、Video、Audio、CSS 3D是不支持的），同时也提供了处理文件I/O的操作，从而使你可以向操作系统读写文件等。PhantomJS的用处非常广泛，诸如网络监测、网页截屏、无需浏览器的 Web 测试、页面访问自动化等。 PhantomJS使用目前官方支持windows\\Mac OS\\Linux三大主流的环境的运行包，你可以根据你的运行环境选择要下载的包。下载地址：http://phantomjs.org/download.html 笔者的运行环境是win10，下载完成后解压文件，将bin目录下的phantomjs.exe和examples目录下的hello.js放到一个文件目录下，然后在cmd下运行phantomjs.exe，结果如下图。 phantomjs的命令格式如下： 1phantomjs [options] somescript.js [arg1 [arg2 [...]]] 详细介绍参见Command Line Interface 接下来介绍如何实现服务端截屏功能，编写screenshot.js文件，先介绍下webpage、system、fs。 webpage:主要是提供了一套可以访问和操作web文档的核心方法，包括操作DOM、事件捕获、用户事件模拟等等。 system:该模块提供了一些与操作系统相关的接口，例如访问操作系统信息、访问系统环境变量、接受命令行参数等等与程序执行相关的系统信息。 fs:即FileSystem（类似NodeJS）。fs提供了执行文件I/O操作的标准接口，如读写文件、删除文件等。它使得你持久化一些文件（如logfile等）变得非常容易。 12345678910111213141516171819202122232425262728293031323334353637383940414243\"use strict\";/** * phantomjs screenshot.js \"http://192.168.14.180/index.html\" \"image/456.png\" * phantomjs screenshot.js \"wwwroot/index.html\" \"image/456.png\"*/var page = require('webpage').create();var system = require('system');var address, output;if (system.args.length &lt; 3 || system.args.length &gt; 5) &#123; phantom.exit(1);&#125; else &#123; address = system.args[1]; output = system.args[2]; //定义宽高 page.viewportSize = &#123; width: 1000, height: 800 &#125;; page.open(address, function (status) &#123; if (status == 'success') &#123; var bb = page.evaluate(function () &#123; return document.getElementsByTagName('html')[0].getBoundingClientRect(); &#125;); page.clipRect = &#123; top: bb.top, left: bb.left, width: bb.width, height: bb.height &#125;; window.setTimeout(function () &#123; //保存图片或者pdf，根据文件后缀名自动判断 page.render(output); page.close(); console.log('渲染成功...'); phantom.exit(); &#125;, 1000); &#125; else &#123; page.close(); phantom.exit(); &#125; &#125;);&#125; 在服务端定义一个方法，该方法创建一个cmd进程，让这个进程调用phantomjs命令格式即可。 12345678910111213141516171819202122232425262728/// &lt;summary&gt;/// 进行截图/// &lt;/summary&gt;/// &lt;param name=\"webPageUrl\"&gt;截图网页链接&lt;/param&gt;/// &lt;param name=\"imagePath\"&gt;截图生成的文件存放的路径及其文件名&lt;/param&gt;/// &lt;param name=\"serverPath\"&gt;phantomjs.exe与screenshot.js所在目录的路径&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool GetImg(string webPageUrl, string imagePath, string serverPath)&#123; try &#123; //实例化进程 //phantomjs.exe screenshot.js \"wwwroot/index.html\" \"image/456.png\" Process p = new Process(); p.StartInfo.FileName = serverPath + @\"\\phantomjs.exe\"; p.StartInfo.WorkingDirectory = serverPath + @\"\\\"; p.StartInfo.Arguments = string.Format(serverPath + @\"\\screenshot.js \" + webPageUrl + \" \" + imagePath); p.StartInfo.CreateNoWindow = true; p.StartInfo.WindowStyle = ProcessWindowStyle.Hidden; p.Start(); return true; &#125; catch (Exception ex) &#123; Console.WriteLine(ex.Message); return false; &#125;&#125; 无浏览器图形界面项目 软件名 介绍 支持语言 Awesomium 基于Chromium无图形界面浏览器引擎。 C++,.NET benv Benv是node.js开发的无界面浏览器测试环境，用于测试客户端代码。 JavaScript browser-launcher Browser-Launcher可以检测系统上的所有浏览器版本，并在一个独立的配置文件中启动它们，用于自动测试。 JavaScript browser.rb 无界面Ruby浏览器。 Ruby Browserjet 无界面webkit浏览器，采用node.js接口。 JavaScript BrowserKit 可模拟浏览器的行为。 PHP CasperJS CasperJS是一个开源的导航脚本和测试工具，使用JavaScript基于 PhantomJS 编写，用于测试Web应用功能，PhantomJS是一个服务器端的JavaScriptAPI的WebKit。其支持各种Web标准：DOM处理,CSS选择器,JSON,Canvas,和SVG。 JavaScript DalekJS DalekJS 是一个基于JavaScript（或Node.js）的免费和开源的自动化测试接口。它能够同时运行测试一组流行的浏览器（Chrome，IE，Firefox和WebKit）。 JavaScript Erik Erik是一款基于WebKit的无界面浏览器，可用于功能函数的测试，使用JavaScript对网页进行操作访问。 Swift Geb Geb是浏览器自动化（browserautomation）测试解決方案。 Groovy ghost ghost.py是一个Python的Webkit的Web客户端。 Python Ghostbuster Ghostbuster是一款自动化浏览器测试工具，基于phantomjs，意味着你得到一个仿真浏览器，一个真正的DOM，仿真测试环境。 JavaScript grope Grope是无ＧUI浏览器环境，使用WebKitFramework+RubyCocoa。 Ruby Guillotine Guillotine是一款采用C#开发的.NET无界面浏览器。 .NET Headless Headless是一款无界面浏览器，支持快速网络接受测试，采用.Net环境。 .NET headless_browser Headless-Browser是一款采用C++开发的基于WebKit无界面浏览器。 C++ HeadlessBrowser HeadlessBrowser是一款轻量级无图形界面浏览器，用于DOM测试。 JavaScript HtmlUnit HtmlUnit是一个isa”Java程序GUI-Less浏览器”。 Java Jabba-Webkit Jabba-Webkit是一款无图形化WebKit浏览器，主要用来抓取Ajax网页。 Python Jasmine-Headless-Webkit Jasmine-Headless-Webkit是一款基于jasmine的无图形化web工具。 Python,JavaScript,Ruby Jaunt JavaWeb网页抓取&amp;自动化API Java jBrowserDriver jBrowserDriver是一款采用纯Java编写的无图形化浏览器，基于WebKit，和Selenium兼容。 Java jedi-crawler Jedi-Crawler是一款轻量级 Node/PhantomJS爬虫，可以动态的抓取网页内容。 JavaScript Lotte Lotte是一款自动化无图形化浏览器测试工具，采用phantomJs。 JavaScript MechanicalSoup MechanicalSoup是一个与网站自动交互Python库。 Python mechanize 状态编程的Web浏览。 Python Nightmare 高层次浏览器自动化库，构建于PhantomJS。 JavaScript PhantomJS PhantomJS是一个服务器端的JavaScriptAPI的WebKit JavaScript,Python,Ruby,Java,C#,Haskell,Objective-C,Perl,PHP,R(via Selenium) phantompy Phantompy是一款headlessWebKit引擎，构建于强大的 Qt5WebkitAPI之上。 Python Python-Webkit Python-Webkit是一个Webkitpython扩展，可完整的访问网页的DOM。 Python RoboBrowser RoboBrowser是一款简单的浏览网页的Pythonic库，无需依赖独立的浏览器。 Python Selenium 跨平台自动化web浏览器。 JavaScript,Python,Ruby,Java,C#,Haskell,Objective-C,Perl,PHP,R SimpleBrowser SimpleBrowser是专门为自动化任务而设计的一个灵活而直观的浏览器引擎，内置.Net4framework。 .NET SlimerJS SlimerJS是一个提供给 Web 开发人员，可通过脚本编程控制的浏览器。 JavaScript Splash Splash是一款HTTPAPI轻量级浏览器，采用Python和ＱT开发。 Any Splinter Splinter是一个用Python编写的Web应用程序进行验收测试的工具。 Python Spynner Spynner是一个可编程Web浏览器Python模块。支持AJAX。 Python SST SST(selenium-simple-test)是一个Web测试框架，使用Python来生成基于浏览器的功能测试。 Python stanislaw Stanislaw一款Pythonheadless浏览器测试工具。 Python trifleJS 一个headlessIE浏览器。采用.NETWebBrowser类，拥有JavascriptAPI，运行在V8引擎。 JavaScript twill Twill是一种简单的语言，允许用户通过一个命令行界面浏览网页。 Python WatiN Watin是一个面向.net的Web自动化测试开源项目，对应Web元素提供了丰富的类库，而且使用起来非常简单。 .NET Watir-WebDriver Watir的实现基于WebDriver的Ruby绑定。 Ruby WKZombie WKZombie是针对iOS/OSX的不需要用户界面或API就能进行网站导航和数据收集的一个Swift框架，也被称为无界面浏览器。 Swift Zombie.js 一个轻量级的框架，用于在一个模拟的环境中测试客户端的JavaScript代码。Zombie.js使用Node.js实现快速的headlessfull-stack测试平台。 JavaScript","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://www.whoosh.site/categories/浏览器/"}],"tags":[{"name":"PhantomJS","slug":"PhantomJS","permalink":"http://www.whoosh.site/tags/PhantomJS/"}]},{"title":"ReactNative自学02-ES6语法","slug":"20161031_ReactNative自学02-ES6语法","date":"2016-10-31T11:34:58.000Z","updated":"2018-03-11T13:37:07.273Z","comments":true,"path":"2016/10/31/20161031_ReactNative自学02-ES6语法/","link":"","permalink":"http://www.whoosh.site/2016/10/31/20161031_ReactNative自学02-ES6语法/","excerpt":"","text":"简介ECMAScript 6.0（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 JavaScript的创造者Netscape公司，之后将JavaScript提交给国际标准化组织ECMA，希望这种语言能够成为国际标准，ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现， 之所以不叫JavaScript，主要是由于以下两个原因： 商标，Java是Sun公司的商标，根据授权协议，只有Netscape公司可以合法地使用JavaScript这个名字，且JavaScript本身也已经被Netscape公司注册为商标。 想体现这门语言的制定者是ECMA，不是Netscape，这样有利于保证这门语言的开放性和中立性。 变量在线将ES6代码转为ES5代码Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。这意味着，你可以用ES6的方式编写程序，又不用担心现有环境是否支持。 变量声明ES5只有2种声明变量的方法：var、function ES6共有6种声明变量的方法：var、function、let、const、import(require)、class。 1.var命令123456789101112131415161718var a = 10;var b = 20;var c = 30;var a = 10,b = 20,c = 30;var arr = [1,2,3,4,5];var a = arr[0];var b = arr[1];var c = arr[3];var obj = &#123; name: 'gary', age: 20&#125;var a = obj.name;var b = obj.age; 没有用var关键字，使用直接赋值方式声明的是全局变量，例如：1a = 10; 全局对象是最顶层的对象，在浏览器环境指的是window对象，在Node.js指的是global对象。ES5之中，全局对象的属性与全局变量是等价的。1234window.a = 1;a // 1a = 2;window.a // 2 2.function命令var 方式定义的函数，不能先调用函数，后声明，只能先声明函数，然后调用。function方式定义函数可以先调用，后声明。1234567891011aaa();//这样调用就会出错 var aaa = function()&#123; alert(\"aaa\"); &#125; aaa();//这样就不会出错 //先调用后声明 bbb(); function bbb()&#123; alert(\"bbb\"); &#125; 3.let命令 块级有效 ES5只有全局作用域和函数作用域，没有块级作用域，在ES6中，let实际上为JavaScript新增了块级作用域。 用来声明变量，用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; for循环的计数器，就很合适使用let命令。例如：1234567891011121314151617var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[5](); //10a[6](); // 10var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[5](); //5a[6](); // 6 变量提升 let不像var那样会发生“”现象1234console.log(foo); // 输出undefinedconsole.log(bar); // 报错ReferenceErrorvar foo = 2;let bar = 2; 实测结果两个都是undefined，应该是网上资料错误，可以通过Babel来了解底层原理 暂时性死区 只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。12345678910var tmp='dev';if (true) &#123; console.log(tmp); let tmp; console.log(tmp); tmp = 123; console.log(tmp);&#125; 在let命令声明变量tmp之前，都属于变量tmp的“死区”。 不允许重复声明 let不允许在相同作用域内，重复声明同一个变量。12345678910// 报错function test() &#123; let a = 10; var a = 1;&#125;// 报错function test() &#123; let a = 10; let a = 1;&#125; 因此，不能在函数内部重新声明参数。12345678function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; 4.const命令const声明一个只读的常量。一旦声明，就必须立即初始化，不能留到以后赋值。也不能改变。123const PI = 3.1415;console.log(PI); // 3.1415PI = 3;// TypeError: Assignment to constant variable. const的作用域与let命令相同：只在声明所在的块级作用域内有效，声明的常量，也与let一样不可重复声明。 const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。1234const foo = &#123;&#125;;foo.prop = 123;console.log(foo.prop);// 123foo = &#123;&#125;; // TypeError: \"foo\" is read-only var命令和function命令声明的全局变量，依旧是全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。也就是说，从ES6开始，全局变量将逐步与全局对象的属性脱钩。123456var a = 1;// 如果在Node的REPL环境，可以写成global.a// 或者采用通用方法，写成this.awindow.a // 1let b = 1;window.b // undefined 5.import命令(模块)模块的功能主要由 export 和 import 组成.每一个模块都有自己单独的作用域，模块之间的相互调用关系是通过 export 来规定模块对外暴露的接口，通过import来引用其它模块提供的接口。同时还为模块创造了命名空间，防止函数的命名冲突。 ES6将一个文件视为一个模块，通过export 向外输出了一个变量。一个模块也可以同时往外面输出多个变量。1234//test.jsvar name = 'Rainbow';var age = '24';export &#123;name, age&#125;; 定义好模块的输出以后就可以在另外一个模块通过import引用。1import &#123;name, age&#125; from './test.js' 整体输入，module指令1234567//test.jsexport function getName() &#123; return name;&#125;export function getAge()&#123; return age;&#125; 通过 import * as 就完成了模块整体的导入。1import * as test form './test.js'; 通过指令 module 也可以达到整体的输入。12module test from 'test.js';test.getName(); 不用关心模块输出了什么，通过 export default 指令就能加载到默认模块，不需要通过 花括号来指定输出的模块,一个模块只能使用 export default 一次123456789101112// default 导出export default function getAge() &#123;&#125; // 或者写成function getAge() &#123;&#125;export default getAge;// 导入的时候不需要花括号import test from './test.js';// 一条import 语句可以同时导入默认方法和其它变量.import defaultMethod, &#123; otherMethod &#125; from 'xxx.js'; 7.class命令如果你用过纯面向对象语言，那么你会对class的语法非常熟悉。1234567891011class People &#123; constructor(name) &#123; //构造函数 this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;var p = new People(\"Tom\");p.sayName(); 上面定义了一个People类，他有一个属性 name 和一个方法 sayName()，还有一个构造函数。 就像函数有函数声明和函数表达式两种定义方式，类也可以通过类表达式来定义： 1234567891011121314151617181920212223let People = class &#123; constructor(name) &#123; //构造函数 this.name = name; &#125; sayName() &#123; console.log(this.name); &#125; &#125;``` 你可能以为类声明和类表达式的区别在于变量提升的不同。但是事实是无论是类声明还是类表达式的方式来定义，都不会有变量提升。通过关键字 extends 来继承一个类，并且，可以通过 super 关键字来引用父类。```jsclass Student extends People &#123; constructor(name, grade) &#123; //构造函数 super(name); //通过 super 调用父类的构造函数的。 this.grade = grade; &#125; sayGrade() &#123; console.log(this.grade); &#125;&#125; 上面的例子中我们定义了一个 Student ，他是 People 的子类。下面我们给 name 属性定义 getter 和 setter123456789101112131415161718class People &#123; constructor(name) &#123; //构造函数 this.name = name; &#125; get name() &#123; return this._name.toUpperCase(); &#125; set name(name) &#123; this._name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;var p = new People(\"tom\");console.log(p.name); //TOMconsole.log(p._name); //tomp.sayName(); //TOM 仔细看上面的例子，搞清楚最后三行分别会输出什么，就明白getter 和 setter该怎么用了。 主要是要区分 this._name 和 this.name 的区别。因为我们定义了 name 的读写器，而没有定义 _name 的读写器，所以访问这两个属性的结果是不同的。 但是要注意一点，不要这样写：123set name(name) &#123; this.name = name;&#125; 因为给 this.name 赋值的时候会调用 set name ，这样会导致无限递归直到栈溢出。 通过 static 关键字定义静态方法：123456789101112class People &#123; constructor(name) &#123; //构造函数 this.name = name; &#125; sayName() &#123; console.log(this.name); &#125; static formatName(name) &#123; return name[0].toUpperCase() + name.sustr(1).toLowerCase(); &#125;&#125;console.log(People.formatName(\"tom\")); 解构赋值ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 模式匹配只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。 如果解构不成功，变量的值就等于undefined。12345678910111213141516171819202122232425let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [x, , y] = [1, 2, 3];//不完全解构x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // \"a\"y // undefinedz // []//解构赋值允许指定默认值。var [foo = true] = [];foo // true[x, y = 'b'] = ['a']; // x='a', y='b'[x, y = 'b'] = ['a', undefined]; // x='a', y='b' 注意，ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError 解构赋值不仅适用于var命令，也适用于let和const命令。123var [v1, v2, ..., vN ] = array;let [v1, v2, ..., vN ] = array;const [v1, v2, ..., vN ] = array; 对于Set结构，也可以使用数组的解构赋值。12let [x, y, z] = new Set([\"a\", \"b\", \"c\"]);x // \"a\" 对象的解构赋值解构不仅可以用于数组，还可以用于对象。123var &#123; foo, bar &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;foo // \"aaa\"bar // \"bbb\" 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。123456var &#123; bar, foo &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;foo // \"aaa\"bar // \"bbb\"var &#123; baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;baz // undefined 如果变量名与属性名不一致，必须写成下面这样。123456var &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;baz // \"aaa\"let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world' 这实际上说明，对象的解构赋值是下面形式的简写。1var &#123; foo: foo, bar: bar &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;; 也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。123var &#123; foo: baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;baz // \"aaa\"foo // error: foo is not defined 变量的解构赋值变量的声明和赋值是一体的。对于let和const来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。1234let foo;let &#123;foo&#125; = &#123;foo: 1&#125;; // SyntaxError: Duplicate declaration \"foo\"let baz;let &#123;bar: baz&#125; = &#123;bar: 1&#125;; // SyntaxError: Duplicate declaration \"baz\" 上面代码中，解构赋值的变量都会重新声明，所以报错了。不过，因为var命令允许重新声明，所以这个错误只会在使用let和const命令时出现。如果没有第二个let命令，上面的代码就不会报错。 如果要将一个已经声明的变量用于解构赋值，必须非常小心。1234// 错误的写法var x;&#123;x&#125; = &#123;x: 1&#125;;// SyntaxError: syntax error 上面代码的写法会报错，因为JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。12// 正确的写法(&#123;x&#125; = &#123;x: 1&#125;); 数组的解构赋值由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。1234var arr = [1, 2, 3];var &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3 结构的解构赋值和数组一样，解构也可以用于嵌套结构的对象。123456789var obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;var &#123; p: [x, &#123; y &#125;] &#125; = obj;x // \"Hello\"y // \"World\" 注意，这时p是模式，不是变量，因此不会被赋值。123456789101112var node = &#123; loc: &#123; start: &#123; line: 1, column: 5 &#125; &#125;&#125;;var &#123; loc: &#123; start: &#123; line &#125;&#125; &#125; = node;line // 1loc // error: loc is undefinedstart // error: start is undefined 默认值生效的条件是，对象的属性值严格等于undefined。 字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。123456const [a, b, c, d, e] = 'hello';a // \"h\"b // \"e\"c // \"l\"d // \"l\"e // \"o\" 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。12let &#123;length : len&#125; = 'hello';len // 5 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。1234let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。 函数参数的解构解构赋值的规则是，只要等号右边的值不是对象，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。12let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 函数参数的解构也可以使用默认值。1234567function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。1234567function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0] 函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。 事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。12345678910function* fibs() &#123; var a = 0; var b = 1; while (true) &#123; yield a; [a, b] = [b, a + b]; &#125;&#125;var [first, second, third, fourth, fifth, sixth] = fibs();sixth // 5 解构赋值用途 交换变量的值1[x, y] = [y, x]; 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。 从函数返回多个值函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。 12345678910111213// 返回一个数组function example() &#123; return [1, 2, 3];&#125;var [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;var &#123; foo, bar &#125; = example(); 函数参数的定义 解构赋值可以方便地将一组参数与变量名对应起来。123456// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 提取JSON数据 解构赋值对提取JSON对象中的数据，尤其有用。12345678var jsonData = &#123; id: 42, status: \"OK\", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, \"OK\", [867, 5309] 上面代码可以快速提取JSON数据的值。 函数参数的默认值1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;; 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || &#39;default foo&#39;;这样的语句。 遍历Map结构任何部署了Iterator接口的对象，都可以用for…of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。12345678var map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + \" is \" + value);&#125;// first is hello// second is world 如果只想获取键名，或者只想获取键值，可以写成下面这样。12345678// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; 输入模块的指定方法 加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。1const &#123; SourceMapConsumer, SourceNode &#125; = require(\"source-map\"); 编程风格采用严格模式：use strict主要有以下限制： 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀0表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global* [prop] eval不会在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface） let取代var在块级作用域下，let完全可以取代var，因为两者语义相同，而且let没有副作用。 在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。所有的函数都应该设置为常量。这符合函数式编程思想，有利于将来的分布式运算。const声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。 长远来看，JavaScript可能会有多线程的实现（比如Intel的River Trail那一类的项目），这时let表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。 字符串静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。 解构赋值使用数组成员对变量赋值时，优先使用解构赋值。 函数的参数如果是对象的成员，优先使用解构赋值。 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。 对象单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。 另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。 数组使用扩展运算符（…）拷贝数组。 使用Array.from方法，将类似数组的对象转为数组。 函数立即执行函数可以写成箭头函数的形式。 那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了this。 简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。 不要在函数体内使用arguments变量，使用rest运算符（…）代替。因为rest运算符显式表明你想要获取参数，而且arguments是一个类似数组的对象，而rest运算符可以提供一个真正的数组。 Map结构注意区分Object和Map，只有模拟现实世界的实体对象时，才使用Object。如果只是需要key: value的数据结构，使用Map结构。因为Map有内建的遍历机制。 Class总是用Class，取代需要prototype的操作。因为Class的写法更简洁，更易于理解。 使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。 模块首先，Module语法是JavaScript模块的标准写法，坚持使用这种写法。使用import取代require。 如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，不要export default与普通的export同时使用。 不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。 如果模块默认输出一个对象，对象名的首字母应该大写。 网络资源http://www.w3school.com.cn/js/index.asp http://es6.ruanyifeng.com/ http://babeljs.io/","categories":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://www.whoosh.site/categories/ReactNative/"}],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://www.whoosh.site/tags/ReactNative/"},{"name":"ES6","slug":"ES6","permalink":"http://www.whoosh.site/tags/ES6/"}]},{"title":"ReactNative自学01-基础篇","slug":"20160925_ReactNative自学01-基础篇","date":"2016-09-25T10:59:58.000Z","updated":"2018-03-11T13:37:07.249Z","comments":true,"path":"2016/09/25/20160925_ReactNative自学01-基础篇/","link":"","permalink":"http://www.whoosh.site/2016/09/25/20160925_ReactNative自学01-基础篇/","excerpt":"","text":"React-Native技术背景目前跨平台移动开发主要分一下4个主要流派为：Web流，代码转换流，编译流，和虚拟机流。 Web 流：也被称为 Hybrid 技术，它基于 Web 相关技术来实现界面及功能 代码转换流：将某个语言转成 Objective-C、Java 或 C#，然后使用不同平台下的官方工具来开发 编译流：将某个语言编译为二进制文件，生成动态库或打包成 apk/ipa/xap 文件 虚拟机流：通过将某个语言的虚拟机移植到不同平台上来运行 facebook之前投入了大量精力在html5，虽然取得很大进展，但始终不如人意，后来就转向native开发，性能和体验都近乎完美，但无法摆脱苹果的束缚，在版本更新和维护上非常的麻烦，同时，一些公司采用混合开发模式（Hybrid）即：native+web,但是webview的性能在移动断是受限的，所以也不是一种特别好的模式。 之后，facebook在react框架基础上推出react-native(react.js用于开发网页)，在性能上仅次于native，但比Hybrid和html5优越很多。同时，RN不仅可以使用前端开发的模式开发应用，还可以调用原生应用的UI和组件 现在除了Facebook，很多大公司都在尝试这一技术来降低开发和维护成本，如：淘宝部分功能、qq空间、携程部分产品等，而且微软未来在UWP应用上也会支持RN技术。 搭建开发环境 安装node.js，会自动安装包管理器npm，查看安装结果node -v, npm -v 安装java开发环境，java sdk、java jdk，并配置java环境变量，查看环境变量echo %path% 配置环境变量,在系统环境中添加JAVA_HOME,在Path中添%JAVA_HOME%/bin 安装android开发环境，并配置android环境变量 在系统环境中添加ANDROID_HOME,在Path中添加 %ANDROID_HOME%\\tools %ANDROID_HOME%\\platform_tools 在系统环境中添加CLASSPATH,值：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar 下载Android SDK, Tools:Android SDK Tools、Android SDK Platform-tools、Android SDK Build tools（必须是版本23.0.1） Android 6.0(API23):SDK Platform、Google APIs、Soucre for Android SDK（如果装虚拟机：Google APIs Intel x86 Atom_64 System Image） Extras:Android Support Repository、Android Support Libarary（Obsolete）、Google USB Driver（如果虚拟机：Inter x86 Emulator Accelerate[HAXM install]） 安装代码编辑环境，我使用的是vscode,可以很方便的调试程序，也可以使用WebStorm。首先，安装react native tools插件，安装Bable ES6/Es7插件 安装代码版本工具，git，方便项目管理，和clone开源资源（可选） 第一个RN项目切换npm镜像12npm config set registry https://registry.npm.taobao.orgnpm config set disturl https://npm.taobao.org/dist 安装react-native-cli1npm install react-native-cli -g //全局安装cli 初始化实例1react-native init Mytest NPM加载开源包123npm install //安装project.json中的资源包npm install 包名 -save //最新版本npm install 包名@2.1.1 -save //指定版本 运行RN项目12react-native run-androidreact-native run-ios 其他常用命令1234567adb devices //查看当前连接设备adb reverse tcp:8081 tcp:8081 //重新链接设备adb shell input keyevent 82 //调出开发者菜单npm cache clean //清理npm本地缓存npm kill-server //结束npmnpm start-server //开启npmreact-native upgrade //更新react-native版本 相关资源 RN官网： http://facebook.github.io/react-native/docs/getting-started.html RN中文官网： http://reactnative.cn/ ES语法： http://es6.ruanyifeng.com/ Android资源：http://www.android-studio.org/ npm淘宝镜像：http://npm.taobao.org/ 所用软件：百度网盘 密码：oo3t","categories":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://www.whoosh.site/categories/ReactNative/"}],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://www.whoosh.site/tags/ReactNative/"}]},{"title":"Markdown语法简介","slug":"20160901_Markdown语法简介","date":"2016-09-01T12:30:58.000Z","updated":"2018-03-16T15:20:56.985Z","comments":true,"path":"2016/09/01/20160901_Markdown语法简介/","link":"","permalink":"http://www.whoosh.site/2016/09/01/20160901_Markdown语法简介/","excerpt":"","text":"概述Markdown 是一个 Web 上使用的文本到HTML的转换工具，可以通过简单、易读易写的文本格式生成结构化的HTML文档。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。 Markdown 并非要取代 HTML，而是以一种简单的书写格式，实现一种更加友好的页面呈现，并且，如果所需的标签不在 Markdown 涵盖范围之内，可以直接在文档里面用 HTML 撰写。但要制约的只有一些 HTML 区块元素――比如 &lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt; 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。 另外 Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 &lt;p&gt; 标签，且书写时一定要在 Markdown 标签和内容之间加上空格，例如：# 标题 基本标签段落一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。 如图所示： 换行Markdown 允许段落内的强迫换行，例如直接插入换行符&lt;br/&gt;，如果你确实想要依赖 Markdown 的格式来换行的话，可以在插入处先按入两个以上的空格或者至少一个 Tab 键，然后回车即可。 如图所示： 缩进普通段落不该用空格或制表符来缩进，因为用了也无效，可以通过在段落前添加需要的空格编码，已达到显示效果。 半角空格 &amp;ensp; 或 &amp;#8194; 全角空格 &amp;emsp; 或 &amp;#8195; 不断行空格 &amp;nbsp; 或 &amp;#160; 如图所示： 标题Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。 类 Setext 形式是用底线的形式，利用任意数量的 = （一级标题）和 - （二级标题） 类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 一级 到 六级 如图所示： 列表Markdown 支持有序列表和无序列表。 无序列表使用星号、加号或是减号作为列表标记 有序列表则使用数字接着一个英文句点，如果排序错乱，Markdown 仍会以第一个数字进行排序，所以，第一个项目最好还是从 1. 开始 区块引用Markdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式。 可以自己先将内容断好行，然后在每行的最前面加上在每一行加上 &gt; ，如区块引用1 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ，如区块引用2 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ，如区块引用2，3 如图所示： 代码 如果要标记一小段行内代码，你可以用反引号把它包起来，如： `代码` 如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段 代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号 在代码区段内，&amp; 和方括号都会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易 如图所示： 代码区块在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以 如图所示： 超链接超链接允许两种样式： 行内式和参考式。 行内式的形式为： 方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字 接着一个冒号 接着一个以上的空格或制表符 接着链接的网址 选择性地接着 title 内容，可以用单引号、双引号或是括弧包着，最好使用双引号 参考式的形式为： 在链接文字的括号后面再接上另一个方括号 而在第二个方括号里面要填入用以辨识链接的标记 如图所示： 图片Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。 其形式为： 一个惊叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 title 文字。 如图所示： 表格Markdown 的表格格式虽然简单，但制作起来是很不容易的。 如图所示： 强调Markdown 使用星号 * 和底线 _ 作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 &lt;em&gt; 标签包围，用两个 或 _ 包起来的话，则会被转成 &lt;strong&gt;。但是，如果你的 `或_` 两边都有空白的话，它们就只会被当成普通的符号。 如图所示： 分隔线Markdown 允许在一行中用三个以上的星号、减号、底线来建立一个分隔线，也可以在星号或是减号中间插入空格，但行内不能有其他东西。 如图所示： 其他反斜杠Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \\ 反斜线` 反引号* 星号_ 底线{} 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 自动链接Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接&lt;http://baidu.com/&gt; 如图所示： 特殊字符在 HTML 文件中，有两个字符需要特殊处理： &lt; 和 &amp; 。 &lt; 符号用于起始标签，&amp; 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式 &amp;lt; 和 &amp;amp;。但是 code 范围内，不论是行内还是区块， &lt; 和 &amp; 两个符号都一定会被转换成 HTML 实体 推荐MarkDown 中文 VSCode 代码编辑器","categories":[{"name":"Development Language","slug":"Development-Language","permalink":"http://www.whoosh.site/categories/Development-Language/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://www.whoosh.site/tags/Markdown/"}]},{"title":"树莓派3 声音传感器(Win10 IoT)","slug":"20160425_树莓派3 声音传感器-Win10","date":"2016-04-24T16:35:58.000Z","updated":"2018-03-11T13:37:07.209Z","comments":true,"path":"2016/04/25/20160425_树莓派3 声音传感器-Win10/","link":"","permalink":"http://www.whoosh.site/2016/04/25/20160425_树莓派3 声音传感器-Win10/","excerpt":"","text":"序这段时间太忙了，项目收尾一直没有时间继续捣鼓树莓派，正好趁这个双休抽点时间来和我的小伙伴玩耍一把。上篇文章提到我想用Win10 Iot Core和买来的一堆传感器摩擦出一些火花，虽然，已经有很多前辈做过，但是我没有做过啊，没做过又怎么能体会到实践的乐趣呢。先来一张传感器全家福吧！ 声音传感器这么一大堆传感器，要先玩那个呢，啊！纠结症又犯了，挑挑拣拣了好久，最后决定先搞一个简单点的—声音检测传感器。 那么，接下来就是看资料了，还好店家提供相关技术文档，这里为避嫌，就不提供店家地址。其实原理很简单，电路图如下： 以下是我摘录的： 模块描述 可以检测周围环境的声音强度 ,使用注意：此传感器只能识别声音的有无（根据震动原理）不能识别声音的大小或者特定频率的声音 灵敏度可调（图中蓝色数字电位器调节） 工作电压3.3V-5V 输出形式数字开关量输出（0和1高低电平）模块接口说明 VCC外接3.3V-5V电压（可以直接与 5v 单片机和3.3v单片机相连） GND外接GND DO小板数字量输出接口（0和 1）使用说明 声音模块对环境声音强度最敏感，一般用来检测周围环境的声音强度。 模块在环境声音强度达不到设定阈值时，DO口输出高电平，当外界环境声音强度超过设定阈值时，模块 D0输出低电平 小板数字量输出 D0可以与单片机直接相连，通过单片机来检测高低电平，由此来检测环境的声音 检查传感器了解了声音传感器基本结构后，我们要做的就是检查声音传感器是否正常：在相对安静的环境中，将模块的VCC接到树莓派的3.3V PWR电源正极上，将模块的GND接到树莓派的GND上（我选了39），此时，模块的电源指示灯会亮，说明你的传感器OK。如果开关提示也亮了，说明传感器对当前环境声音太灵敏了，可以调节蓝色数字电位器，使之灵敏度降低。附上测试接线图和树莓派GPIO引脚位置图： 如何接线我使用了6根杜邦线（3根公对母，3根公对公），具体接线步骤： 将第一根公对母杜邦线母端接到树莓派3.3V PWR电源引脚上，公端接到面包 板的正极上（红线） 将第二根公对母杜邦线母端接到树莓派GND负极引脚上，公端接到面包板负极上（棕线） 将第三根公对母杜邦线母端接到树莓派GPIO 5引脚上，公端接到LED灯长脚上（灰线） 将第一根公对公杜邦线的一端接到面包板电源正极上，另一端接到传感器VCC上（红线） 将第二根公对公杜邦线的一端接到面包板电源负极上，另一端接到传感器GND上（棕线） 将最后一根公对公杜邦线的一端接到传感器的OutPut(DO)上，另一端接到LED等的短脚上（紫线）。 最后接线如图所示： 代码实现见证奇迹的时刻到了，新建一个UWP空白应用（通用Windows），将以下代码粘到MainPage中，然后部署到树莓派中的Win10中即可。至于怎么安装系统、部署应用和web远程控制，待我下次整理出一个文档，当然，你也可以自己在网上搜。另外：源码来源于网友汪宇杰Edi.Wang。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public sealed partial class MainPage : Page &#123; //LED灯引脚 public GpioPin LedPin &#123; get; set; &#125; //声音传感器引脚 public GpioPin SoundPin &#123; get; set; &#125; //保存LED灯的开关状态 public bool IsLightOn &#123; get; set; &#125; public MainPage() &#123; this.InitializeComponent(); Loaded += OnLoaded; &#125; /// &lt;summary&gt; /// Loaded事件 /// &lt;/summary&gt; /// &lt;param name=\"sender\"&gt;&lt;/param&gt; /// &lt;param name=\"routedEventArgs\"&gt;&lt;/param&gt; private void OnLoaded(object sender, RoutedEventArgs routedEventArgs) &#123; //初始化GPIO控制器 var controller = GpioController.GetDefault(); if (null != controller) &#123; //LED是高电平输出表示开，所以第一次启动的时候要关灯，输出低电平 LedPin = controller.OpenPin(5); LedPin.SetDriveMode(GpioPinDriveMode.Output); LedPin.Write(GpioPinValue.Low); //FC-04的GPIO 06端口是接受信号的，所以是输入 SoundPin = controller.OpenPin(6); SoundPin.SetDriveMode(GpioPinDriveMode.Input); //监测声音传感器引脚值得变化 SoundPin.ValueChanged += (pin, args) =&gt; &#123; //读取引脚值（FC-04传感器只有两个值0、1） var pinValue = SoundPin.Read(); //FC-04检测到声音时候会在DO输出低电平 if (pinValue == GpioPinValue.Low) &#123; Debug.WriteLine(\"Sound Detected!\"); //开关灯操作（设置LED引脚值） LedPin.Write(IsLightOn ? GpioPinValue.Low : GpioPinValue.High); IsLightOn = !IsLightOn; &#125; &#125;; &#125; &#125; &#125; 总结在实践过程中遇到了不少问题，毕竟是小白，有很多不懂不会的地方，但是，还是那句话，只要思想不倒退，办法总比困难多。最后，来看一下效果图吧！","categories":[{"name":"树莓派","slug":"树莓派","permalink":"http://www.whoosh.site/categories/树莓派/"}],"tags":[{"name":"树莓派3","slug":"树莓派3","permalink":"http://www.whoosh.site/tags/树莓派3/"},{"name":"传感器","slug":"传感器","permalink":"http://www.whoosh.site/tags/传感器/"},{"name":"Win10 IoT","slug":"Win10-IoT","permalink":"http://www.whoosh.site/tags/Win10-IoT/"}]},{"title":"树莓派3 使用体验","slug":"20160410_树莓派3 使用体会","date":"2016-04-10T15:35:00.000Z","updated":"2018-03-16T15:23:47.629Z","comments":true,"path":"2016/04/10/20160410_树莓派3 使用体会/","link":"","permalink":"http://www.whoosh.site/2016/04/10/20160410_树莓派3 使用体会/","excerpt":"","text":"序以前听说过树莓派，那时候感觉这玩意离自己很遥远，都是一些极客才会玩的东西。但是，随着微软针对Raspberry Pi推出的Win10 Iot Core版本，便勾起了我的兴趣了，没办法，谁叫我是一个资深软粉呢！虽说有兴趣，但真要买一个玩玩，还是下了很大决心的，主要原因并不是浪费钱（板子不贵，240左右天朝币），而是根据微软这么多年的尿性，怕学了也没什么卵用。当年搞WP开发就被坑了，好在也学到了不少东西，嗯，就这样安慰自己吧。 树莓派3一出来，我就坐不住了，上一周在X宝上攒了一套，包括主板，还有一堆的配件（各种传感器、面包板、杜邦线、小零件），要吐槽一下快递，这种东西店家一般都要收快递费，所以要买的话，一次性买齐。而且不巧的是，当时正赶上深圳的禁摩限电，搞了一周才到货。 还要说一下杜邦线，我拿到货就傻眼了，40根全是母对母的，本以为是公对母的呢，最后想了个办法，把缝衣针折断来替代，也是醉了。说了这么多废话，接下来进入正题。 先来一张定妆照： 使用体验那么这几天我都用这货干了些什么呢，先来看一下有哪些系统可以跑在树莓派上呢，Raspberry Pi官网给出了如下图系统，这些系统下载地址都可以在这个页面中找到，我就尝试了下图中箭头所指的4个系统，那么就逐个来说说体验过程中遇到的问题吧。 RaspBian官方支持的操作系统，Noobs是一个比RaspBian更容易安装的版本，其实都很简单的，网上有这方面的教程，就是通过win32diskimager-v0.9-binary，将img镜像写入到SD卡中，然后把SD卡插到主板上，通电就OK了。我就不在赘述了点击下载 需要强调的是，如果你没有显示器，可以使用替代方法，例如：远程访问，根据上面地址文章中的步骤，进入到RaspBian系统后，安装Linux下远程桌面xrdp即可在window下通过远程桌面访问到桌面版的RaspBian了。 安装远程访问xrdp命令 1sudo apt-get install xrdp Ubuntu Mate使用这个系统的时候，我也想着像上一个步骤那样，通过远程访问来搞定，但现实是残酷滴，我无法知道Ubuntu系统的用户名和密码，就没法登陆进去，这可难倒我了，最终还是办法总是多于困难的，现在的电视机一半都自带VGA或者HDMI接口，这个时候，就可以通过HDMI线或者HDMI转VGA接头连接到电视上，要说明的是，网上说HDMI转接头最好需要带外部电源的，可是我用了个无源的转接头也是Ok的，前提是主板电源输出不要太低，官方说是2.5A，实际上我用的是2.0A。 另外，如果用HDMI直链电视的话，国内的电视显示器分辨率很杂，我家里的就是，接上去也通电了，但就是黑屏，于是各种查啊。这里就需要修改系统分区下config.txt文件，建议使用notepad++打开文档，添加或修改配置项hdmi_ignore_edid=0xa5000080，具体步骤请移步。 Win10 IoT话说我就是因为Win10才买树莓派的，物联网要火了，不能掉队伍不是。而且，在编程方面也有基础，官方提供了很多Demo，光看源码不实操，心里是很痒的，哈哈。所以一拿到货我就装了Win10的系统，需要提醒的是，如果和我一样，使用的是树莓派3，那么就需要下最新版本的系统了，win10正式版10586是不支持Pi3的，之后的可以。而且现在最新的版本系统（14295）还不支持wifi和蓝牙，我就是冲着Pi3自带wifi和蓝牙才放弃pi2的，感谢网友汪宇杰Edi.Wang的告知。 说一下开发过程中遇到的一个坑，按照官方提供的点亮LED程序，发现没法点亮LED灯，导致我一直以为是我接线出了问题，可是接线实在是太简单了，这都错智商岂不是没救了，后来在VS中自己跑了一遍源码，居然就点亮了，真是我勒个去啊。附上官方地址 这里很多文档可以参考，另外Demo下载地址。 OpenElec这个系统是什么货呢，可能知道它的人不多，说通俗点吧，它是多媒体终端系统，可以用作电视盒子，以前叫XBMC现在叫Kodi,装了这个系统，树莓派瞬间就变成了电视盒子了，系统安装过程和装Ubuntu Mate是一样的，装好了如何配置就稍微复杂一些，主要是在更换中文语言的地方一个坑，还有就是想看国内视频网站或电视直播，需要下载中文插件库，好在网上有很多教程，按照教程走问题都不大的，附上教程地址 总结树莓派的可玩性是很强的，可以用它来做一些很有趣的事情，但是怎么有趣就要自己去发掘了。另外，记得我上文提到我买了一堆的传感器吧，接下来，我就要尝试在win10 iot下和这些传感器玩耍了，再次感谢这方面的先锋战士Edi.Wang。","categories":[{"name":"树莓派","slug":"树莓派","permalink":"http://www.whoosh.site/categories/树莓派/"}],"tags":[{"name":"树莓派3","slug":"树莓派3","permalink":"http://www.whoosh.site/tags/树莓派3/"}]}]}